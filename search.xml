<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python通过GeoIP获取IP信息（国家、城市、经纬度等）</title>
      <link href="/posts/2c5697c0/"/>
      <url>/posts/2c5697c0/</url>
      
        <content type="html"><![CDATA[<p>IP地址信息是非常重要的情报信息，通过IP可以定位到该IP所在的国家、城市、经纬度等。<br>获取IP信息的方式有很多，很多服务商都提供了相应的地址库或API接口服务。<br>如国内的ipip.net，国外的ip-api.com、maxmind.com等。<br>很多公司都是使用Maxmind网站的IP信息库，里面包含着IP的详细信息，有付费的也有免费的，收费与免费的区别就是精准度和覆盖率。</p><p>本文介绍下载及定时更新Maxmind的离线库用python通过GeoIP来获取IP信息 </p><h1 id="一、下载GeoLite2离线地址库"><a href="#一、下载GeoLite2离线地址库" class="headerlink" title="一、下载GeoLite2离线地址库"></a>一、下载GeoLite2离线地址库</h1><h2 id="1、注册及申请License-Key"><a href="#1、注册及申请License-Key" class="headerlink" title="1、注册及申请License Key"></a>1、注册及申请License Key</h2><p>下载地址库之前先要在Maxmind网站注册同意相应的协议并登陆。</p><h3 id="1）注册"><a href="#1）注册" class="headerlink" title="1）注册"></a>1）注册</h3><p>访问 <a href="https://dev.maxmind.com/geoip/geolite2-free-geolocation-data" target="_blank" rel="noopener">https://dev.maxmind.com/geoip/geolite2-free-geolocation-data</a><br><img src="https://img-blog.csdnimg.cn/e4fcf9f4aa7a49888805da7ac7be650b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="Maxmiand注册导航"><br>点击”Sign Up for GeoLite2” 根据输入框进行注册<br><img src="https://img-blog.csdnimg.cn/1a9dbfe1d10747caaf22179dac0fb077.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="Maxmiand注册表单"><br>注意邮箱一定要正确，注册后会发邮件进行确认及修改密码。<br>根据注册的用户名和修改后的密码登陆就可以直接下载离线包了。<br><img src="https://img-blog.csdnimg.cn/358c4741c75544e1a3d3761fdd337274.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="Maxmind账号信息"><br>点击”Download Databases”进入到下载页面，可以看到提供了CSV及mmdb两种格式的离线库包，最近的更新时间为2021年11月02日。<br><img src="https://img-blog.csdnimg.cn/9196090e03384dc99cfd3d6b5c37627d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="MaxmiandGeoLite2地址库下载"><br>由于IP地址信息是经常有变化的，Maxmind提供了geoipupdate工具来更新离线地址包。该工具使用需要申请账号和License Key</p><h3 id="2）申请License-Key"><a href="#2）申请License-Key" class="headerlink" title="2）申请License Key"></a>2）申请License Key</h3><p>还是通过刚注册的引导页面，点击“Generate a License Key”<br><img src="https://img-blog.csdnimg.cn/1386d73167524690bca90a8118bff1f8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="Maxmind生成License导航页"><br>进如到页面后，点击“Generate new license key”<br><img src="https://img-blog.csdnimg.cn/aa44150be07a4bdcbbf0d7fe48c1d0ed.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="Generate new license key"><br><img src="https://img-blog.csdnimg.cn/a1865478abf74092b903b3c060f8b3ac.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="License Key生成确定页"><br>点击确定以后就会生成账号及License key<br><img src="https://img-blog.csdnimg.cn/4eef17f7d1224c279c78b5730d1e2e43.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="License key生成"></p><h2 id="2、下载并配置geoipupdate"><a href="#2、下载并配置geoipupdate" class="headerlink" title="2、下载并配置geoipupdate"></a>2、下载并配置geoipupdate</h2><p><a href="https://github.com/maxmind/geoipupdate" target="_blank" rel="noopener">https://github.com/maxmind/geoipupdate</a><br>这里有详细的安安装及配置说明</p><p>发行版本下载地址 <a href="https://github.com/maxmind/geoipupdate/releases" target="_blank" rel="noopener">https://github.com/maxmind/geoipupdate/releases</a><br><img src="https://img-blog.csdnimg.cn/44213d6d1dc74e1b871e3327958fe2f9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>可以看到提供了各种平台的版本的下载链接，这里我们下载安装的是linux版本，点击下载“geoipupdate_4.8.0_linux_amd64.tar.gz”<br>在home目录下执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/maxmind/geoipupdate/releases/download/v4.<span class="number">8.0</span>/geoipupdate_4.<span class="number">8.0</span>_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>下载至home目录</p><p>tar -zxvf geoipupdate_4.8.0_linux_amd64.tar.gz 进行解压<br>cd geoipupdate_4.8.0_linux_amd64  目录执行ls -alh查看目录内容，发现有两个关键文件，一个是getipupdate命令执行文件，一个是GeoIP.conf配置文件<br><img src="https://img-blog.csdnimg.cn/e20bf57c217b483f938271233b52c40c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="geoipupdate目录"></p><p>将执行命令拷贝到命令文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp geoipupdate /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p>geoipupdate命令读配置文件默认为/usr/local/etc/GeoIP.conf将配置文件拷贝到/usr/local/etc/下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp GeoIP.conf /usr/<span class="built_in">local</span>/etc/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/<span class="built_in">local</span>/etc/GeoIP.conf</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/aa5ec95685da4abd9cb3edfa24ea4375.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="修改GeoIP.conf"><br>如上图修改离线库文件目录及账号、LicenseKey，AccountID和LicenseKey就是开始在Maxmind网站上申请的。</p><h2 id="3、运行geoipupdate命令并加入定时任务"><a href="#3、运行geoipupdate命令并加入定时任务" class="headerlink" title="3、运行geoipupdate命令并加入定时任务"></a>3、运行geoipupdate命令并加入定时任务</h2><p>执行geoipupdate命令，在目录下面产生了GeoLite2-City.mmdb、GeoLite2-Country.mmdb两个离线库文件。<br><img src="https://img-blog.csdnimg.cn/9d1249f69cf84d9c90b690ca3efaa35c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GeoLite2离线库文件"><br>创建Linux定时任务，每周自动更新一下离线库文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab <span class="literal">-e</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> * * <span class="number">0</span> /usr/local/bin/geoipupdate</span><br></pre></td></tr></table></figure><h1 id="二、通过Python调用GeoIP获取IP信息"><a href="#二、通过Python调用GeoIP获取IP信息" class="headerlink" title="二、通过Python调用GeoIP获取IP信息"></a>二、通过Python调用GeoIP获取IP信息</h1><p>默认已经安装好了Flask环境，并激活了python虚拟环境。激活python虚拟环境安装Flask教程见<a href="http://xiejava.ishareread.com/posts/7f405b25/" target="_blank" rel="noopener">http://xiejava.ishareread.com/posts/7f405b25/</a></p><h2 id="1、安装geoip2"><a href="#1、安装geoip2" class="headerlink" title="1、安装geoip2"></a>1、安装geoip2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install geoip2</span><br></pre></td></tr></table></figure><h2 id="2、编写hello-py调用geoip2"><a href="#2、编写hello-py调用geoip2" class="headerlink" title="2、编写hello.py调用geoip2"></a>2、编写hello.py调用geoip2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi hello.py</span><br></pre></td></tr></table></figure><p>复制以下代码到hello.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">import</span> geoip2.database</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">reader=geoip2.database.Reader(<span class="string">'/home/geoipupdate_4.8.0_linux_amd64/GeoLite2-City.mmdb'</span>)</span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/getip/&lt;ip&gt;")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getip</span><span class="params">(ip)</span>:</span></span><br><span class="line">    ipinfo=reader.city(ip)</span><br><span class="line">    ipinfo_json=&#123;<span class="string">'country'</span>:ipinfo.country.name,<span class="string">'city'</span>:ipinfo.city.name,<span class="string">'location'</span>:[ipinfo.location.longitude,ipinfo.location.latitude]&#125;</span><br><span class="line">    <span class="keyword">return</span> ipinfo_json</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure><h2 id="3、运行hello-py"><a href="#3、运行hello-py" class="headerlink" title="3、运行hello.py"></a>3、运行hello.py</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(flask_web) [<span class="type">root</span>@<span class="type">localhost</span> <span class="type">flask_web</span>]<span class="comment"># python hello.py</span></span><br><span class="line"> * Serving Flask app <span class="string">'hello'</span> (lazy loading)</span><br><span class="line"> * Environment: production</span><br><span class="line">   WARNING: This is a development server. <span class="keyword">Do</span> not use it <span class="keyword">in</span> a production deployment.</span><br><span class="line">   Use a production WSGI server instead.</span><br><span class="line"> * Debug mode: off</span><br><span class="line"> * Running on all addresses.</span><br><span class="line">   WARNING: This is a development server. <span class="keyword">Do</span> not use it <span class="keyword">in</span> a production deployment.</span><br><span class="line"> * Running on http://<span class="number">192.168</span>.<span class="number">1.18</span>:<span class="number">8080</span>/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure><p>注意：如果linux开启了防火墙请关闭防火墙，或放开192.168.1.18</p><h2 id="4、验证"><a href="#4、验证" class="headerlink" title="4、验证"></a>4、验证</h2><p>通过浏览器访问 <a href="http://192.168.1.18:8080/getip/128.101.101.101" target="_blank" rel="noopener">http://192.168.1.18:8080/getip/128.101.101.101</a><br><img src="https://img-blog.csdnimg.cn/4cf63aac6b78465d836a6df9ccb5b4a9.png#pic_center" alt="验证IP信息"><br>可以看到返回IP的国家、城市、经纬度等信息。</p><p><strong>至此，本文介绍了如何注册并下载GeoIP离线数据包，并通过官方提供的geoipupdate进行定期更新数据。还介绍了如何通过Python调用GeoIP获取IP信息。</strong></p><p>作者博客：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7下python3+Flask+uWSGI+Nginx+Supervisor环境搭建</title>
      <link href="/posts/7f405b25/"/>
      <url>/posts/7f405b25/</url>
      
        <content type="html"><![CDATA[<p>在生产环境中通常用uwsgi作为Flask的web服务网关，通过nginx反向代理进行负载均衡，通过supervior进行服务进行的管理。这一套搭下来还是有一些坑要踩，本文通过一个简单的Flask web应用记录了CentOS7下python3+Flask+uWSGI+Nginx+Supervisor环境搭建的全过程，以及一些注意事项，以免遗忘。</p><h1 id="一、Python3环境安装"><a href="#一、Python3环境安装" class="headerlink" title="一、Python3环境安装"></a>一、Python3环境安装</h1><p>CentOS7下Python3环境安装参考 <a href="http://xiejava.ishareread.com/posts/57cef505/" target="_blank" rel="noopener">http://xiejava.ishareread.com/posts/57cef505/</a></p><p>查看python版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># python -V</span></span><br><span class="line">Python 3.8.12</span><br></pre></td></tr></table></figure><h1 id="二、安装Flask"><a href="#二、安装Flask" class="headerlink" title="二、安装Flask"></a>二、安装Flask</h1><h2 id="1、创建Python虚拟环境"><a href="#1、创建Python虚拟环境" class="headerlink" title="1、创建Python虚拟环境"></a>1、创建Python虚拟环境</h2><p>在home目录下创建flask_web目录（目录根据具体实际环境创建，本教程是/home/flask_web）<br>通过venv创建虚拟环境<br>[root@localhost flask_web]# python -m venv /home/flask_web<br>创建成功后可以看到在目录下自动建了一些文件夹，包括python命令及依赖库等，激活以后是个独立的python虚拟运行环境。<br><img src="https://img-blog.csdnimg.cn/8ad5311fc3254fefa6739c76f067b8ad.png#pic_center" alt="python虚拟运行环境"></p><p>在目录下运行source bin/activate 激活虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost flask_web]<span class="comment"># source bin/activate</span></span><br><span class="line">(flask_web) [root@localhost flask_web]<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="2、安装Flask"><a href="#2、安装Flask" class="headerlink" title="2、安装Flask"></a>2、安装Flask</h2><p>通过pip install flask安装flask</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(flask_web) [root@localhost flask_web]<span class="comment"># pip install flask</span></span><br></pre></td></tr></table></figure><p>安装的时候有可能报ModuleNotFoundError: No module named ‘_ctypes’的错误，原因是缺少libffi-devel包，具体可参考 <a href="https://blog.csdn.net/qq_36416904/article/details/79316972" target="_blank" rel="noopener">https://blog.csdn.net/qq_36416904/article/details/79316972</a><br><img src="https://img-blog.csdnimg.cn/3d4cc5ba51234b399e59ffb1e66aa0b3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="安装Flask报错"></p><p>运行yum install libffi-devel -y 并且要重新编译执行安装python<br>解决包依赖的问题<br>(flask_web) [root@localhost flask_web]# yum install libffi-devel -y<br>进入到python源码包目录 执行使用make&amp;make install 命令重新编译并安装python（这里比较坑）<br>然后再pip install flask 进行安装<br>安装完成后可以尝试运行flask run，提示没有Flask应用程序，说明flask已经安装成功并且可以运行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(flask_web) [root@localhost flask_web]<span class="comment"># flask run</span></span><br><span class="line"> * Environment: production</span><br><span class="line">   WARNING: This is a development server. Do not use it <span class="keyword">in</span> a production deployment.</span><br><span class="line">   Use a production WSGI server instead.</span><br><span class="line"> * Debug mode: off</span><br><span class="line">Usage: flask run [OPTIONS]</span><br><span class="line">Try <span class="string">'flask run --help'</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">Error: Could not locate a Flask application. You did not provide the <span class="string">"FLASK_APP"</span> environment variable, and a <span class="string">"wsgi.py"</span> or <span class="string">"app.py"</span> module was not found <span class="keyword">in</span> the current directory.</span><br></pre></td></tr></table></figure><p>3、建立测试应用<br>vi hello.py创建一个hello.py的文件，copy下面的内容到文件中:wq保存退出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>通过python hello.py运行测试程序</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(flask_web) [<span class="type">root</span>@<span class="type">localhost</span> <span class="type">flask_web</span>]<span class="comment"># python hello.py</span></span><br><span class="line"> * Serving Flask app <span class="string">'hello'</span> (lazy loading)</span><br><span class="line"> * Environment: production</span><br><span class="line">   WARNING: This is a development server. <span class="keyword">Do</span> not use it <span class="keyword">in</span> a production deployment.</span><br><span class="line">   Use a production WSGI server instead.</span><br><span class="line"> * Debug mode: off</span><br><span class="line"> * Running on http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5000</span>/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure><p>新开一个shell窗口执行curl <a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a> 可以看到有Hello World返回说明应用在flask框架下运行没有问题。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> ~]<span class="comment"># curl http://127.0.0.1:5000/</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h1 id="三、安装及配置uwsgi"><a href="#三、安装及配置uwsgi" class="headerlink" title="三、安装及配置uwsgi"></a>三、安装及配置uwsgi</h1><p>uWSGI是一个Web Server，并且独占uwsgi协议，但是同时支持WSGI协议、HTTP协议等，它的功能是把HTTP协议转化成语言支持的网络协议供python使用。有点类似于Java的web服务容器中间件tomcat</p><h2 id="1、安装uwsgi"><a href="#1、安装uwsgi" class="headerlink" title="1、安装uwsgi"></a>1、安装uwsgi</h2><p>通过pip命令安装</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(flask_web) [<span class="type">root</span>@<span class="type">localhost</span> <span class="type">flask_web</span>]<span class="comment"># pip install uwsgi</span></span><br></pre></td></tr></table></figure><p>如果顺利的话会显示Successfully installed uwsgi-2.0.20，表示安装成功了。</p><h2 id="2、配置uwsgi"><a href="#2、配置uwsgi" class="headerlink" title="2、配置uwsgi"></a>2、配置uwsgi</h2><p>新建一个uwsgi.ini配置文件，并将配置信息复制到配置文件<br>vi uwsgi.ini </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line"><span class="comment">#http=127.0.0.1:3366  #如果是http,通过proxy_pass http链接</span></span><br><span class="line">socket=127.0.0.1:3366 <span class="comment">#如果是socket，通过nginx配置uwsgi_pass socket链接</span></span><br><span class="line">wsgi-file=/home/flask_web/hello.py</span><br><span class="line">callable=app</span><br><span class="line">touch-reload=/home/flask_web/</span><br><span class="line"><span class="comment">#最大请求数，最多请求5000次就重启进程，以防止内存泄漏</span></span><br><span class="line">max-requests=5000</span><br><span class="line"><span class="comment">#请求超时时间，超过60秒关闭请求</span></span><br><span class="line">harakiri=60</span><br><span class="line"><span class="comment">#进程的数量</span></span><br><span class="line">processes=1</span><br><span class="line"><span class="comment">#线程数</span></span><br><span class="line">threads = 2</span><br><span class="line"><span class="comment">#记录pid的文件</span></span><br><span class="line">pidfile=/home/flask_web/uwsgi.pid</span><br><span class="line">buffer-size = 32768</span><br><span class="line"><span class="comment">#日志最大50M</span></span><br><span class="line"><span class="built_in">log</span>-maxsize=50000000</span><br><span class="line"><span class="comment">#配置虚拟环境路径，如果是在虚拟环境下启动，这个一定要配，不配会有些包找不到，应用会报错。可以在uwsgi.log文件中看报错信息</span></span><br><span class="line">virtualenv =/home/flask_web</span><br><span class="line"><span class="comment">#uwsgi日志文件，如果是通过supervisor托管，daemonize配置需要屏蔽</span></span><br><span class="line"><span class="comment">#daemonize=/home/flask_web/uwsgi.log</span></span><br><span class="line"><span class="comment">#项目更新后，自动加载</span></span><br><span class="line">python-autoreload=1</span><br><span class="line"><span class="comment">#状态检测地址</span></span><br><span class="line">stats = 127.0.0.1:9191</span><br></pre></td></tr></table></figure><h2 id="3、运行uwsgi"><a href="#3、运行uwsgi" class="headerlink" title="3、运行uwsgi"></a>3、运行uwsgi</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(flask_web) [root@localhost flask_web]<span class="comment"># uwsgi --ini /home/flask_web/uwsgi.ini</span></span><br></pre></td></tr></table></figure><p>启动以后通过访问curl <a href="http://127.0.0.1:3366" target="_blank" rel="noopener">http://127.0.0.1:3366</a> 有Hello World!的返回信息表示uwsgi已经成功启动，并且应用程序正常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost flask_web]<span class="comment"># curl http://127.0.0.1:3366</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h1 id="四、配置Nginx反向代理"><a href="#四、配置Nginx反向代理" class="headerlink" title="四、配置Nginx反向代理"></a>四、配置Nginx反向代理</h1><p>ps -ef|grep nginx 找到nginx的配置文件<br><img src="https://img-blog.csdnimg.cn/70323a6952c9414daad6f80370ea9f94.png#pic_center" alt="nginx配置文件"><br>如果uwsgi配置的是socket连接<br>[uwsgi]<br>socket=127.0.0.1:3366 #如果是socket，通过nginx配置uwsgi_pass socket链接<br>nginx的server配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     listen 808;</span><br><span class="line">     server_name localhost;</span><br><span class="line"></span><br><span class="line">     location / &#123;</span><br><span class="line">          include uwsgi_params;</span><br><span class="line">          uwsgi_pass 127.0.0.1:3366;</span><br><span class="line">      &#125;</span><br><span class="line">      access_log /home/flask_web/access.log;</span><br><span class="line">      error_log /home/flask_web/error.log;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果uwsgi配置的是http<br>[uwsgi]<br>http=127.0.0.1:3366  #如果是http,通过proxy_pass http链接<br>nginx的server配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">      listen 808;</span><br><span class="line">      server_name localhost;</span><br><span class="line"></span><br><span class="line">      location / &#123;</span><br><span class="line">           proxy_pass http://127.0.0.1:3366;</span><br><span class="line">       &#125;</span><br><span class="line">       access_log /home/flask_web/access.log;</span><br><span class="line">       error_log /home/flask_web/error.log;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>重新加载nginx配置后，通过浏览器访问可以正常显示访问结果</p><h1 id="五、通过Supervisor进行进程托管"><a href="#五、通过Supervisor进行进程托管" class="headerlink" title="五、通过Supervisor进行进程托管"></a>五、通过Supervisor进行进程托管</h1><p>生产环境中，可以通过supervisor来进行uwsgi和nginx进程的托管，界面化的方式管理uwsgi和nginx，包括进程的监控、启停等。</p><h2 id="1、安装supervisor"><a href="#1、安装supervisor" class="headerlink" title="1、安装supervisor"></a>1、安装supervisor</h2><p>通过pip安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure><p>离线安装请参考：<a href="http://xiejava.ishareread.com/posts/d670c9b8/" target="_blank" rel="noopener">http://xiejava.ishareread.com/posts/d670c9b8/</a></p><h2 id="2、配置supervisor"><a href="#2、配置supervisor" class="headerlink" title="2、配置supervisor"></a>2、配置supervisor</h2><p>找到supervisord的安装目录在/usr/local/bin下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]<span class="comment"># which supervisord</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/supervisord</span><br></pre></td></tr></table></figure><p>cd到/usr/local/bin目录下<br>通过echo_supervisord_conf &gt; supervisord.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]<span class="comment"># echo_supervisord_conf &gt; supervisord.conf</span></span><br></pre></td></tr></table></figure><p>可以看到生成了一个supervisord.conf的配置文件。<br>将生成的supervisord.conf配置文件放到/etc/目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv supervisord.conf /etc/</span><br></pre></td></tr></table></figure><p>修改supervisord.conf的配置文件，主要是将子配置文件路径开启并指定配置文件路径，按照惯例将配置文件放到/etc目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">files = /etc/supervisord.d/*.ini</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/049f24f7b6c54c0a892b5075f3921edc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="supervisord.conf配置文件"></p><p>我们在/etc目录下建个supervisord.d目录用来保存supervisor托管进程的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /etc/</span></span><br><span class="line">[root@localhost etc]<span class="comment"># mkdir supervisord.d</span></span><br></pre></td></tr></table></figure><p>建立并配置子配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]<span class="comment"># cd supervisord.d/</span></span><br><span class="line">[root@localhost supervisord.d]<span class="comment"># vi uwsgi.ini</span></span><br></pre></td></tr></table></figure><p>复制以下内容至uwsgi.ini文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[program:uwsgi]</span><br><span class="line"><span class="built_in">command</span> =uwsgi --ini /home/flask_web/uwsgi.ini</span><br><span class="line">directory=/home/flask_web</span><br><span class="line">startsecs=10</span><br><span class="line">startretries=5</span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line">autorestart=<span class="literal">true</span></span><br><span class="line">stdout_logfile=/home/flask_web/uwsgi_sup_log.log</span><br><span class="line">stdout_logfile_maxbytes=10MB</span><br><span class="line">user=root</span><br><span class="line">stopasgroup=<span class="literal">true</span></span><br><span class="line">killasgroup=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="3、启动supervisor"><a href="#3、启动supervisor" class="headerlink" title="3、启动supervisor"></a>3、启动supervisor</h2><p>在启动supervisor拉起uwsgi前两个注意事项</p><p>1) uwsgi的配置文件中daemonize一定要屏蔽掉，否则守护进程一直会重启，导致端口每次都被占用，Supervisor托管不了。<br><img src="https://img-blog.csdnimg.cn/8eef8e8552e047e79a9c3443074cd2cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="uwsgi.ini"><br>2) 在启动之前先将已经启动的uwsgi进程停掉，否则通过supervisor拉起uwsgi进程时端口冲突<br><img src="https://img-blog.csdnimg.cn/60fda7586d9a430f8cc5febda83cdad9.png#pic_center" alt="kill uwsgi进程"></p><p>启动supervisord进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]<span class="comment"># supervisord -c /etc/supervisord.conf</span></span><br></pre></td></tr></table></figure><p>修改配置文件后重新加载可以通过 supervisorctl reload 命令重新加载<br>查看supervisor托管状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost supervisord.d]<span class="comment"># supervisorctl status</span></span><br><span class="line">uwsgi                            STARTING</span><br></pre></td></tr></table></figure><p>可以看到uwsgi被supervisor托管并已经启动。如果需要通过supervisor的web控制界面进行进程的管理。需要修改/etc/supervisord.conf的配置文件将访问的IP地址限制放开，设置用户名、口令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[inet_http_server]         ; inet (TCP) server disabled by default</span><br><span class="line">port=*:9001        ; ip_address:port specifier, *:port <span class="keyword">for</span> all iface</span><br><span class="line">username=user              ; default is no username (open server)</span><br><span class="line">password=user@123               ; default is no password (open server)</span><br></pre></td></tr></table></figure><p>重新启动supervisor，重启时会报需要验证的错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost supervisord.d]<span class="comment"># supervisorctl shutdown</span></span><br><span class="line">Server requires authentication</span><br><span class="line">error: &lt;class <span class="string">'xmlrpc.client.ProtocolError'</span>&gt;, &lt;ProtocolError <span class="keyword">for</span> 127.0.0.1/RPC2: 401 Unauthorized&gt;: file: /usr/<span class="built_in">local</span>/lib/python3.8/site-packages/supervisor/xmlrpc.py line: 542</span><br></pre></td></tr></table></figure><p>可以直接kill -9杀掉supervisor的进程再启动，也可以通过supervisorctl 输入用户名、口令通过shutdown然后再重启。<br>启动命令：supervisord -c /etc/supervisord.conf</p><p>这时就可以通过supervisor的web控制界面进行进程的管理了。<br><img src="https://img-blog.csdnimg.cn/fdda8d39fb0343d0b7a7a570c2b1256f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="Supervisor"><br><strong>至此，CentOS7下python3+Flask+uWSGI+Nginx+Supervisor环境全部搭建好了。</strong></p><p>作者博客：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7下安装python3.8</title>
      <link href="/posts/57cef505/"/>
      <url>/posts/57cef505/</url>
      
        <content type="html"><![CDATA[<p>环境的搭建是进行开发的第一步，python因为存在python2和python3两个版本，让在建立python环境时造成不便，并且由于在Linux环境下不像Window环境安装那么友好，存在一些小坑。本教程记录了CentOS7下安装python3.8的过程和注意事项。</p><h1 id="一、查看系统版本"><a href="#一、查看系统版本" class="headerlink" title="一、查看系统版本"></a>一、查看系统版本</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/centos-release</span></span><br><span class="line">CentOS Linux release 7.2.1511 (Core)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># uname -a</span></span><br><span class="line">Linux localhost.localdomain 3.10.0-327.el7.x86_64 <span class="comment">#1 SMP Thu Nov 19 22:10:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><p>查看python版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># python -V</span></span><br><span class="line">Python 2.7.5</span><br></pre></td></tr></table></figure><p>系统默认安装了Python 2.7.5</p><h1 id="二、安装依赖"><a href="#二、安装依赖" class="headerlink" title="二、安装依赖"></a>二、安装依赖</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make</span><br></pre></td></tr></table></figure><p>如果有提示一路选择Y就可以</p><h1 id="三、下载python源码包"><a href="#三、下载python源码包" class="headerlink" title="三、下载python源码包"></a>三、下载python源码包</h1><p>python官网<a href="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a> 目前python最新版本是python3.10<br><img src="https://img-blog.csdnimg.cn/5967484e1d49472ab817580815275fef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="下载Python源码包"></p><p>下载稳定版本3.8版</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.8.12/Python-3.8.12.tgz</span><br></pre></td></tr></table></figure><h1 id="四、解压安装python源码包"><a href="#四、解压安装python源码包" class="headerlink" title="四、解压安装python源码包"></a>四、解压安装python源码包</h1><h2 id="1、解压"><a href="#1、解压" class="headerlink" title="1、解压"></a>1、解压</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Python-3.8.12.tgz</span><br></pre></td></tr></table></figure><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>进入解压后的目录进行编译和安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Python-3.8.12/</span><br><span class="line">[root@localhost Python-3.8.12]<span class="comment">#</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Python-3.8.12]<span class="comment"># ./configure</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Python-3.8.12]<span class="comment"># make&amp;&amp;make install</span></span><br></pre></td></tr></table></figure><p>执行完后显示安装成功<br><img src="https://img-blog.csdnimg.cn/9e8bcddbd7644d0b9bc702a13b3984e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="pyhont安装成功"></p><h2 id="3、建立命令软链接"><a href="#3、建立命令软链接" class="headerlink" title="3、建立命令软链接"></a>3、建立命令软链接</h2><p>虽然python3.8.12安装成功了，但默认输入python还是显示是2.7版本的。如果要用python3.8.12需要输入python3即可，有时候不太方便。可以通过修改软链接的方式将默认的python指向python3.8.12。<br>先看一下默认的python及新安装的python3都安装在哪里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Python-3.8.12]<span class="comment"># which python</span></span><br><span class="line">/usr/bin/python</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Python-3.8.12]<span class="comment"># which python3</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/python3</span><br></pre></td></tr></table></figure><p>可以看到默认的python路径为/usr/bin/python，python3的路径为/usr/local/bin/python3<br>将python3的软链接加到python上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Python-3.8.12]<span class="comment"># mv /usr/bin/python /usr/bin/python.bak</span></span><br><span class="line">[root@localhost Python-3.8.12]<span class="comment"># ln -s /usr/local/bin/python3 /usr/bin/python</span></span><br></pre></td></tr></table></figure><p>通过python -V命令查看python版号，这时python的版本已经是3.8.12了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Python-3.8.12]<span class="comment"># python -V</span></span><br><span class="line">Python 3.8.12</span><br></pre></td></tr></table></figure><p>pip命令也可以修改，python3.8.12默认的pip是pip3，CentOS7的python2.7默认没有安装pip.<br>输入pip命令的时候提示命令没有找到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Python-3.8.12]<span class="comment"># pip</span></span><br><span class="line">bash: pip: <span class="built_in">command</span> not found...</span><br></pre></td></tr></table></figure><p>这时也可以通过建立软链接的方式将pip命令链接到pip3上。首先看pip3命令在哪?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Python-3.8.12]<span class="comment"># which pip3</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/pip3</span><br></pre></td></tr></table></figure><p>然后建立pip到pip3的软链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Python-3.8.12]<span class="comment"># ln -s /usr/local/bin/pip3 /usr/bin/pip</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Python-3.8.12]<span class="comment"># pip -V</span></span><br><span class="line">pip 21.1.1 from /usr/<span class="built_in">local</span>/lib/python3.8/site-packages/pip (python 3.8)</span><br></pre></td></tr></table></figure><h1 id="五、配置yum"><a href="#五、配置yum" class="headerlink" title="五、配置yum"></a>五、配置yum</h1><p>安装python3改完软链接以后发现yum命令报错了，yum是依赖python2.7的，你把python改成了3.8了，所以报错了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Python-3.8.12]<span class="comment"># yum</span></span><br><span class="line">  File <span class="string">"/usr/bin/yum"</span>, line 30</span><br><span class="line">    except KeyboardInterrupt, e:</span><br><span class="line">                            ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>可以修改yum里对python2的依赖即可。虽然安装了python3但是系统里python2依旧还在系统里，可以通过python2来指定用python2.7的命令，首先来看下python2的命令在哪里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># which python2</span></span><br><span class="line">/usr/bin/python2</span><br></pre></td></tr></table></figure><p>可以cd到/usr/bin目录下 通过ls -alh|grep python查看python命令的详细情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]<span class="comment"># ls -alh|grep python</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/37df1186dcbf4820b7de6676120aa5ee.png#pic_center" alt="python命令软链接"><br>可以看到python软连接是执行的python3命令，python2是执行的python2.7的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/libexec/urlgrabber-ext-down</span><br></pre></td></tr></table></figure><p>修改对python的依赖，修改成python2或python2.7都可以。<br><img src="https://img-blog.csdnimg.cn/04054660445f497b886cb78119616722.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="修改依赖"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/bin/yum</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6777b0e3d68b4842a700a05af5eb6411.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="修改依赖"></p><p>修改完这两个文件后，再敲yum命令就不会报错了。</p><p><strong>至此CentOS7环境下python3.8.12已经成功安装！</strong></p><p>作者博客：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识SOAR-安全事件编排自动化响应</title>
      <link href="/posts/63a3c769/"/>
      <url>/posts/63a3c769/</url>
      
        <content type="html"><![CDATA[<p>SOAR是最近几年安全市场上最火热的词汇之一。SOAR究竟是什么，发展历程是什么，能够起什么作用，带着这些问题我们来认识一下SOAR。</p><h1 id="一、SOAR是什么"><a href="#一、SOAR是什么" class="headerlink" title="一、SOAR是什么"></a>一、SOAR是什么</h1><p>SOAR 一词来自分析机构 Gartner，SOAR-Security Orchestration, Automation and Response 安全编排和自动化响应。在Gartner的报告里，SOAR平台的核心组件为，编排与自动化、工作流引擎、案例与工单管理、威胁情报管理。而SOAR体系则是三个概念的交叉重叠：<strong>SOAR=SOA+SIRP+TIP</strong><br>1）精密编排的联动安全解决方案(SOA)；<br>2）事件应急响应平台(SIRP)；<br>3）威胁情报平台(TIP)。<br><img src="https://img-blog.csdnimg.cn/f1aefcc3e390408abb7effccbe41f083.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="SOAR"></p><h1 id="二、SOAR的发展历程"><a href="#二、SOAR的发展历程" class="headerlink" title="二、SOAR的发展历程"></a>二、SOAR的发展历程</h1><p>2015年，可以定义为SOAR的1.0时代。Gartner将SOAR(当时被认为是“安全运维分析和报告”)描述成为安全运维团队提供机器可读的安全数据报告和分析管理功能的产品。2017年，SOAR进入2.0时代。Gartner提出了“安全编排、自动化及响应”(SOAR)这个术语，用以描述脱胎于事件响应、安全自动化、场景管理和其他安全工具的一系列新兴平台。Gartner观察到三种以前截然不同的技术：安全编排和自动化(SOA)、安全事件响应平台(SIRPs)和威胁情报平台(TIPs)，正在逐步融合到一起。<br>根据Gartner2019年最新定义，SOAR是指能使企业组织从SIEM等监控系统中收集报警信息，或通过与其它技术的集成和自动化协调，提供包括安全事件响应和威胁情报等功能。SOAR技术市场最终目标是将安全编排和自动化(SOA)、安全事件响应(SIR)和威胁情报平台(TIP)功能融合到单个解决方案中。<br><img src="https://img-blog.csdnimg.cn/84eb9177ec554c0d8f5f74163cda15b2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="SOAR的演进"></p><p>根据Gartner预测，到2022年，有30%大型企业组织（安全团队超过5人）将在安全和运维的工作中使用SOAR，这一比例远超当下5%。当下SOAR技术的早期拥护者是那些已经拥有成熟安全运维中心，并且能够理解SOAR带来好处的那些成熟的安全组织。</p><h1 id="三、SOAR主要解决什么问题"><a href="#三、SOAR主要解决什么问题" class="headerlink" title="三、SOAR主要解决什么问题"></a>三、SOAR主要解决什么问题</h1><p>随着网络安全攻防对抗的日趋激烈，网络安全单纯指望防范和阻止的策略已经失效，必须更加注重检测与响应。企业和组织要在网络已经遭受攻击的假定前提下构建集阻止、检测、响应和预防于一体的全新安全防护体系。在国际上，检测和响应类产品受到了极大的关注。放眼国内，更多的注意力集中到了新型检测产品，尤其是未知威胁检测领域。借助这些产品和技术，用户获得了更低的 MTTD（平均检测时间），能够更快更准确地检测出攻击和入侵。但是，这些产品和技术大都没有帮助用户降低 MTTR（平均响应时间）。事实上，对于用户而言，更快地检测出问题仅仅是第一步，如何快速地对问题进行响应更加重要。而在提升安全响应效率的时候，不能仅仅从单点（譬如单纯从端点或者网络）去考虑，还需要从全网整体安全运维的角度去考虑，要将分散的检测与响应机制整合起来。而这，正是 SOAR 要解决的问题。<br>Gartner指出，SOAR可供公司企业收集不同来源的安全威胁数据和警报，运用人机结合的方法进行事件分析与分类，根据标准流程辅助定义、排序和驱动标准化事件响应行为。SOAR主要为安全团队提供定制化的流程和控制，弥合并加速有效网络威胁的调查与缓解。安全运营团队的大量日常事务性工作也可以借助SOAR加以自动化。而且，案例战术手册还可以帮助分析师在单一平台上响应和缓解威胁，节约事件响应的每一分每一秒宝贵时间。<br>Gartner 用 OODA 模型，来描绘一个典型的安全运营流程。OODA 即 Observe(观察)、Orient(定位)、Decide(决策)、Act(行动)。</p><ul><li>观察：观察事件并确定发生了什么，即通过各种检测、分析工具，比如 SIEM 类工具，找到威胁线索，如告警。</li><li>定位：确定观察的方向，并添加上下文来确定观察的含义，即对产生的告警的内容做调查、丰富化。比如查找外网域名的威胁情报，查找此 IP 的历史行为协助研判等等。</li><li>决策：根据业务的风险容忍度和能力决定适当的响应行动，即判定是否需要对此告警采取行动，比如是否需要封禁，是否影响业务，是否需要进一步观察。</li><li>行动：根据决定采取行动，并应用到观察过程中，然后重复，即执行确定的安全策略，并验证。每一步都对下一步提供了指导，周而复始，构成了一个良性促进的进化循环，不断优化企业的安全运营流程以应对不断变化的安全威胁。<br><img src="https://img-blog.csdnimg.cn/b37a4e16ee454bbe95aaf53e5235c9bd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="OODA 模型"></li></ul><p>OODA 环看起来逻辑清晰，易于操作。但事实上， OODA 环里的丰富化、调查取证、验证、执行安全策略变更等等，都是耗时耗力的工作。加上安全设备一直以来的误报问题产生的噪音，以及安全人员工作负荷重，资深从业人员短缺等原因，难以真正有效的推进 OODA 循环。更不用提在 HW 时段高强度的工作压力下，如何能够有条不紊的保持一贯的处置流程来处理每一个安全线索。SOAR 正是在这个背景下被提出，并被寄予厚望。SOAR 的核心，就是将安全流程或预案，即 OODA 循环的每一个实例，比如蠕虫爆发处理流程、挖矿病毒告警处理流程、疑似钓鱼邮件处理流程等等，数字化管理起来形成 Playbook。用自动化完成其中所有可能自动化的动作，无法自动的仍然交由人来处理，通过可视化编排工具将人、技术和流程有机的结合起来，形成标准统一的、可重复的、更高效的安全运营流程。</p><h1 id="四、SOAR的核心功能"><a href="#四、SOAR的核心功能" class="headerlink" title="四、SOAR的核心功能"></a>四、SOAR的核心功能</h1><p>从SOAR安全编排自动化响应的字面定义来看SOAR应该具备三大核心能力，编排、自动化、响应</p><h2 id="编排"><a href="#编排" class="headerlink" title="编排"></a>编排</h2><p>SOAR中的关键词是编排，这是在使用自动化和响应之前必须构建的关键组件。SOAR的编排体现的是一种协调和决策的能力，针对复杂性的安全事件，通过编排将分析过程中各种复杂性分析流程和处理平台进行组合。分析涉及多种数据或平台，如SIEM分析平台、漏洞管理平台、情报数据、资产数据等。处置响应的编排也涉及到很多平台或设备，如EDR管理平台、运维管理平台、工单管理平台、WAF设备、防火墙等。仅仅以技术为中心的安全保障已不再能满足现状，将人员和流程的编排才能保证安全流程真正高效的运行。SOAR的终极目标就是实现技术、流程、人员的无缝编排。</p><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>SOAR的自动化体现在三个方面，面对需要处理的安全事件能够根据策略自动选择编排的剧本、自动执行剧本的操作流程、根据决策结果自动联动设备进行防护阻断等行动策略。它允许剧本（常称为Playbooks）在安全流程的部分或全部内容上执行多个任务，将线性剧本串联起来。虽然线性剧本可能更容易创建，但只适用于处理决策需求较少的工作流。编排和自动化比线性剧本的最大优势就是其灵活性，为支持全自动化和半自动化的决策，需要更加灵活的工作流和执行剧本。SOAR能够识别这些决策模式，并基于以往事件中的执行操作，自动推荐新事件的剧本、执行剧本操作流程，自动化分析决策，根据决策结果自动下发防护阻断的行动策略。</p><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>安全事件响应包括告警管理、工单管理、案件管理等功能。告警管理的核心不仅是对告警安全事件的收集、展示和响应，更强调告警分诊和告警调查。只有通过告警分诊和告警调查才能提升告警的质量，减少告警的数量。工单管理适用于中大型的安全运维团队协同化、流程化地进行告警处置与响应，并且确保响应过程可记录、可度量、可考核。案件管理是现代安全事件响应管理的核心能力。案件管理帮助用户对一组相关的告警进行流程化、持续化的调查分析与响应处置，并不断积累该案件相关的痕迹物证 (IOC) 和攻击者的战技过程指标信息 (TTP)。多个案件并行执行，从而持续化地对一系列安全事件进行追踪处置。<br><img src="https://img-blog.csdnimg.cn/c305603e5c6f4bff9d10fa706c7a4e8c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="SOAR事件响应"></p><p>事件响应是SOC操作中非常复杂的部分，理想状态下，它将是一个有效的动态过程，涉及数十种相互关联的技术、IT、业务流程和整个组织的人员，将是持续性适应风险和信任评估（Continuous Adaptive Risk and Trust Assessment, CARTA）策略用于在持续监测和可视性方面时，SOC团队可使用SOAR技术执行连续活动，利用SOAR技术通过智能化编排与响应最大程度的将已有安全技术进行整合，提高整个安全事件的解决能力和效率。基于编排和自动化前期对事件的分析，SOAR所提供的响应技术是完善整个事件生命周期，提高解决安全威胁效率的关键一环。本质上，SOAR的最终目标是促进安全团队对事件有全面的、端到端的理解，完成更好、更明智响应。</p><h1 id="五、SOAR的价值"><a href="#五、SOAR的价值" class="headerlink" title="五、SOAR的价值"></a>五、SOAR的价值</h1><p><strong>1、缩短响应时间</strong><br>通过自动化技术，尽可能多的自动完成一个安全事件处置流程中相关步骤，从而缩短响应时间即 MTTR。<br><strong>2、释放人力</strong><br>让安全专家从繁重的重复劳动中释放出来，将时间放在更有价值的安全分析、威胁猎捕、流程建立等工作上。<br><strong>3、安全运营流程标准化</strong><br>将公司的安全运营流程数字化管理起来，每一次安全事件的对应处置过程都在统一标准，统一步骤下执行，有迹可循。避免人员能力的差距导致的处置实际效果不可控。<br><strong>4、避免能力断层</strong><br>将安全专家的经验固化成处置预案Playbook，让不同的人都可以遵循同样的方法来完成特定安全事件的处置流程，避免因为个人的离职导致某个领域的安全能力缺失。<br><strong>5、运营流程指标可度量</strong><br>因为运营流程都通过 Playbook 数字化管理且每一次的执行过程都记录在案，因此流程的 KPI 如 MTTD、MTTR、TTQ、TTI 等全部可评估、可度量、可追踪。<br><strong>6、安全运营决策支撑</strong><br>通过对公司的所有运营流程数字化管理、数字化执行、数字化KPI评估后，管理者可以有效的评估什么流程基本无用，什么流程执行效率不高，什么流程发挥了最大的作用，甚至什么安全设备在所有流程中被使用的价值最大。从而为以后的安全投资决策，安全团队建设决策提供有价值的数值化支撑。</p><h1 id="六、SOAR与其他安全产品的关系"><a href="#六、SOAR与其他安全产品的关系" class="headerlink" title="六、SOAR与其他安全产品的关系"></a>六、SOAR与其他安全产品的关系</h1><p><img src="https://img-blog.csdnimg.cn/bd575be2bac3412984d257a2470c4d40.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGllamF2YTEwMTg=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="SOAR与其他安全产品的关系"></p><p>SOAR定位于安全运营操作平台，它收集不同来源的安全威胁数据和警报，事件来源于其他的态势感知平台、SIEM、日志分析系统或安全人员人工录入需要处理的事件。通过调用安全设备的能力如：情报平台、资产管理平台、漏洞扫描平台、EDR管理平台、运维管理平台、工单管理平台、WAF设备、防火墙来实现对安全事件的分析、溯源、取证、处置、通知等。一端接安全事件源，一端对接安全设备能力。通过SOAR本身的编排能力将人员、设备、资源、流程协同起来。每个企业部署流程和技术并不相同，SOAR在实际落地应用过程中并不能“即插即用”，需要对接事件源、对接各类联动处置设备，根据企业具体的实际情况定制剧本流程。对接的实际安全设备能力数量以及剧本的积累，是SOAR平台能够很好的支持运营的关键。</p><p>作者博客：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大脑不是用来思考的，如何让孩子更好的学习？</title>
      <link href="/posts/8394d1a3/"/>
      <url>/posts/8394d1a3/</url>
      
        <content type="html"><![CDATA[<p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/2021/20210822/%E8%AF%BB%E4%B9%A6.png" alt="读书"></p><p>在这个知识爆炸、学习竞争压力巨大的时代，让父母最焦虑的事情之一，莫过于家里有个厌学的孩子了。为了让孩子好好学习，家长们操碎了心。为了孩子报各种培训辅导班、自己亲自上阵陪同辅导、高价请一对一的家教辅导，就差自己代替孩子去学习了。而孩子依旧是，一写作业就磨蹭、一考试就不会、一上学就无精打彩，一放学就满血复活。为什么学生不喜欢上学？如何让孩子喜欢并更好的学习呢？让我们跟着这本《为什么学生不喜欢上学?》一起来探索学习的秘密。<br><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/2021/20210822/%E6%88%91%E7%9A%84%E5%BF%83%E9%87%8C%E5%8F%AA%E6%9C%89%E5%AD%A6%E4%B9%A0.jpg" alt="我的心里只有学习"><br>《为什么学生不喜欢上学?》是一本关于认知心理学的普及读物，也是一本教育心理学的入门书籍。作为美国弗吉尼亚大学心理学教授威林厄姆的重要著作，是一本深受学生和教师欢迎的教育心理学著作。他用认知心理学的原理，详细分析了学生学习的过程和教师在课堂教学中必须注意的一些问题。</p><p>作者丹尼尔·T·威林厄姆，哈佛大学心理学博士，美国弗吉尼亚大学心理学教授。主要研究以大脑为基础的学习和记忆及认知心理学的基础教育应用。《美国教育家》杂志《向认知科学家提问》专栏作者。</p><p>这本书有着容易被人忽视和低估的名字，实际上它是一本认知心理学和教育心理学的科普著作，长期在美国亚马逊图书榜畅销不衰。在豆瓣评分高达9.3分！</p><p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/2021/20210822/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6.png" alt="为什么学生不喜欢上学"><br>书中主要提出并回答了这些问题：</p><ul><li>为什么学生不喜欢上学？</li><li>为什么学生能记住电视里的所有细节，却记不住我们教他的知识？</li><li>为什么让学生理解抽象概念这么难？</li><li>题海战术有用吗？</li><li>科学家是怎样思考的？如何让学生像专家一样思考？</li><li>如何因材施教？</li></ul><p>这本书刷新了很多人对学习的认知，不仅仅适合学生，同样适合处于终生学习时代的你和我。如果你的小学老师能早一点看到，你也就不会讨厌学习了。当然，现在的你看了也同样不晚。不论是教育孩子还是自己，了解了认知学的原理，按照符合科学原理的方法去做，都会让大家的学习更有效率。特别是，本书有许多震撼人心、不符合我们直觉的认知让我们重新去思考如何去更好的学习。</p><h3 id="学生为什么不爱学习？"><a href="#学生为什么不爱学习？" class="headerlink" title="学生为什么不爱学习？"></a><strong>学生为什么不爱学习？</strong></h3><p>从认知心理学的角度来看，人是充满好奇心的，愿意探索了解一切；也喜欢思考，因为思考就是解决问题，而解决问题能带来愉悦感。比如当你苦苦思索，终于解出了一道难题或者想通了一件事情，你的大脑可能奖励它自己少量的多巴胺，让你恨不得手舞足蹈，瞬间自信心爆棚，觉得自己是世界上最棒的人。这种快乐，跟吃个甜点是完全不一样。学习应该是件很快乐的事情。</p><p>既然解决问题也能带来快乐，那为什么还有这么多人不愿意思考，不愿意学习呢？</p><p><strong>因为：大脑不是用来思考的！！！</strong></p><p>看到这里估计大家会一脸闷逼，大脑不是用来思考的，哪是用来干啥的呢？是的，大脑能做很多事情，但思考并不是它最拿手的，人类不常思考是因为我们的大脑<strong>不是用来思考，而是用来避免思考的</strong>。思考很费力，而且它还是缓慢、靠不住的。幸运的是尽管我们并不擅长思考，但我们其实喜欢思考，我们生来就有着好奇心，也寻找可以进行思考的机会。但正是因为思考很难，需要条件合适，这份好奇心才能存活，否则我们很快就会放弃思考的念头。<strong>好奇心是与生俱来的，但它很脆弱</strong>。思考的愉悦感来自解决问题的过程，在一个要解决的问题上毫无进展是不会有愉悦感的，实际上，还会让你沮丧。同样只是知道问题的答案也不会有多大的愉悦感。如何保持好奇心，激发思考的兴趣呢？答案是思考问题的难易程度。太容易的问题不会带来愉悦感，同样太难的问题不但不会带来愉悦感还会带来挫折感让人渐渐的避免思考。</p><p><strong>所以：要确保提供给学生的问题是可以解决的。尊重学生的认知局限和个体间的认知差异，难易适中。</strong></p><p>根据资料，认知心理学把人类对于外部世界的认识分成了三个区域：舒适区、学习区、恐慌区。其中，“舒适区”是对自己来说没有学习难度的知识，接触这类知识感觉很舒适，但可学到的东西很少，进展缓慢；“学习区”有一定挑战，接触时会感到不适，但又不至于太难受，保持在这个区间学习，可以得到快速成长；“恐慌区”是超出自己能力范围太多的知识，接触会感到忧虑、恐惧，不堪负重以至放弃学习。学习具有适当挑战的东西，一段时间后，“学习区”会慢慢变为“舒适区”， 而一部分的“恐慌区” 又会变成“学习区”。<br><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/2021/20210822/%E8%88%92%E9%80%82%E5%8C%BA.jpg" alt="舒适区、学习区、恐慌区"></p><p>在舒适区学习，会因为太容易而觉得枯燥，无法坚持；在恐慌区学习，会因为太难好奇心受挫，很快就放弃。所以学习任务要难易适中。要确保在学习过程中碰到的问题可以被解决。</p><h3 id="在学习的过程中死记硬背是否合理？"><a href="#在学习的过程中死记硬背是否合理？" class="headerlink" title="在学习的过程中死记硬背是否合理？"></a><strong>在学习的过程中死记硬背是否合理？</strong></h3><p>一般大家都会死记硬背的学习方法嗤之以鼻，认为是读死书。然而你错了！有些东西该背的还得背，该记的还得记。事实性知识要先于技能，也就是说如9*9乘法表，元素周期表、历史年代表、一些常识等等，必须得用心记下，这些都是学习的基石。</p><p>毫无疑问，让学生记住枯燥的事实是完全不够的，需要进行关联和分析。但是同样，如果没有事实性知识想要凭空让学生拥有分析能力或者归纳能力是不可能的。</p><p><strong>因为：</strong><br><strong>第一，背景知识对阅读理解来说必不可少</strong>。它帮我们在单个的要点之间建立起联系。</p><p><strong>第二，背景知识对于我们的认知是必要的</strong>。一个人看起来在进行逻辑思考，但其实大部分是在进行记忆检索。它使我们能够将独立的元素合成一个单元，进而增加工作记忆的空间。</p><p><strong>第三，事实性知识可以增强记忆</strong>。如果你对一方面了解的越多，你就越能更好的理解这方面的新知识。</p><p>长期记忆中的事实性记忆使得获取更多的事实性知识更容易，它说明持有的信息量取决于已有的信息量。</p><p><strong>所以：</strong><br>我们必须让学生学习背景知识。学生必须学会反复出现的概念–统一所有学科的思想。</p><p><strong>知识体系在先，批判性思维在后</strong>。批判性思考并不能够脱离背景知识而单独实践以至完善的。<br>具有浅显知识都比没有知识强。了解的深固然好，但是我们不可能细致地了解每一件事情，泛泛的知识显然比不懂要强。</p><p><strong>加强阅读</strong>。大量的数据证实，读“闲书”的人一生都因此受益。</p><p><strong>偶然获得知识</strong>。学习事实性知识可以随时随地的学习如读闲书、翻杂志、看记录片、新闻或者和朋友聊天都可以获得相应的知识。</p><p><strong>尽早开始</strong>。家庭环境的培养，如父母使用的语言、书籍资源是否可得、家长是否平时看书。等等还有其他一些因素决定了孩子在上学前拥有的知识。</p><h3 id="题海战术到底有没有用？"><a href="#题海战术到底有没有用？" class="headerlink" title="题海战术到底有没有用？"></a><strong>题海战术到底有没有用？</strong></h3><p>题海战术也是比较有争议的学习方法，现在有一种观点认为，题海战术只对提高考试成绩有帮助，扼杀了学生内在的学习动力，是现行教育下的畸形产物，它带来的弊远大于利。但同时也有教育专家跳出来说，学生必须反复地练习才能学会知识和技能。两者孰是孰非？</p><p>在认知学看来，练习是最有效的窍门之一，它减少了大脑活动需要的空间。没有充分的练习，你不可能精通任何脑力活。</p><p>为什么要练习？因为通过练习能获得最基本的能力，以期精益求精。如果你作为足球运动员在带球的同时还要思考踢球的角度和速度，你不太可能成为一个优秀的足球运动员。你必须得日复一日的练习。像这样的低层次过程必须不假思索，才能给更高层次的过程，比如战术策略提供足够的空间。类似的，你如果不熟记数据要诀也学不好代数。练习的目的是获得能力和提高能力。</p><p><strong>因为：</strong></p><p><strong>练习是为了日后更好的学</strong>习。通过大量的练习会让一些步骤变得自动化，学习者才能将思考能力提高到下一个层次。让思考过程变得省力，这样才能学得更多。</p><p><strong>练习使记忆更长久</strong>。努力学习显然不能防止遗忘，但持续地练习可以防止遗忘。</p><p><strong>练习促进知识的迁移</strong>。重复做很多某一类型的题目使你更容易辨识一个新问题的内在结构，即使你以前没有见过这一题目。</p><p>但是，不是每件事情都需要无限度地练习的。</p><p><strong>所以：</strong></p><p>如果练习可以让思考过程变得省力，我们就要去识别哪些过程需要自动化，总的来说需要自动化的过程往往是自动化后效益能达到最大值的技能的基础。</p><p><strong>分散练习时间</strong>。没有必要把关于一个概念的所有练习集中在很短的一段时间里完成。分散练习后记忆会更持久。持续不断地练习同一项技能是很无聊的事，最好能有点变化。分散练习的另一个好处是学习者有更多的时间思考如何将学到的东西加以应用。</p><p><strong>在进阶环境中练习</strong>。自动化需要很多练习，聪明的办法是既分散练习的时间，又分散练习的环境。尽量多的设计有创意的方法来练习最关键的技巧，同时让学习者在更高阶的环境中学到基本技能。</p><h3 id="有些孩子天生就不是学习的料？"><a href="#有些孩子天生就不是学习的料？" class="headerlink" title="有些孩子天生就不是学习的料？"></a><strong>有些孩子天生就不是学习的料？</strong></h3><p>有些人认为，学习能力是受基因影响，如果你的基因优秀，你就聪明；基因不好，就不聪明。你聪明就可以学得很好。另外一种看法就是认为智能是可以塑造的。如果考试考砸了或不理解某个知识点，不是因为笨，而是因为他们还不够努力。哪一种看法是正确的呢？</p><p>答案是：两者都有正确的部分。我们的基因遗传确实对智能有影响，但是通常是通过环境影响的。毫无疑问智能是可以改变的！</p><p>孩子智能上的差异可以通过持久的努力来改变。</p><p><strong>因为：</strong></p><p><strong>对于智能，态度很重要</strong><br>有充分证据证明，相信智能可以通过努力提高的学生比相信智能是改变不了得事情的学生学得更好，得到的分数更高。<br>孩子必须知道他的能力决定他所作事情时的成功率，他需要发展对于自己能力的自信，而且还要理解，对于不同类型的任务他拥有不同级别的能力。</p><p><strong>所以：</strong></p><p>要确保孩子相信自己能够进步，要让他们相信为此所作的努力是值得的。</p><p><strong>赞扬努力，而非能力</strong>。赞扬过程而不是能力，赞扬孩子面对困难时坚持不懈的精神或对作业负责的态度。</p><p>告诉他们<strong>一份耕耘一份收获</strong>。所有的所谓“天才”都是持续努力的结果。</p><p><strong>坦然的接受失败</strong>。如果你想提高智能，你需要挑战自己，这表示接受了略高过自己能力的任务，你很有可能第一次就会失败，但失败没有什么大不了的。人生中的一次又一次的失败是成功的原因。<br>学习技能不是天生的。所有的学习者都要学会自觉、时间分配、足智多谋（如遇到难题时该如何做）。</p><p>终身学习，做保持好奇心和探索欲的父母和老师，我们需要更多的智慧。而教育就是将智慧薪火相传的过程，尊重孩子的认知规律，谨慎积极的保持努力和践行。教育使人更聪明，聪明的人可以使教育更美好。</p><hr><center>关注：“爱分享读书”微信公众号 <p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/%E7%88%B1%E5%88%86%E4%BA%AB%E8%AF%BB%E4%B9%A6%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><p>读书我们是认真的</p></center>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
            <tag> 学习考试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>都2021了，我为什么还在用博客这种古老的方式在记录</title>
      <link href="/posts/7626e526/"/>
      <url>/posts/7626e526/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/81616d1642d7445796c58b74e0b30bf9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70#pic_center" alt="BLOG"></p><p>都2021了，在这个移动互联网异常发达，自媒体泛滥的时代，博客这个古老的在互联网时代记录自己的工具似乎是不合时宜要被大众所遗忘被历史所淘汰。而我却还在用博客这种古老的方式生活在移动互联网时代记录工作，学习，生活。</p><p><strong>一、为什么要记录</strong><br>正如我的博客标题，记录最好的自己。最朴实的想法就是想记录自己的所学、所见、所闻、所思、所想。记录使人进步。吴军老师的《全球科技通史》中提到，促进人类文明发展的是两条主线，一条是能源，一条是信息。文字的发明，信息的记录，让人类的文明得以延续和发展。是一代一代人通过信息的记载和积累促进科技的发展，让信息不管是从记录方式还是传播速度都得到了跨越式的发展，进入到了现在信息爆炸的时代。书中提到，为什么在近代早期西方的科学技术进步的速度要明显的快于中国，一个重要的原因就西方对于科学技术的研究及传播方式。西方的研究方式是通过不断的实验大量的记录进行定量研究，后人可以基于前人记录的信息研究成果进行研究和传播，大大加快的科学技术的进步。而那时候中国可能还是定性方式的研究，口口相传的传播方式，导致原来很多技术到现在都失传了。</p><p>对于个人来说，我想应该也是一样的，要想更快进步和发展，将自己生活、学习、工作过程中的所学、所见、所闻、所思、所想记录下来定期的回顾和思考应该会有所促进吧。而且随着时间的推移回头看看自己以前记录的东西应该也是一种乐趣。或许，有人看到我所记录的东西以此为鉴少走一点弯路。</p><p>不在乎文笔，不限于内容，仅仅只是记录，希望记录能够成就最好的自己。</p><p><strong>二、为什么是博客这种方式</strong><br>记录信息的手段很多，尤其是自媒体时代，微博、微信、头条、抖音、小红书啥的，平台很多。为什么还要用博客这种古老的方式呢？如果自是记录给自己看映象笔记、网易云笔记都是很好的，私密性太强，不够开放。微博、微信社交属性太强关注的都是些熟人。头条、抖音、小红书，功利性太强，为了收益去强迫自己去写也不是自己的初衷。想来想去还只有博客这种古老的方式比较合适，安安静静的自己想记录什么就记录什么。也不用去担心什么流量，不用去关注什么人关注了你。以前几个大的通用的博客平台都不提供服务了如新浪博客、网易博客等，而CSDN、cnblog主要是技术类的博客，想记录点乱七八糟的事情似乎也不太适合。所以只好自己来搭建博客咯。</p><p>自己搭建的博客<a href="http://xiejava.ishareread.com" target="_blank" rel="noopener">http://xiejava.ishareread.com</a> 已经快两年了。记录的东西不是太多，说明见识不多，思考太少。</p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自我管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全运维与安全运营</title>
      <link href="/posts/76373188/"/>
      <url>/posts/76373188/</url>
      
        <content type="html"><![CDATA[<p>安全运维与安全运营是安全人员经常听到的两个名词。到底什么是安全运维，什么是安全运营，两者之间有什么区别和联系呢？</p><p>我们先来看一下运维与运营的概念区别。<br><strong>运维</strong>一般来说指的是运行维护，通过一定的技术和管理手段保障平台或系统的正常运行。本质上是对平台、系统或产品所涉及的网络、服务器、服务的生命周期各个阶段的运营与维护，在成本、稳定性、效率上达成一致可接受的状态。</p><p><strong>运营</strong>从字面上理解更多的是指经营。通过对平台、系统或产品的经营达到预期的业务目标。对运营过程的计划、组织、实施和控制，是与产品生产和服务创造密切相关的各项管理工作的总称。从另一个角度来讲，运营管理也可以指为对生产和提供公司主要的产品和服务的系统进行设计、运行、评价和改进的管理工作。</p><p>总体来说<strong>运营应该是覆盖运维的，运维是支持运营的</strong>。那么安全运维和安全运营，应该也是同样的道理。</p><p>网上有人进行了概括：</p><p><strong>安全运维</strong>简单来说，就是从安全的角度对日常IT信息系统进行运行维护，传统运维工作主要是为了保障信息系统的正常运行，安全运维则是通过安全分析，检测和解决已经产生和即将产生的安全问题，从而建立从防护到监测到解决的闭环安全机制管理系统，实现运维的目的——保障企业整体IT系统运行正常。</p><p><strong>安全运营</strong>应该来说概念更广，狭义的安全运营是为以资产为核心，以安全事件管理为关键流程，依托于安全运营平台（SOC），建立一套实时的资产风险模型，进行事件分析、风险分析、预警管理和应急响应处理的集中安全管理体系。广义安全运营是一个技术、流程和人有机结合的复杂的系统工程，通过对已有的安全产品、工具、服务产出的数据进行有效的分析，持续输出价值，解决安全风险，从而实现安全的最终目标。</p><p>个人认为<strong>运维更多的强调流程，运营更多的强调体系。</strong></p><p>作者博客：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络信息安全管理之资产、脆弱性、威胁、风险</title>
      <link href="/posts/57a81e07/"/>
      <url>/posts/57a81e07/</url>
      
        <content type="html"><![CDATA[<p>​<br><strong>网络信息安全管理</strong>是指对网络资产采取合适的安全措施，以确保网络资产的可用性、完整性、可控制性和抗抵赖性，不致因网络设备、网络通信协议、网络服务、网络管理受到人为和自然因素的危害，而导致网络中断、信息泄露或破坏。网络信息管理对象主要包括网络设备、网络通信协议、网络操作系统、网络服务、安全网络管理等在内的所有支持网络系统运行的软、硬件总和。网络信息安全管理的目标就是通过适当的安全防范措施，保障网络的运行安全和信息安全，满足网上业务开展的安全要求。</p><p><strong>网络信息安全管理要素</strong>由网络管理对象、网络威胁、网络脆弱性、网络风险、网络保护措施组成。由于网络管理对象自身的脆弱性，使得威胁的发生成为可能，从而造成了不同的影响，形成了风险。网络安全管理实际上就是风险控制，其基本过程是通过网络管理对象的威胁和脆弱性进行分析，确定网络管理对象的价值、网络管理对象威胁发生的可能性、网络管理对象的脆弱程度，从而确定网络管理对象的风险等级，然后据此选取合适的安全保护措施，降低网络管理对象的风险。</p><p><strong>安全风险管理的三要素</strong>分别是<strong>资产</strong>、<strong>威胁</strong>和<strong>脆弱性</strong>，脆弱性的存在将会导致风险，而威胁主体利用脆弱性产生风险。网络攻击主要利用了系统的脆弱性。由于网络管理对象自身的脆弱性，使得威胁的发生成为可能，从而造成了不同的影响，形成了风险。</p><p><img src="https://img-blog.csdnimg.cn/20201204163036136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="网络信息安全管理要素"></p><p>网络信息安全管理对象是企业、机构直接赋予了价值而需要保护的资产。它的存在形式包括有形的和无形的，如网络设备硬件、软件文档是有形的，而服务质量、网络带宽是无形的。</p><p>常见的网络信息安全管理对象信息安全资产分类如下：</p><table><thead><tr><th>分类</th><th>示例</th></tr></thead><tbody><tr><td>数据</td><td>保存在信息媒介上的各种数据资料，包括源代码、数据库数据、系统文档、运行管理规程、计划报告、用户手册、各类纸质的文档等</td></tr><tr><td>软件</td><td>系统软件：操作系统、数据库管理系统、语句包、开发系统<br>应用软件：办公软件、数据库软件、各类工具软件等<br>源程序：各种共享源代码、自行或合作开发的各种代码等</td></tr><tr><td>硬件</td><td>网络设备：路由器、网关、交换机等<br>计算机设备：大型机、小型机、服务器、工作站、台式计算机、便携计算机等<br>存储设备：磁带机、磁盘阵列、磁带、光盘、软盘、移动硬盘等<br>传输线路：光纤、双绞线等<br>保障设备：UPS、变电设备、空调、保险柜、文件柜、门禁、消防设施等<br>安全设备：防火墙、入侵检测系统、身份鉴别等<br>其他：打印机、复印机、扫描仪、传真机等</td></tr><tr><td>服务</td><td>信息服务：对外依赖该系统开展的各类服务<br>网络服务：各种网络设备、设施提供的网络连接服务<br>办公服务：为提高效率而开发的管理信息系统，包括各种内部配置管理、文件流转管理等服务</td></tr><tr><td>人员</td><td>掌握重要信息和核心业务的人员，如主机维护主管、网络维护主管及应用项目经理等</td></tr><tr><td>其他</td><td>企业形象、客户关系等</td></tr></tbody></table><p><strong>脆弱性</strong>：脆弱性也可称为弱点或漏洞，是资产或资产组中存在的可能被威胁利用造成损害的薄弱环节。脆弱性一旦被威胁成功利用就可能对资产造成损害。脆弱性可能存在于物理环境、组织、过程、人员、管理、配置、硬件、软件和信息等各个方面。</p><p>脆弱性是与资产紧密相连的，是其固有的属性，客观存在是绝对的，但存在脆弱性不一定就绝对造成安全事件。如果没有被相应的威胁利用，单纯的脆弱性本身不会对资产造成伤害。</p><table><tr><th>类型</th><th>识别对象</th><th>脆弱性子类</th></tr><tr ><td rowspan=6>技术脆弱性</td><td>物理环境</td><td>机房场地、机房防火、机房供配电、机房防静电、机房接地与防雷、电磁防护、通讯线路的保护、机房区域防护、机房设备管理等</td><tr><td>网络结构</td><td>网络结构设计、网络传输加密、网络设备安全漏洞、边界保护、外部访问控制策略、内部访问控制策略、网络设备安全配置等</td></tr><tr><td>服务器/系统软件</td><td>补丁安装、物理保护、用户帐号、口令策略、资源共享、事件审计、访问控制、新系统配置（初始化）、注册表加固、网络安全、系统软件安全漏洞、软件安全功能管理等</td></tr><tr><td>数据库</td><td>补丁安装、鉴别机制、口令机制、访问控制、网络和服务设置、备份恢复机制、审计机制等</td></tr><tr><td>应用系统</td><td>审计机制、审计存储、访问控制策略、数据完整性、通讯、鉴别机制、密码保护等</td></tr><tr><td>应用中间件</td><td>协议安全、交易完整性、数据完整性等</td></tr><tr><td rowspan=2>管理脆弱性</td><td>技术管理</td><td>物理和环境安全、通讯和操作管理、访问控制、系统开发与维护、业务连续性等</td></tr><tr><td>组织管理</td><td>安全策略、组织安全、信息资产分类与控制、人员安全、符合性等</td></tr></table>威胁：对资产或组织可能导致负面结果的一个事件的潜在源。威胁利用管理对象自身的脆弱性，采用一定的途径和方式，对评估对象造成损害或损失，从而形成风险。<p>威胁源分三类：自然威胁、人为威胁和环境威胁。</p><table><thead><tr><th>种类</th><th>描述</th><th>威胁子类</th></tr></thead><tbody><tr><td>软硬件故障</td><td>对业务实施或系统运行产生影响的设备硬件故障、通讯链路中断、系统本身或软件缺陷等问题</td><td>设备硬件故障、传输设备故障、存储媒体故障、 系统软件故障、应用软件故障、数据库软件故障、开发环境故障等</td></tr><tr><td>物理环境影响</td><td>对信息系统正常运行造成影响的物理环境问题和自然灾害</td><td>断电、静电、灰尘、潮湿、温度、洪灾、火灾、地震、暴风雨、潮汐、污染、空调设备故障、鼠蚁虫害、电磁干扰等</td></tr><tr><td>操作失误</td><td>应该执行而没有执行相应的操作，或无意执行了错误的操作</td><td>维护错误、操作失误、提供错误的指南或操作信息等</td></tr><tr><td>管理不到位</td><td>安全管理无法落实或不到位，从而破坏信息系统正常有序运行</td><td>管理制度和策略不完善、管理规程缺失、职责不明确、监督控管机制不健全等</td></tr><tr><td>恶意代码</td><td>故意在计算机系统上执行恶意任务的程序代码</td><td>病毒、特洛伊木马、蠕虫、陷门、间谍软件、窃听软件、携带恶意软件的垃圾邮件、流氓安全软件、即时消息垃圾邮件等</td></tr><tr><td>越权或滥用</td><td>通过采用一些措施，超越自己的权限访问了本来无权访问的资源，或者滥用自己的权限，做出破坏信息系统的行为</td><td>非授权访问网络资源、非授权访问系统资源、滥用权限非正常修改系统配置或数据、滥用权限泄露秘密信息、非授权使用存储介质等</td></tr><tr><td>网络攻击</td><td>利用工具和技术通过网络对信息系统进行攻击和入侵</td><td>网络探测和信息采集、漏洞探测、嗅探（账号、口令、权限等）、用户身份伪造和欺骗、用户或业务数据的窃取和破坏、系统运行的控制和破坏、拒绝服务攻击、僵尸网络、隐蔽式下载、名誉劫持、网络黑客的入侵等</td></tr><tr><td>物理攻击</td><td>通过物理的接触造成对软件、硬件、数据的破坏</td><td>物理接触、物理破坏、盗窃、勒索、罢工、内部员工蓄意破坏等</td></tr><tr><td>泄密</td><td>信息泄露给不应了解的他人</td><td>内部信息泄露、外部信息泄露等</td></tr><tr><td>篡改</td><td>非法修改信息，破坏信息的完整性使系统的安全性降低或信息不可用</td><td>篡改网络配置信息、篡改系统配置信息、篡改安全配置信息、篡改用户身份信息或业务数据信息等</td></tr><tr><td>抵赖</td><td>不承认收到的信息和所作的操作和交易</td><td>原发抵赖、接受抵赖、第三方抵赖等</td></tr></tbody></table><p>在这里可以看出威胁与攻击的区别和关系。攻击是威胁的一种类型，攻击是人为的蓄意的有计划采取的恶意破坏的行动。一般来说攻击比较容易检测到。</p><p><strong>网络信息安全风险</strong>是指特定的威胁利用网络管理对象所存在的脆弱性，导致网络管理对象的价值受到损害或丢失的可能性。简单的说，网络安全风险就是网络威胁发生的概率和所造成影响的乘积。</p><p><img src="https://img-blog.csdnimg.cn/20201204163838552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="网络安全风险分析"></p><p>本文整理自《信息安全工程师教程第2版》</p><p>作者博客：<a href="http://xiejava.ishareread.com/" target="_blank" rel="noopener">http://xiejava.ishareread.com/</a></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识威胁情报</title>
      <link href="/posts/3866c7c1/"/>
      <url>/posts/3866c7c1/</url>
      
        <content type="html"><![CDATA[<h1 id="初识威胁情报"><a href="#初识威胁情报" class="headerlink" title="初识威胁情报"></a>初识威胁情报</h1><p>随着网络空间的广度和深度不断拓展，当今网络攻击的多样化、复杂化、专业化，安全对抗日趋激烈，传统的安全思维模式和安全技术已经无法有效满足政企客户安全防护的需要，新的安全理念、新的安全技术不断涌现。业界普遍认同：仅仅防御是不够的，更加需要持续地检测与响应。而要做到更有效的检测与更快速的响应，安全情报必不可少。有效的威胁情报可以提高安全产品的对恶意攻击识别能力，提高溯源效率，并及时采取应对措施，减少甚至消除攻击的危害。</p><p>本文收集了互联网上的威胁情报的相关知识信息，试图从威胁情报的定义、分类、应用三个方面对威胁情报进行初步的认识。</p><h2 id="一、什么是威胁情报"><a href="#一、什么是威胁情报" class="headerlink" title="一、什么是威胁情报"></a>一、什么是威胁情报</h2><p>安全情报包含漏洞、资产、威胁、风险、运行和事件等多维度安全知识在内的知识集合。<strong>安全情报</strong>是一个宽泛的概念，主要包括了<strong>威胁情报</strong>、<strong>漏洞情报</strong>、<strong>事件情报</strong>以及<strong>基础数据情报</strong>。</p><p>根据Gartner对威胁情报的定义，<strong>威胁情报</strong>是一种基于证据的知识，包括了情境、机制、指标、影响和操作建议。威胁情报描述了现存的、或者是即将出现针对资产的威胁或危险，并可以用于通知主体针对相关威胁或危险采取某种响应。简单来说威胁情报是可以针对相关威胁采取行动的知识，可以帮助企业和组织快速了解到敌对方对自己的威胁信息，从而帮助他们提前做好威胁防范、更快速地进行攻击检测与响应、更高效地进行事后攻击溯源。</p><p>从严格意义上来讲，威胁情报和漏洞情报是不同的两种安全情报，不应该将它们混淆。从防御者的角度来看，获取<strong>漏洞情报是为了知己</strong>，而获取<strong>威胁情报是为了知彼</strong>。</p><h2 id="二、威胁情报分类"><a href="#二、威胁情报分类" class="headerlink" title="二、威胁情报分类"></a>二、威胁情报分类</h2><p>根据使用方法不同，威胁情报可分为三类</p><p><strong>战略情报</strong><br>包括安全调查报告、趋势分析、行业状况等战略层面的情报，可供企业CISO或安全负责人制定安全规划和投资策略，将有限的资源投入到最需要的地方。</p><p><strong>技术情报</strong><br>包括各种威胁的丰富化情报，以及相关信息。通过攻击事件相关的IP和域名的详细信息，以及攻击者相关的攻击事件及样本，安全分析师可以对重要安全事件做准确的分析，包括报警确认、攻击影响范围、攻击链以及攻击目的、技战方法等，并进行相应的安全预测和防范。</p><p><strong>战术情报</strong><br>包括各种面向安全设备或系统的，易于执行的高可信度威胁IOC (Indicator of Compromise)。安全运营团队利用高质量的威胁IOC可帮忙安全系统自动检测未知威胁，及早产生预警和通知，快速响应恶意攻击，提高企业安全防护能力。</p><p>根据数据本身威胁情报可以分为<strong>HASH值</strong>、<strong>IP地址</strong>、<strong>域名</strong>、<strong>网络或主机特征</strong>、<strong>TTPs</strong>（Tactics、Techniques &amp; Procedures，工具、技术、过程）等<br><img src="https://img-blog.csdnimg.cn/20210625092504657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_2,color_FFFFFF,t_70#pic_center" alt="威胁情报"></p><p><strong>HASH值</strong>：一般指样本、文件的HASH值，比如MD5和SHA系列。由于HASH函数的雪崩效应，文件任何微弱地改变，都会导致产生一个完全不同也不相关的哈希值。这使得在很多情况下，它变得不值得跟踪，所以它带来的防御效果也是最低的。</p><p><strong>​​IP地址</strong>：常见的指标之一，通过IP的访问控制可以抵御很多常见的攻击，但是又因为IP数量太大，任何攻击者均可以尝试更改IP地址，以绕过访问控制。</p><p><strong>​​域名</strong>：有些攻击类型或攻击手法也或者出于隐藏的目的，攻击者会通过域名连接外部服务器进行间接通信，由于域名需要购买、注册、与服务器绑定等操作使得它的成本相对IP是比较高的，对域名的把控产生的防御效果也是较好的。但是对于高级APT攻击或大规模的团伙攻击，往往会准备大量备用域名，所以它的限制作用也是有限。</p><p>​​<strong>网络或主机特征</strong>：这里指的特征可以是很多方面，比如攻击者浏览器的User-Agent、登录的用户名、访问的频率等，这些特征就是一种对攻击者的描述，这些情报数据可以很好的将攻击流量从其他的流量中提取出来，就会产生一种较好的防御效果。</p><p><strong>​​攻击工具</strong>：这里是指获取或检测到了攻击者使用的工具，这种基于工具的情报数据能够使得一批攻击失效，攻击者不得不进行免杀或重写工具，这就达到了增加攻击成本的目的。</p><p><strong>​​TTPs</strong>：Tactics、Techniques &amp; Procedures的缩写，指攻击者所使用的攻击策略、手法等，掌握了些信息就能明白攻击者所利用的具体漏洞，就能够针对性的布防，使得攻击者不得不寻找新的漏洞，所以这也是价值最高的情报数据。</p><p>从应用领域分类可以分为，<strong>机读情报（MRTI）</strong>、<strong>人读情报（PRTI）</strong>、<strong>画像情报</strong>和<strong>知识情报</strong>四类</p><p><strong>机读情报</strong>：可供机器理解和使用的情报，侧重于高频次、高准确性、强实效的应用场景。<br><strong>人读情报</strong>：信息量更大，需要更多的上下文、背景信息支持人工分析研判和应急响应。<br><strong>画像情报</strong>：针对单一的威胁、资产、漏洞、事件进行分析，形成相应的知识集，概念上类似于用户画像。<br><strong>知识情报</strong>：基于先验知识的规则模型和算法。这些模型和算法与平台之间高度匹配，可以快速导入平台，结合平台获得的各类数据、信息和情报，实现对某类特定类别的威胁、风险或特定事件的感知、分析、决策和处置。消费对象和应用场景集中于态势感知、SOC/SIEM类分析平台。</p><p>其中机读情报应用最广，基本已经被各大安全厂商在设备中集成，多以IoC或者Yara的形式存储。人读情报的格式比较宽泛，包括安全公告、漏洞预警、病毒/APT分析文章都属于这个类别。画像情报则是介于机读和人读情报中的一种，通常用结构化的标签和非结构化的备注来描述，针对单一的威胁、资产、漏洞、事件进行分析形成的知识集，也可以加入场景标注。而知识情报的提法主要是针对态势感知、SOC、SIEM类平台产品的，平台内置的先验规则如关联规则和知识图谱都属于这一类。</p><p>从情报市场来源来分可分为<strong>开源情报（OSINT）</strong>、<strong>商用情报</strong></p><p><strong>开源情报</strong>：Open Source Threat Intelligence 开源情报，免费从公开信息来源进行数据采集和分析后形成的情报。<br><strong>商用情报</strong>：Commercial Threat Intelligence 商业情报，在威胁情报领域，根据用户需求提供的付费情报。一般来说付费的准确度要稍高。</p><h2 id="三、威胁情报有什么用"><a href="#三、威胁情报有什么用" class="headerlink" title="三、威胁情报有什么用"></a>三、威胁情报有什么用</h2><p><strong>溯源分析</strong><br>威胁情报记录了外部攻击的大量信息，可以让安全分析师了解攻击方的情报，解决攻防战中信息不对称的困境。特别是在分析告警、进行溯源分析时，往往会在威胁情报系统中查询相关攻击 IP、Domain 等的具体信息，看看有没有攻击线索和方式，可以用作告警确认和进一步处理的依据。</p><p><strong>检测告警</strong><br>数字化时代的黑客的攻击也逐渐自动化、智能化，每天企业都会受到大量的外部攻击，依靠人去一个个分辨是不现实的，企业往往部署了可以对外部流量或外部日志进行自动化分辨的安全设备和系统，比如 FW 、 IDPS 、 SIEM 或大数据安全分析平台。如果将最新的威胁情报传输到这些 安全设备和系统中，就可以极大的提高这些设备系统对新型攻击的检测能力。<br>情报厂商往往将这些有价值的情报以IOC 的形式发布出来，用户可以将这些 IOC 导入到部署的安全设备系统中，从而可以快速实现对新型威胁攻击的识别、告警和处理。</p><p><strong>安全预防</strong><br>防守不是最好的策略，在如今企业每日都面对各式各样的网络攻击，单纯的被动防守已经无法阻挡黑客的攻击。如果能预知攻击并提前预防就可以减小不少攻击的损失。<br>通过漏洞情报可以在攻击到来之前获悉攻击的信息，事先做好准备，修复相关漏洞，加强安全防护，避免威胁攻击带来的危害。</p><p><strong>安全规划</strong><br>安全工作是一个系统性的工程，需要方方面面的知识和信息。为了做好安全规则，需要了解威胁攻击的总体现状和未来发展趋势，同时还要提供相关信息用以说明管理层提供相关投资。高级威胁情报信息可以帮助安全团队领导了解威胁攻击的状况以及预测，方便企业制定好相应安全规划和投资。</p><p><strong><em>实用的情报才是最好的情报</em></strong><br>情报的“ART”原则，符合“ART”原则的才是对企业有用的情报。<br><strong>Accuracy（准确性）</strong>：情报是否足够详细和可靠<br>威胁情报的作用是为安全团队提供相关信息并指导决策，如果情报不准确，不但没有产生价值，反而会对组织的安全决策会造成负面影响。<br><strong>Relevance（相关性）</strong>：情报是否可适用于你的业务或行业<br>不是所有的信息都是适用的，相关性较弱的情报会导致分析人员的繁重任务，并且会导致其他有效情报的时效性失效。<br><strong>Timeliness（时效性）</strong>：在你利用些情报前，情报是否已经失效<br>威胁情报是信息的集合，凡是信息，都具有时效性。往往情报的有效时间会很短，攻击者会为了隐藏自己的踪迹不断的更换一些特征信息，比如说IP地址、手法等等。</p><p>威胁情报要发挥价值，核心在于情报信息的共享。只有建立起一套威胁情报共享的机制，让有价值的威胁情报流动起来，才能真正加速安全防御的效率、效能，取得切实的防御效果。<br>威胁情报的生态系统包括两个方面：威胁情报的生产和威胁情报的消费。<br>威胁情报的生产就是通过对原始数据/样本的采集、交换、分析、追踪，产生和共享有价值的威胁情报信息的过程。<br>威胁情报的消费是指将企业和客户网络中的安全数据与威胁情报进行比对、验证，以及企业和客户方的安全分析师利用威胁情报进行分析的过程。<br>威胁情报的生产和消费构成了一个情报生态系统的闭环。只有生产没有消费，威胁情报的价值无法实现；而只有消费没有生产，威胁情报就成了无源之水。</p><p>对于政企客户而言，威胁情报的应用/消费是实现情报价值的关键。各类安全设备都应该能够消费威胁情报，但最关键的是安全管理平台/SOC对威胁情报的应用</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解企业安全能力框架(IPDRR)</title>
      <link href="/posts/6b94b28d/"/>
      <url>/posts/6b94b28d/</url>
      
        <content type="html"><![CDATA[<p>企业安全能力框架(IPDRR)是美国国家标准与技术研究所（National Institute of Standards and Technology）的网络安全框架（简称NISTCSF )。第一个版本于2014年发布，旨在为寻求加强网咯安全防御的组织提供指导。企业可以根据自身需求加强网络安全防御。<br><img src="https://img-blog.csdnimg.cn/20210617155234944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="企业网络安全系统框架"><br>企业网络安全系统框架（参考IPDRR）</p><p>随着社会数字化转型的深入，网络攻击事件日益增多、破坏力逐步增强。安全方法论也正逐步从”针对威胁的安全防御”向“面向业务的安全治理”（IPDRR）等演进。</p><p>IPDRR能力框架模型包括风险识别（Identify）、安全防御（Protect）、安全检测（Detect）、安全响应（Response）和安全恢复（Recovery）五大能力，从以防护为核心的模型，转向以检测和业务连续性管理的模型，变被动为主动，最终达成自适应的安全能力。</p><p>IPDRR模型体现了安全保障系统化的思想，管理与技术结合来有效保障系统核心业务的安全。通过持续的安全检测来实现IPDRR的闭环安全，为用户提供完善的安全能力框架和支撑体系。</p><p>具体来说IPDRR主要包含了五个部分：<br><strong>识别（Identify）</strong>：识别网络资产及风险，是指对系统、资产、数据和网络所面临的安全风险的认识及确认<br><strong>保护（Protect）</strong>：保护网络，是指制定和实施合适的安全措施，确保能够提供关键基础设施服务。<br><strong>检测（Detect）</strong>：发现攻击，在攻击产生时即时监测，同时监控业务和保护措施是否正常运行，制定和实施恰当的行动以发现网络安全事件<br><strong>响应（Respond）</strong>：响应和处理事件，指对已经发现的网络安全事件采取合适的行动。具体程序依据事件的影响程度来进行抉择，主要包括：事件调查、评估损害、收集证据、报告事件和恢复系统<br><strong>恢复（Recover）</strong>：恢复系统和修复漏洞，将系统恢复至正常状态，同时找到事件的根本原因，并进行预防和修复</p><p>可以参考大家对实体财物是怎么保护的就很容易理解了。举个例子，大家如何对自己的私有财产是怎么保护的呢？<br>第一步识别（Identify）肯定是识别出有哪些资产分别都有什么风险吧，比如家里的现金、金银珠宝、贵重电器、房产证、82年的拉菲、92年的茅台等等对于我们来说都是属于我们要保护的资产，这些都有被小偷偷走，被破坏等风险。所以我们需要采取一定的措施将这些资产给保护起来。<br>比如现金、金银珠宝、房产证等放在保险柜里，82年的拉菲、92年的茅台等搞个酒窖上好锁，家里的房子装好防护门、防盗窗等，这些就是第二步保护（Protect），对需要保护的资产做好基本的防护。做到了这些够不够呢？显然是不够的，这只是做好被动防御，我们还要做好主动防御，也就是第三步检测（Detect），这时候我们可以装一些监控设备摄像头、传感器等等，看时时刻刻监控我们所要保护的资产看有没有什么情况，还可以雇佣一批保安7*24小时巡逻实时监测。响应（Respond）也就是发现了什么风吹草动，就采取响应的措施，比如如果是有人破门而入就及时的告警，制止，报警。恢复（Recover）就是对易发生的损失进行恢复，如有人破门而入把门给搞坏了，就得把门重新修好或换一个新的级别更高更安全的门。</p><p>企业的网络安全也是一样的。首先要识别自己企业的网络安全资产如重要系统、服务器等都部署在哪里，有没有漏洞，基线配置有没有合规。然后需要做好基本的防护，比如在出入口部署防火墙、主机装EDR、Web服务器要在WAF的保护下、做好访问控制、部署IPS设备等等。有了基础的防护设备以后要做好检测响应比如部署NTA做好流量检测分析、部署SIEM或日志分析系统将这些基础防护设备的告警精心接入做好安全告警的检测分析。通过检测设备发现网络安全事件以后要采取响应的响应措施，比如发现漏洞要进行补洞加固等、发现攻击封堵IP等，可以通过SOAR安全编排与自动化响应平台对人、工具、流程进行协同提高对于安全事件的响应能力。最后是恢复，也就是对已经造成的破坏进行恢复至正常状态，对于失陷的主机进行离网、杀毒、重装、恢复等。</p><p>本文试图对市面上常见的安全产品进行分类来映射到IPDRR的五大能力<br><strong>识别（Identify）</strong>提供识别能力的产品包括资产管理平台、资产测绘平台、基线管理平台、漏洞扫描工具等。<br><strong>保护（Protect）</strong>提供保护能力的产品包括主机防御类EDR、VPN、4A、防火墙、IPS、WAF、抗DOS等<br><strong>检测（Detect）</strong> 提供威胁检测能力的产品包括IDS、NTA、蜜罐、恶意代码检测、用户异常行为检测等。<br><strong>响应（Respond）</strong>：提供响应能力的产品包括SIEM、安全审计、态势感知、SOAR等<br><strong>恢复（Recover）</strong>：提供恢复能力的产品包括NG-SOC，NG-SOC理论上应该是覆盖了IPDRR所有的能力。<br><img src="https://img-blog.csdnimg.cn/20210617155308964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="IPDRR产品能力映射"></p><p>当然企业安全能力不能够仅仅的依靠工具，是人、策略、流程、工具综合能力的体现。企业可以根据自身需求参考IPDRR能力框架模型加强网络安全能力建设，哪里欠缺补哪里，通过管理与技术结合来有效保障系统核心业务的安全。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见2020,2021我来了！</title>
      <link href="/posts/e5fab05b/"/>
      <url>/posts/e5fab05b/</url>
      
        <content type="html"><![CDATA[<p>今天是2021年1月1日，按照惯例应该是回忆过去展望未来的一天。</p><h2 id="回忆过去："><a href="#回忆过去：" class="headerlink" title="回忆过去："></a>回忆过去：</h2><p>在过去的一年里，曾今在2020年立下的flag是否都实现了呢？</p><p><strong>2020的flag：</strong></p><ul><li>看完10本英文原著。</li><li>爱分享网站运营PV要达5W,UV达5千</li><li>每周至少发一篇微信公众号文章</li><li>开通自己的博客</li><li>每周至少跑步3次</li></ul><p>2020年完成得最好的是看完了10本英文原著，因为2020过春节到第一季度受疫情影响，老老实实待在家里。在5月份就看完了10本英文原著。但是后来却没有坚持下来。看英文原著的热情慢慢的消退下来。一是看了这么多本原著似乎英文还是那么的菜打击了自己的信心，二是看英文原著比较耗时间4、5月份开始正常上班后时间就显得比较紧张了。后来7月份的时候准备考通信工程师的考试，时间更加紧张。所以继续看英文原著的事情就放下来了。英文很重要，学习英文2020年还是要继续坚持。</p><p> 爱分享网站因为各种原因在7月份的时候基本上已经停了，但是服务器还在续费。其实在5,6月份以前网站的访问量等各方面指标都一直在上升，因为疫情大家可能待在家里看书的需求量大增，网站的访问量一直都在持续的上升。如果网站不停基本上运营的flag还是可以达到的。现在的环境对于个人网站来说很艰难了。网站还会继续下去主要内容会以自己的博客为主了。</p><p>因为网站基本停了，一直在想网站生存的方向。微信公众号的文章也比较少更新了。还是自己肚子里的货太少了，写了一段时间以后发现没啥东西写了，坚持不下去了。真佩服那些现在还在每天更新的微信公众号。</p><p>经过多方比较决定用hexo来搭建自己的博客。写博客已经被认为是很古老的方式了，一直以来都很羡慕那些一直坚持下来的优质博主。想通过博客的方式记录自己的学习、生活、工作。2020年共写了24篇博客，产量不是很高，说明思考和积累还是不够。</p><p>跑步锻炼，在夏天天气好的时候还是坚持得不错，每周基本上坚持了一次。天气渐渐冷了起来以后懒筋发作很少出去跑步了。看着自己日益发胖的体重，要深刻的检讨一下。</p><p>2020年全年阅读量有所减少在豆瓣上标记只读了29本书。因为2020年中旬的时候决定考通信工程师和信息安全工程师，所以其他书看得比较少了。经过几个月的努力，顺利通过了通信工程师和信息安全工程师的考试。虽然2020年年初立的flag很多都没有完成，完成了的效果也不是特别好，但是过了通信工程师和信息安全工程师心里稍微有点宽慰。毕竟2020年努力过。</p><h2 id="展望未来："><a href="#展望未来：" class="headerlink" title="展望未来："></a>展望未来：</h2><p>不管怎么样，2020年已经成为过去式了。崭新的2021已经来到，先立下2021年的flag。</p><p><strong>2021年flag:</strong></p><ul><li>考CISP</li><li>考一建</li><li>发两篇论文</li><li>至少写30篇博客文章</li><li>完成12本英文原著</li><li>完成50本书籍的阅读量</li></ul><p>2021加油！</p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自我管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作这么多年了，我为什么还在考证</title>
      <link href="/posts/9fed4f95/"/>
      <url>/posts/9fed4f95/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20201218163950384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="学习学习"></p><p>工作这么多年了，我为什么还在考证？</p><p>因为以前一直没有考过啊！</p><p>毕业以来参加工作后，一直以来认为考证没有啥用处。一方面，因为找工作太过顺利，那会儿找工作也没有看到别人拿什么证去找工作，也没有看到那家公司的招聘广告上写需要什么什么证书。另一方面，由于才从学校出来对于学习考试有种天然的排斥。想想这么多年以来一直都是在学习考试。好不容易毕业了那还不好好放松一下。现在回想起来真是too young,too simple。</p><p>工作这么多年，都是在从事研发相关的工作。一开始写代码，要学的东西挺多的，从毕业时候的ASP到Java。能够完成工作任务，能够做出东西来才是硬道理。后来做项目经理，产品经理也是没有经过系统的培训和学习，在项目中磨练在项目中成长。在公司也带了几个重点大项目，项目也交付得令公司和客户比较满意。想想这研发和项目管理就那么回事。貌似所有的公司都是一样，不管你用什么办法，能够搞定项目的就是好的项目经理。至于有没有证没人关注。甚至公司过CMMI5的时候，我带的项目被抽为参审项目，我还没有系统的学过项目管理。虽然CMMI5已经过了，但是总感觉过得挺虚的。基本上就是在咨询公司的指导下，要你干什么就干什么，要你准备什么就准备什么。至于为啥是这样完全是懵逼。</p><p>人过中年，似乎不管到哪里都充满着危机感。以前自以为自己技术很牛逼，项目管理方面也是相当的OK。随着时间的推移这种自信心慢慢的越来越消退。大家都说搞IT的就是吃青春饭。就像随着年龄的增长，身体越来虚一样，心里也是越来越虚。心里虚了以后就想自己应该多学习提高自己。但是一段时间发现要学的东西实在是太多了，技术的、管理的。东一下西一下的，也没有什么效果。后来自己总结了一下，没有目标的学习都是假装在学习，只不过是安慰自己罢了。一定要给自己定个目标要学哪个方向，而检验学习效果的办法非常简单粗暴–考证。以考促学。能够考证通过不能说明你学得有多么的精深，至少也说明你达到了基本的平均水平。没有考试就没有压力，一本书拖拖拉拉看了一年还在看。而考试时间临近的压力对于深度拖延症患者也是一个很好的治愈方式。</p><p>就这样，我给自己制定的第一个学习目标就是系统的学习项目管理的理论体系，所以报了软考的信息系统项目管理师。经过半年多的学习顺利的拿到了信息系统项目管理师的证。学习的时候还是有一些感触，原来自己在平时的项目管理工作中还是有理论支撑的，人家在书中就已经写了。一些平时没有注意考虑到的点书上也有总结。回想起自己带的项目过CMMI5和过ISO认证等，以及公司的项目管理体系和质量管理体系结合书中的知识点，至少把我零散的一些项目管理知识和经验给系统化、体系化的联系起来了，让我对项目管理有了更深切的理解。尤其是在后来信息系统项目管理师考试写论文的时候，就能够可以很好的理论联系实践。</p><p>嗯，工作这么多年，我终于可以持证上岗了！</p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习考试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络信息安全管理要素和安全风险评估</title>
      <link href="/posts/8a1fa561/"/>
      <url>/posts/8a1fa561/</url>
      
        <content type="html"><![CDATA[<p>网络信息安全管理要素由网络管理对象、网络威胁、网络脆弱性、网络风险、网络保护措施组成。<br><img src="https://img-blog.csdnimg.cn/20201204163036136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="网络信息安全管理要素"><br>由于网络管理对象自身的脆弱性，使得威胁的发生成为可能，从而造成了不同的影响，形成了风险。</p><p>网络安全管理实际上就是风险控制，其基本过程是通过网络管理对象的威胁和脆弱性进行分析，确定网络管理对象的价值、网络管理对象威胁发生的可能性、网络管理对象的脆弱程度，从而确定网络管理对象的风险等级，然后据此选取合适的安全保护措施，降低网络管理对象的风险。</p><p>所有的安全管理、安全服务、安全技术等都是围绕网络信息安全管理要素来的。</p><p>网络安全风险评估是评价网络信息系统遭受潜在的安全威胁所产生的影响。</p><p>网络安全风险，是指由于网络系统所存在的脆弱性，因人为或自然的威胁导致安全事件发生所造成的可能性。网络风险评估就是评估威胁者利用网络资产的脆弱性，造成网络资产损失的严重程度。</p><p>网络安全风险评估过程，主要包括网络安全风险评估准备、资产识别、威胁识别、脆弱性识别、已有的安全措施分析、网络安全风险分析、网络安全风险处置与管理等。<br><img src="https://img-blog.csdnimg.cn/20201204163226746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="网络安全风险评估过程"><br><strong>资产识别</strong>包含“网络资产鉴定”和“网络资产价值估算”。前者给出评估所考虑的具体对象，确认网络资产种类和清单，是整个评估工作的基础。常见的网络资产主要分为网络设备、主机、服务器、应用、数据和文档资产等六个方面。</p><p>“网络资产价值估算”是某一具体资产在网络系统中的重要程度确认。</p><p>威胁是指可能对评估对象造成损害的外部原因。威胁利用评估对象自身的脆弱性，采用一定的途径和方式，对评估对象造成损害或损失，从而形成风险，<strong>威胁识别</strong>是对网络资产有可能受到的安全危害进行分析，一般从威胁来源、威胁途径、威胁意图等几个方面来分析。</p><p>脆弱性是指评估对象存在一个或多个脆弱的管理、技术、业务方面的漏洞，这些漏洞可能会被威胁所利用。<strong>脆弱性识别</strong>是指通过各种测试方法，获得网络资产中所存在的缺陷清单，这些缺陷会导致对信息资产的非授权访问、泄密、失控、破坏或不可用、绕过已有的安全机制，缺陷的存在将会危及网络资产的安全。</p><table><thead><tr><th>任务</th><th>输出文档</th><th>文档内容</th></tr></thead><tbody><tr><td>风险评估准备</td><td>会议记录并确认需要评估的系统、评估计划和评估程序</td><td>评估系统、评估计划和内容安排，双方负责人及需要明确的协调工作</td></tr><tr><td>访谈</td><td>针对业务系统进行技术安全和管理安全评估的访谈表</td><td>业务系统描述、运营情况和用户群体，并了解业务管理流程</td></tr><tr><td>文档审查（资产识别）</td><td>资产审查记录和业务系统审查记录</td><td>资产管理台账、网络拓扑图、业务运营管理制度和责任人</td></tr><tr><td>威胁识别</td><td>技术安全测评的网络、主机、应用测评结果记录，工具测试完成后的电子输出记录</td><td>漏洞扫描、渗透性测试、性能测试、入侵检测和协议分析等内容的技术测试结果</td></tr><tr><td>脆弱性识别</td><td>根据威胁识别结果，技术安全测评的网络、主机、应用测评</td><td>检查检查内容的记录，并根据威胁对业务系统脆弱性进行识别</td></tr><tr><td>风险处置</td><td>风险处置措施记录</td><td>对已识别的风险进行评估和处置，并评估是否存在残余风险</td></tr><tr><td>风险管理</td><td>对可接受的残余风险进行风险管理并出具风险评估报告</td><td>风险评估过程中发现的问题、问题的证据和证据源、每项检查活动中测评委托单位配合人员的书面认可</td></tr></tbody></table><p>网络安全风险分析是指在资产评估、威胁评估、脆弱性评估、安全管理评估、安全影响评估的基础上，综合利用定性和定量的分析方法，选择适当的风险计算方法或工具确定风险的大小与风险等级，即对网络系统安全管理范围内的每一个网络资产因遭受泄露、修改、不可用和破坏所带来的任何影响做出一个风险测量的列表，以便识别与选择适当和正确的安全控制方式。通过分析所评估的数据，进行风险值计算。</p><p><img src="https://img-blog.csdnimg.cn/20201204163838552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="网络安全风险分析"><br>网络安全风险分析的主要步骤如下：<br>一、对资产进行识别，并对资产的价值进行赋值。<br>二、对威胁进行识别，描述威胁的属性，并对威胁出现的频率赋值。<br>三、对脆弱性进行识别，并对具体资产的脆弱性的严重程度赋值。<br>四、根据威胁及威胁利用脆弱性的难易程度判断安全事件发生的可能性<br>五、根据脆弱性的严重程度及安全事件所作用的资产价值计算安全事件的损失。<br>六、根据安全事件发生的可能性及安全事件出现后的损失，计算安全事件一旦发生对组织的影响，即网络安全风险值。其中，安全事件损失是指确定已经鉴定的资产受到损害所带来的影响。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyinstaller打包exe后不能运行报Failed to execute script XXXX问题分析与处理</title>
      <link href="/posts/19a32f6f/"/>
      <url>/posts/19a32f6f/</url>
      
        <content type="html"><![CDATA[<p>最近用python的tkinter写了个小工具，发现用pyinstaller打包成exe后运行出错。报Failed to execute script XXXX</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F -w worksubmit.py</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201101171716408.png#pic_center" alt="报错"><br>为了搞清楚报错的原因，想看到程序具体执行的情况。可以通过不带-w的参数打包在控制台看程序执行情况。<br><code>pyinstaller -F worksubmit.py</code> 可以通过不带-w的参数打包，这时打包的exe运行是带控制台的命令行<br><img src="https://img-blog.csdnimg.cn/20201101172133371.png#pic_center" alt="运行情况"><br>可以清楚的看到</p><blockquote><p>ModuleNotFoundError:No module named ‘xlrd’</p></blockquote><p>这时就要解决打包时xlrd模块没有打进去的问题，找到xlrd模块的位置，并将该模块打到运行程序包里。<br>先找到程序依赖的xlrd模块的位置，在PyCharm中通过”File”-&gt;”Setting”,在项目设置里查看Project interpreter，可以看到xlrd的目录位置。<br><img src="https://img-blog.csdnimg.cn/20201101172227853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70#pic_center" alt="找包路径"></p><p>用pyinstall打包的时候通过加-p的参数将依赖的模块打进去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F -p J:\study\python\testsubmit\venv\Lib\site-packages worksubmit.py</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201101172053955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这样就可以顺利将依赖的模块打进去，再执行exe文件不再报错了。</p><p><strong>总结一下，碰到打包成exe后运行有问题，可以通过不带-w的参数打包，这时打包的exe运行是带控制台的命令行。基本上所有的运行问题都可以通过控制台的命令定位和排查。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>等级保护与分级保护的关系和区别</title>
      <link href="/posts/dc4d08f1/"/>
      <url>/posts/dc4d08f1/</url>
      
        <content type="html"><![CDATA[<p>等级保护与分级保护既有联系又有区别：</p><p>国家安全信息等级保护，重点保护的对象是非涉密的涉及国计民生的重要信息系统和通信基础信息系统；涉密信息系统分级保护是国家信息安全等级保护的重要组成部分，是等级保护在涉密领域的具体体现。</p><p>国家安全信息等级保护重点保护的对象是涉及国计民生的重要信息系统和通信基础信息系统，而不论它是否涉密。涉密信息系统分级保护保护的对象是所有涉及国家秘密的信息系统，重点是党政机关、军队和军工单位，由各级保密工作部门根据涉密信息系统的保护等级实施监督管理，确保系统和信息安全，确保国家秘密不被泄漏。</p><p>国家信息安全等级保护是国家从整体上、根本上解决国家信息安全问题的办法,进一步确定了信息安全发展的主线和中心任务,提出了总体要求。对信息系统实行等级保护是国家法定制度和基本国策，是开展信息安全保护工作的有效办法，是信息安全保护工作的发展方向。而涉密信息系统分级保护则是国家信息安全等级保护在涉及国家秘密信息的信息系统中的特殊保护措施与方法。</p><p><strong>等级保护与分级保护本质的区别是等级保护适用的对象为非涉密信息系统，分级保护适用的对象为涉密信息系统。</strong></p><p>具体区别如下：</p><table><thead><tr><th>项目</th><th>等级保护</th><th>分级保护</th></tr></thead><tbody><tr><td>管理体系</td><td>公安机关</td><td>国家保密部门</td></tr><tr><td>标准体系</td><td>国家标准（GB、GB/T）</td><td>国家保密标准（BMB，强制执行）</td></tr><tr><td>适用对象</td><td>非涉密信息系统</td><td>涉密信息系统</td></tr><tr><td>定级依据</td><td>等级保护定级是依据重要业务系统与承载业务运行的网络、设备、系统及单位属性、遭到破坏后所影响的主、客体关系等。</td><td>分级保护定级是依据信息的重要性，以信息最高密级确定受保护的级别。</td></tr><tr><td>级别划分</td><td>第一级：自主保护级<br>第二级：指导保护级<br>第三极：监督保护级<br>第四级：强制保护级<br>第五级：专控保护级</td><td>秘密级<br>机密级<br>绝密级</td></tr><tr><td>工作内容</td><td>信息系统等级保护工作包括：<br>系统定级、系统备案、安全建设整改、等级测评和监督检查五个环节。</td><td>涉密信息系统分级保护工作包括:<br>系统定级、方案设计、工程实施、系统测评、系统审批、日常管理、测评与检查和系统废止八个环节。</td></tr><tr><td>测评频率</td><td>第三级信息系统：应每年至少进行一次等级测评；<br>第四级信息系统：应每年至少进行一次等级测评；<br>第五级信息系统：应当根据特殊安全要求进行等级测评。</td><td>秘密级、机密级信息系统：应每两年至少进行一次安全保密测评或保密检查；<br>绝密级信息系统：应每年至少进行一次安全保密测评或保密检查。</td></tr><tr><td>评测机构</td><td>国家信息安全等级保护工作协调小组办公室授权的信息安全等级保护测评机构</td><td>由国家保密工作部门授权的系统测评机构</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Supervisor离线安装及使用</title>
      <link href="/posts/d670c9b8/"/>
      <url>/posts/d670c9b8/</url>
      
        <content type="html"><![CDATA[<p>Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警</p><p>supervisor的安装有多种方式<br>配置好yum源后，可以直接安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install supervisor</span><br></pre></td></tr></table></figure><p>Debian/Ubuntu可通过apt安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install supervisor</span><br></pre></td></tr></table></figure><p>pip安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure><p>easy_install安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install</span><br></pre></td></tr></table></figure><p>这几种安装方式都需要在线联网。但大部分的生产环境都是离线环境，是封闭的网络没有办法在线安装。</p><p>这里整理了Supervisor的离线安装包和安装脚本，可以进行离线安装并能指定安装目录。</p><h1 id="一、整理Supervisor安装需要的工具和依赖包"><a href="#一、整理Supervisor安装需要的工具和依赖包" class="headerlink" title="一、整理Supervisor安装需要的工具和依赖包"></a>一、整理Supervisor安装需要的工具和依赖包</h1><p>包括有：<br>setuptools<br>elementtree<br>meld3<br>supervisor</p><h1 id="二、编写离线安装脚本"><a href="#二、编写离线安装脚本" class="headerlink" title="二、编写离线安装脚本"></a>二、编写离线安装脚本</h1><p>整体思路：依次解压并安装Supervisor所需要的工具和依赖包，将Supervisor的配置文件的默认安装目录路径替换成制定的目录路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi install_supervisor.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="keyword">function</span> Install_Supervisor()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">#Install supervisord</span></span><br><span class="line">    tar -zxvf setuptools-24.0.2.tar.gz 2&gt;&amp;1 &gt;/dev/null</span><br><span class="line">    <span class="built_in">cd</span> setuptools-24.0.2/</span><br><span class="line">    python setup.py install &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">    <span class="built_in">cd</span> ..</span><br><span class="line">    easy_install elementtree-1.2.7-20070827-preview.zip &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">    easy_install meld3-0.6.5.tar.gz 2&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">    easy_install supervisor-3.3.0.tar.gz &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">    mkdir -p <span class="variable">$&#123;INSTALL_DIR&#125;</span>/etc/</span><br><span class="line">    mkdir -p <span class="variable">$&#123;INSTALL_DIR&#125;</span>/tmp/</span><br><span class="line">    mkdir -p <span class="variable">$&#123;INSTALL_DIR&#125;</span>/logs/</span><br><span class="line">    cp etc/supervisord.conf <span class="variable">$&#123;INSTALL_DIR&#125;</span>/etc/</span><br><span class="line">    sed -i <span class="string">"s#__install_dir__#<span class="variable">$&#123;INSTALL_DIR&#125;</span>#g"</span> <span class="variable">$&#123;INSTALL_DIR&#125;</span>/etc/supervisord.conf</span><br><span class="line">    sed -i <span class="string">"s#__user__#<span class="variable">$&#123;USER&#125;</span>#g"</span> <span class="variable">$&#123;INSTALL_DIR&#125;</span>/etc/supervisord.conf</span><br><span class="line">    ln -s /usr/bin/supervisorctl <span class="variable">$&#123;INSTALL_DIR&#125;</span>/commandctl</span><br><span class="line">    cp run_supervisor.sh <span class="variable">$&#123;INSTALL_DIR&#125;</span>/</span><br><span class="line">    sed -i <span class="string">"s#__install_dir__#<span class="variable">$&#123;INSTALL_DIR&#125;</span>#g"</span> <span class="variable">$&#123;INSTALL_DIR&#125;</span>/run_supervisor.sh</span><br><span class="line">    chmod +x <span class="variable">$&#123;INSTALL_DIR&#125;</span>/run_supervisor.sh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">USER=<span class="string">'root'</span></span><br><span class="line"><span class="keyword">if</span> [ ! -n <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">   INSTALL_DIR=<span class="string">'/app/supervisor'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   INSTALL_DIR=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">Install_Supervisor</span><br></pre></td></tr></table></figure><p>安装脚本中默认的安装路径是/app/supervisor，可以根据实际情况进行调整。</p><p>另外整理了一个run_supervisor.sh的脚本，在安装以后根据安装目录来生成这个启动脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">cd</span> __install_dir__</span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"tmp"</span> ];<span class="keyword">then</span></span><br><span class="line">  mkdir tmp</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"tmp文件夹已经存在"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"logs"</span> ];<span class="keyword">then</span></span><br><span class="line">  mkdir logs</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"logs文件夹已经存在"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">/usr/bin/supervisord -c __install_dir__/etc/supervisord.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"supervisord 已执行。"</span></span><br></pre></td></tr></table></figure><h1 id="三、将所有的安装包脚本等打成离线安装包"><a href="#三、将所有的安装包脚本等打成离线安装包" class="headerlink" title="三、将所有的安装包脚本等打成离线安装包"></a>三、将所有的安装包脚本等打成离线安装包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf  supervisor_install_pack.tar.gz  supervisor</span><br></pre></td></tr></table></figure><p>已打好的离线安装包下载 <a href="https://545c.com/file/21165215-443895501" target="_blank" rel="noopener">https://545c.com/file/21165215-443895501</a><br><a href="https://545c.com/file/21165215-443895501" target="_blank" rel="noopener">城通网盘下载</a>   <a href="https://545c.com/file/21165215-443895501" target="_blank" rel="noopener">https://545c.com/file/21165215-443895501</a><br><a href="https://download.csdn.net/download/fullbug/12434225" target="_blank" rel="noopener">CSDN下载</a> <a href="https://download.csdn.net/download/fullbug/12434225" target="_blank" rel="noopener">https://download.csdn.net/download/fullbug/12434225</a></p><h1 id="四、离线安装包使用"><a href="#四、离线安装包使用" class="headerlink" title="四、离线安装包使用"></a>四、离线安装包使用</h1><p>下载离线安包，解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf supervisor_install_pack.tar.gz</span><br></pre></td></tr></table></figure><p>解压后看到supervisor的目录，在supervisor的目录中找到install_supervisor.sh的脚本<br><img src="https://img-blog.csdnimg.cn/20200518111602385.png" alt="supervisor离线包安装目录"><br>执行install_supervisor.sh的脚本，默认安装/app/supervisor下，可以带参数指定安装目录。也可以修改install_supervisor.sh脚本自定义默认的安装路径。<br>执行完安装脚本，就可以在/app/supervisor目录下看到有相应的启动脚本、配置文件目录、日志目录及临时文件目录。<br><img src="https://img-blog.csdnimg.cn/20200518111653544.png" alt="supervisor运行目录"><br>执行run_supervisor.sh就可以启动supervisor</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run_supervisor.sh</span><br></pre></td></tr></table></figure><h1 id="五、验证和使用supervisor"><a href="#五、验证和使用supervisor" class="headerlink" title="五、验证和使用supervisor"></a>五、验证和使用supervisor</h1><p>ps -ef|grep supervisor  查看supervisor是否已经启动<br><img src="https://img-blog.csdnimg.cn/20200518111736457.png" alt="查看supervisor是否已经启动"><br>通过web界面的9001看web界面控制台<a href="http://127.0.0.1:9001" target="_blank" rel="noopener">http://127.0.0.1:9001</a><br><img src="https://img-blog.csdnimg.cn/20200518111807123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="web界面控制台"></p><ul><li>supervisord<br>运行 Supervisor 时会启动一个进程 supervisord，它负责启动所管理的进程，并将所管理的进程作为自己的子进程来启动，而且可以在所管理的进程出现崩溃时自动重启。<br>supervisord -v 查看supervisor版本号</li><li>supervisorctl<br>是命令行管理工具，可以用来执行 stop、start、restart 等命令，来对这些子进程进行管理。<br>supervisor是所有进程的父进程，管理着启动的子进展，supervisor以子进程的PID来管理子进程，当子进程异常退出时supervisor可以收到相应的信号量。</li></ul><p><strong>supervisor常用管理命令</strong><br>supervisorctl restart &lt; application name&gt; ;重启指定应用<br>supervisorctl stop &lt; application name&gt; ;停止指定应用<br>supervisorctl start &lt; application name&gt; ;启动指定应用<br>supervisorctl restart all ;重启所有应用<br>supervisorctl stop all ;停止所有应用<br>supervisorctl start all ;启动所有应用</p><h1 id="六、配置文件说明"><a href="#六、配置文件说明" class="headerlink" title="六、配置文件说明"></a>六、配置文件说明</h1><h2 id="supervisor-conf配置文件"><a href="#supervisor-conf配置文件" class="headerlink" title="supervisor.conf配置文件"></a>supervisor.conf配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ;UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">;chmod=0700                 ;socket文件的mode，默认是0700</span><br><span class="line">;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid</span><br><span class="line"> </span><br><span class="line">;[inet_http_server]         ;HTTP服务器，提供web管理界面</span><br><span class="line">;port=127.0.0.1:9001        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span><br><span class="line">;username=user              ;登录管理后台的用户名</span><br><span class="line">;password=123               ;登录管理后台的密码</span><br><span class="line"> </span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.log ;日志文件，默认是 <span class="variable">$CWD</span>/supervisord.log</span><br><span class="line">logfile_maxbytes=50MB        ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span><br><span class="line">logfile_backups=10           ;日志文件保留备份数量默认10，设为0表示不备份</span><br><span class="line">loglevel=info                ;日志级别，默认info，其它: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ;pid 文件</span><br><span class="line">nodaemon=<span class="literal">false</span>               ;是否在前台启动，默认是<span class="literal">false</span>，即以 daemon 的方式启动</span><br><span class="line">minfds=1024                  ;可以打开的文件描述符的最小值，默认 1024。注意托管ES进程，这里要进行调整至65535</span><br><span class="line">minprocs=200                 ;可以打开的进程数的最小值，默认 200。注意托管ES进程，这里要进行调整至4096</span><br><span class="line"> </span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span><br><span class="line">;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span><br><span class="line"> </span><br><span class="line">; [program:xx]是被管理的进程配置参数，xx是进程的名称</span><br><span class="line">[program:xx]</span><br><span class="line"><span class="built_in">command</span>=/opt/apache-tomcat-8.0.35/bin/catalina.sh run  ; 程序启动命令</span><br><span class="line">autostart=<span class="literal">true</span>       ; 在supervisord启动的时候也自动启动</span><br><span class="line">startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span><br><span class="line">autorestart=<span class="literal">true</span>     ; 程序退出后自动重启,可选值：[unexpected,<span class="literal">true</span>,<span class="literal">false</span>]，默认为unexpected，表示进程意外杀死后才重启</span><br><span class="line">startretries=3       ; 启动失败自动重试次数，默认是3</span><br><span class="line">user=tomcat          ; 用哪个用户启动进程，默认是root</span><br><span class="line">priority=999         ; 进程启动优先级，默认999，值小的优先启动</span><br><span class="line">redirect_stderr=<span class="literal">true</span> ; 把stderr重定向到stdout，默认<span class="literal">false</span></span><br><span class="line">stdout_logfile_maxbytes=20MB  ; stdout 日志文件大小，默认50MB</span><br><span class="line">stdout_logfile_backups = 20   ; stdout 日志文件备份数，默认是10</span><br><span class="line">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class="line">stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.out</span><br><span class="line">stopasgroup=<span class="literal">false</span>     ;默认为<span class="literal">false</span>,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span><br><span class="line">killasgroup=<span class="literal">false</span>     ;默认为<span class="literal">false</span>，向进程组发送<span class="built_in">kill</span>信号，包括子进程</span><br><span class="line"> </span><br><span class="line">;包含其它配置文件</span><br><span class="line">[include]</span><br><span class="line">files = supervisord.d/*.ini    ;默认放在安装目录的supervisord.d目录下，可以指定一个或多个以.ini结束的配置文件。</span><br></pre></td></tr></table></figure><h2 id="子进程配置文件"><a href="#子进程配置文件" class="headerlink" title="子进程配置文件"></a>子进程配置文件</h2><p>需要给托管的子进程配置相应的配置文件，每个进程的配置文件都可以单独分拆也可以把相关的脚本放一起。目录及文件后缀可以在<br>supervisor.conf配置文件中进行自定义。见supervisor.conf的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">files = supervisord.d/*.ini  <span class="comment">#目录路径及文件后缀名都可以自定义。</span></span><br></pre></td></tr></table></figure><p>logstash.ini 样例说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#项目名</span></span><br><span class="line">[program:logstash-test]</span><br><span class="line"><span class="comment">#脚本目录</span></span><br><span class="line">directory=/app/elk/logstash-7.6.0</span><br><span class="line"><span class="comment">#脚本执行命令</span></span><br><span class="line"><span class="built_in">command</span>=/app/elk/logstash-7.6.0/bin/logstash -f /app/elk/logstash-7.6.0/bin/<span class="built_in">test</span>-pipeline.conf</span><br><span class="line"><span class="comment">#进程数</span></span><br><span class="line">numprocs=1</span><br><span class="line"><span class="comment">#supervisor启动的时候是否随着同时启动，默认True</span></span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line"><span class="comment">#当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的</span></span><br><span class="line">autorestart=<span class="literal">false</span></span><br><span class="line"><span class="comment">#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1</span></span><br><span class="line">startsecs=1</span><br><span class="line"><span class="comment">#脚本运行的用户身份 </span></span><br><span class="line">user = root</span><br><span class="line"><span class="comment">#把stderr重定向到stdout，默认 false</span></span><br><span class="line">redirect_stderr = <span class="literal">true</span></span><br><span class="line"><span class="comment">#stdout日志文件大小，默认 50MB</span></span><br><span class="line">stdout_logfile_maxbytes = 10M</span><br><span class="line"><span class="comment">#stdout日志文件备份数</span></span><br><span class="line">stdout_logfile_backups = 10</span><br><span class="line"><span class="comment">#日志输出 </span></span><br><span class="line">stderr_logfile=/app/elk/logstash-7.6.0/logs/logstash_test_error.log</span><br><span class="line">stdout_logfile=/app/elk/logstash-7.6.0/logs/logstash_test_out.log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logstash简明实用教程</title>
      <link href="/posts/a59d6c21/"/>
      <url>/posts/a59d6c21/</url>
      
        <content type="html"><![CDATA[<h1 id="一、logstash是什么"><a href="#一、logstash是什么" class="headerlink" title="一、logstash是什么"></a>一、logstash是什么</h1><p>Logstash 是开源的服务器端<strong>数据处理管道</strong>，能够同时从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的“存储库”中。<br>官方介绍：Logstash is an open source data collection engine with real-time pipelining capabilities。简单来说logstash就是一根具备实时数据传输能力的管道，负责将数据信息从管道的输入端传输到管道的输出端；与此同时这根管道还可以让你根据自己的需求在中间加上滤网，Logstash提供里很多功能强大的滤网以满足你的各种应用场景。<br>Logstash 能够动态地采集、转换和传输数据，不受格式或复杂度的影响。利用 Grok 从非结构化数据中派生出结构，从 IP 地址解码出地理坐标，匿名化或排除敏感字段，并简化整体处理过程。</p><p>Logstash常用于日志关系系统中做日志采集设备；<br><img src="https://img-blog.csdnimg.cn/20200414152706269.png" alt="logstash"><br>系统结构<br><img src="https://img-blog.csdnimg.cn/20200414153844982.png" alt="logstash系统结构"><br>Logstash的事件（logstash将数据流中等每一条数据称之为一个event）处理流水线有三个主要角色完成：<strong>inputs –&gt; filters –&gt; outputs</strong>：</p><p><strong>输入（inpust）</strong>：必须，负责产生事件（Inputs generate events），常用：File、syslog、redis、beats（如：Filebeats）<br>Logstash 支持 各种输入选择 ，可以在同一时间从众多常用来源捕捉事件。能够以连续的流式传输方式，轻松地从日志、指标、Web 应用、数据存储以及各种 AWS 服务采集数据。</p><p><strong>过滤器（filters）</strong>：可选，负责数据处理与转换（filters modify them），常用：grok、mutate、drop、clone、geoip<br>过滤器能实时解析和转换数据<br>数据从源传输到存储库的过程中，Logstash 过滤器能够解析各个事件，识别已命名的字段以构建结构，并将它们转换成通用格式，以便更轻松、更快速地分析和实现商业价值。</p><ul><li>利用 Grok 从非结构化数据中派生出结构 </li><li>从 IP 地址破译出地理坐标 </li><li>将 PII 数据匿名化，完全排除敏感字段</li><li>简化整体处理，不受数据源、格式或架构的影响</li></ul><p><strong>输出（outpus）</strong>：必须，负责数据输出（outputs ship them elsewhere），常用：elasticsearch、file、graphite、statsd<br>Logstash 提供众多输出选择，可以将数据发送到指定的地方，并且能够灵活地解锁众多下游用例</p><p>其中inputs和outputs支持codecs（coder&amp;decoder）在1.3.0 版之前，logstash 只支持纯文本形式输入，然后以过滤器处理它。但现在，我们可以在输入 期处理不同类型的数据，所以完整的数据流程应该是：input | decode | filter | encode | output；codec 的引入，使得 logstash 可以更好更方便的与其他有自定义数据格式的运维产品共存，比如：graphite、fluent、netflow、collectd，以及使用 msgpack、</p><h1 id="二、为什么是logstash"><a href="#二、为什么是logstash" class="headerlink" title="二、为什么是logstash"></a>二、为什么是logstash</h1><p><strong>Logstash和Flume对比</strong><br>1、Logstash比较偏重于字段的预处理，在异常情况下可能会出现数据丢失，只是在运维日志场景下，一般认为这个可能不重要；而Flume偏重数据的传输，几乎没有数据的预处理，仅仅是数据的产生，封装成event然后传输；传输的时候flume比logstash多考虑了一些可靠性。因为数据会持久化在channel中，数据只有存储在下一个存储位置（可能是最终的存储位置，如HDFS；也可能是下一个Flume节点的channel），数据才会从当前的channel中删除。这个过程是通过事务来控制的，这样就保证了数据的可靠性。<br>2、Logstash有几十个插件，配置比较灵活，flume强调用户自定义开发；<br>3、Logstash的input和filter还有output之间都存在buffer，进行缓冲；Flume直接使用channel做持久化<br>4、Logstash性能以及资源消耗比较严重，且不支持缓存；<br><img src="https://img-blog.csdnimg.cn/20200414154043951.png" alt="Logstash和Flume对比"><br>详见参考：<a href="https://blog.csdn.net/songfeihu0810232/article/details/94406608" target="_blank" rel="noopener">https://blog.csdn.net/songfeihu0810232/article/details/94406608</a></p><h1 id="三、logstash安装与配置"><a href="#三、logstash安装与配置" class="headerlink" title="三、logstash安装与配置"></a>三、logstash安装与配置</h1><h2 id="1、logstash安装"><a href="#1、logstash安装" class="headerlink" title="1、logstash安装"></a>1、logstash安装</h2><p>环境要求：jdk1.8或以上<br>下载logstash软件包  logstash官方下载地址<a href="https://www.elastic.co/cn/downloads/logstash" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/logstash</a><br>下载后直接解压就可以用<br>如：tar zxvf logstash-7.6.0.tar.gz<br>解压后目录如下：<br><img src="https://img-blog.csdnimg.cn/20200414154300993.png" alt="logstash目录"><br>目录结构说明见官方文档：<a href="https://www.elastic.co/guide/en/logstash/7.1/dir-layout.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/7.1/dir-layout.html</a><br>解压以后可以对logstash进行简单的测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash -e <span class="string">'input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;'</span></span><br></pre></td></tr></table></figure><p>这条命令表示通过命令的方式指定logstash的输入输出分别是标准的输入输出，什么是标准的输入输出呢？就是控制台的输入输出。<br>等待启动成功，直接输入“hello world”<br>将会在控制台会有相应的输出<br>出现这些信息就表示logstash安装成功并且可以使用了。<br><img src="https://img-blog.csdnimg.cn/20200414154431921.png" alt="logstash测试"></p><h2 id="2、在线安装logstash插件"><a href="#2、在线安装logstash插件" class="headerlink" title="2、在线安装logstash插件"></a>2、在线安装logstash插件</h2><p>虽然logstash默认安装了大部分的插件，但是有些插件没有默认安装，如logstash-output-syslog、logstash-output-jdbc</p><h3 id="2-1-安装Gem并更新"><a href="#2-1-安装Gem并更新" class="headerlink" title="2.1. 安装Gem并更新"></a>2.1. 安装Gem并更新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install -y gem</span></span><br><span class="line"><span class="comment"># gem -v</span></span><br><span class="line">2.0.14.1</span><br><span class="line"><span class="comment"># gem update --system</span></span><br><span class="line"><span class="comment"># gem -v</span></span><br><span class="line">3.1.2</span><br></pre></td></tr></table></figure><h3 id="2-2-检查并修改镜像源"><a href="#2-2-检查并修改镜像源" class="headerlink" title="2.2 检查并修改镜像源"></a>2.2 检查并修改镜像源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gem sources -l</span></span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"> </span><br><span class="line">https://rubygems.org/</span><br><span class="line"></span><br><span class="line"><span class="comment"># gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span></span><br><span class="line">https://gems.ruby-china.com/ added to sources</span><br><span class="line">https://rubygems.org/ removed from sources</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat ~/.gemrc </span></span><br><span class="line">---</span><br><span class="line">:backtrace: <span class="literal">false</span></span><br><span class="line">:bulk_threshold: 1000</span><br><span class="line">:sources:</span><br><span class="line">- https://gems.ruby-china.com/</span><br><span class="line">:update_sources: <span class="literal">true</span></span><br><span class="line">:verbose: <span class="literal">true</span></span><br><span class="line">:concurrent_downloads: 8</span><br></pre></td></tr></table></figure><blockquote><p>请注意：国内的镜像站从<a href="https://gems.ruby-china.org" target="_blank" rel="noopener">https://gems.ruby-china.org</a> 换成了 <a href="https://gems.ruby-china.com" target="_blank" rel="noopener">https://gems.ruby-china.com</a><br>！！！现在很多网上的资料就都是写的<a href="https://gems.ruby-china.org，导致很多人换了镜像源也装不上。" target="_blank" rel="noopener">https://gems.ruby-china.org，导致很多人换了镜像源也装不上。</a></p></blockquote><h3 id="2-3-修改-logstash的-gem-镜像源"><a href="#2-3-修改-logstash的-gem-镜像源" class="headerlink" title="2.3. 修改 logstash的 gem 镜像源"></a>2.3. 修改 logstash的 gem 镜像源</h3><p>cd到logstach的安装目录，可以看到Gemfile文件 <code>vi Gemfile</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a Logstash generated Gemfile.</span></span><br><span class="line"><span class="comment"># If you modify this file manually all comments and formatting will be lost.</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">source</span> <span class="string">"https://rubygems.org"</span></span><br><span class="line">gem <span class="string">"logstash-core"</span>, :path =&gt; <span class="string">"./logstash-core"</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>更改默认的 <a href="https://rubygems.org" target="_blank" rel="noopener">https://rubygems.org</a> 为<a href="https://gems.ruby-china.com" target="_blank" rel="noopener">https://gems.ruby-china.com</a></p><h3 id="2-4、安装插件"><a href="#2-4、安装插件" class="headerlink" title="2.4、安装插件"></a>2.4、安装插件</h3><p><img src="https://img-blog.csdnimg.cn/20200414155435362.png" alt="安装插件"></p><h2 id="3、离线安装logstash插件"><a href="#3、离线安装logstash插件" class="headerlink" title="3、离线安装logstash插件"></a>3、离线安装logstash插件</h2><p>在实际应用过程中有些生产环境是封闭的网络环境，没法连接外网。这时候就需要离线安装插件。<br>说离线安装实际就是在一个有网络的环境下将插件装好，然后再装到离线环境中。<br>这里有两种方式,<br>一种就是在有网络的环境下将插件装好，将整个logsash包离线拷到生产环境。<br>另一种方式就是在有网络的环境下将插件装好后，将logstash的需要离线安装的插件打个离线包，然后再在生产环境进行离线安装。<br>离线插件包打包安装具体操作如下：</p><h3 id="3-1-通过logstash-plugin-prepare-offline-pack-命令将插件打成zip包"><a href="#3-1-通过logstash-plugin-prepare-offline-pack-命令将插件打成zip包" class="headerlink" title="3.1 通过logstash-plugin prepare-offline-pack 命令将插件打成zip包"></a>3.1 通过logstash-plugin prepare-offline-pack 命令将插件打成zip包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./logstash-plugin prepare-offline-pack --output logstash-output-syslog.zip logstash-output-syslog</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200414155806703.png" alt="打包"><br>打包命令执行成功以后，可以看到在logstash的bin目录下有打成的离线插件zip包<br><img src="https://img-blog.csdnimg.cn/20200414155831404.png" alt="打包后生成的离线包"></p><h3 id="3-2-通过logstash-plugin-install-进行离线安装"><a href="#3-2-通过logstash-plugin-install-进行离线安装" class="headerlink" title="3.2 通过logstash-plugin install 进行离线安装"></a>3.2 通过logstash-plugin install 进行离线安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash-plugin install file:///home/logstash/logstash-7.6.2/tools/logstash-output-syslog.zip</span><br></pre></td></tr></table></figure><p>安装后成功会有如下提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Installing file: /home/logstash/logstash-7.6.2/tools/logstash-output-syslog.zip</span><br><span class="line">Install successful</span><br></pre></td></tr></table></figure><h3 id="3-2-通过logstash-plugin-list命令检查插件是否安装成功"><a href="#3-2-通过logstash-plugin-list命令检查插件是否安装成功" class="headerlink" title="3.2 通过logstash-plugin list命令检查插件是否安装成功"></a>3.2 通过logstash-plugin list命令检查插件是否安装成功</h3><p><img src="https://img-blog.csdnimg.cn/20200414155929438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="logstash-plugin list"></p><h2 id="4、logstash简单配置说明"><a href="#4、logstash简单配置说明" class="headerlink" title="4、logstash简单配置说明"></a>4、logstash简单配置说明</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Logstash 设计了自己的 DSL ——包括有区域，注释，数据类型(布尔值，字符串，数值，数组，哈希)，条件判断，字段引用等。</p><h3 id="区段-section"><a href="#区段-section" class="headerlink" title="区段(section)"></a>区段(section)</h3><p>Logstash 用 {} 来定义区域。区域内可以包括插件区域定义，你可以在一个区域内定义多个插件。插件区域内则可以定义键值对设置。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    stdin &#123;&#125;</span><br><span class="line">    syslog &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Logstash 支持少量的数据值类型：</p><ul><li>bool<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug =&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li>string<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host =&gt; <span class="string">"hostname"</span></span><br></pre></td></tr></table></figure></li><li>number<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port =&gt; <span class="number">514</span></span><br></pre></td></tr></table></figure></li><li>array<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match =&gt; [<span class="string">"datetime"</span>, <span class="string">"UNIX"</span>, <span class="string">"ISO8601"</span>]</span><br></pre></td></tr></table></figure></li><li>hash<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">options =&gt; &#123;</span><br><span class="line">    key1 =&gt; <span class="string">"value1"</span>,</span><br><span class="line">    key2 =&gt; <span class="string">"value2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字段引用-field-reference"><a href="#字段引用-field-reference" class="headerlink" title="字段引用(field reference)"></a>字段引用(field reference)</h3>如果想在 Logstash 配置中使用字段的值，只需要把字段的名字写在中括号 [] 里就行了，这就叫字段引用。<br>对于 嵌套字段(也就是多维哈希表，或者叫哈希的哈希)，每层的字段名都写在 [] 里就可以了。比如，你可以从 geoip 里这样获取 longitude 值：<br>[geoip][location][0]<br>logstash 的数组也支持倒序下标，即 [geoip][location][-1] 可以获取数组最后一个元素的值。<br>Logstash 还支持变量内插，在字符串里使用字段引用的方法是这样：<br>“the longitude is %{[geoip][location][0]}”</li></ul><h3 id="条件判断-condition"><a href="#条件判断-condition" class="headerlink" title="条件判断(condition)"></a>条件判断(condition)</h3><p>表达式支持下面这些操作符：<br>equality, etc: ==, !=, &lt;, &gt;, &lt;=, &gt;=<br>regexp: =<del>, !</del><br>inclusion: in, not in<br>boolean: and, or, nand, xor<br>unary: !()<br>通常来说，你都会在表达式里用到字段引用。比如：<br>if “_grokparsefailure” not in [tags] {<br>} else if [status] !~ /^2\d\d/ and [url] == “/noc.gif” {<br>} else {<br>}</p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>Logstash 提供了一个 shell 脚本叫 logstash 方便快速运行。它支持一下参数：<br>-e<br>意即执行。我们在 “Hello World” 的时候已经用过这个参数了。事实上可以不写任何具体配置，直接运行 <code>bin/logstash -e</code> ‘’ 达到相同效果。这个参数的默认值是下面这样：<br>input {<br>    stdin { }<br>}<br>output {<br>    stdout { }<br>}<br>–config 或 -f<br>意即文件。真实运用中，我们会写很长的配置，甚至可能超过 shell 所能支持的 1024 个字符长度。所以我们必把配置固化到文件里，然后通过 <code>bin/logstash -f agent.conf</code> 这样的形式来运行。<br>此外，logstash 还提供一个方便我们规划和书写配置的小功能。你可以直接用 <code>bin/logstash -f /etc/logstash.d/</code> 来运行。logstash 会自动读取 /etc/logstash.d/ 目录下所有的文本文件，然后在自己内存里拼接成一个完整的大配置文件，再去执行。<br>–configtest 或 -t<br>意即测试。用来测试 Logstash 读取到的配置文件语法是否能正常解析。Logstash 配置语法是用 grammar.treetop 定义的。尤其是使用了上一条提到的读取目录方式的读者，尤其要提前测试。<br>–log 或 -l<br>意即日志。Logstash 默认输出日志到标准错误。生产环境下你可以通过 bin/logstash -l logs/logstash.log 命令来统一存储日志。<br>–filterworkers 或 -w<br>意即工作线程。Logstash 会运行多个线程。你可以用 <code>bin/logstash -w 5</code> 这样的方式强制 Logstash 为过滤插件运行 5 个线程。</p><h1 id="四、logstash使用的几种典型的应用场景"><a href="#四、logstash使用的几种典型的应用场景" class="headerlink" title="四、logstash使用的几种典型的应用场景"></a>四、logstash使用的几种典型的应用场景</h1><h2 id="1、通过logstash将syslog日志原始日志转发"><a href="#1、通过logstash将syslog日志原始日志转发" class="headerlink" title="1、通过logstash将syslog日志原始日志转发"></a>1、通过logstash将syslog日志原始日志转发</h2><p><img src="https://img-blog.csdnimg.cn/20200414161106796.png" alt="syslog日志原始日志转发"><br>在logstash的bin目录下新建配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="built_in">test</span>-pipeline.conf</span><br></pre></td></tr></table></figure><p>编辑input和output</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    stdin&#123;</span><br><span class="line">      type =&gt; <span class="string">"test-log"</span></span><br><span class="line">    &#125;</span><br><span class="line">    syslog&#123;</span><br><span class="line">        type =&gt; <span class="string">"test-log"</span></span><br><span class="line">        port =&gt; <span class="number">514</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output</span><br><span class="line">&#123;</span><br><span class="line">    stdout &#123;</span><br><span class="line">      codec =&gt; rubydebug</span><br><span class="line">    &#125;</span><br><span class="line">    syslog&#123;</span><br><span class="line">        host =&gt; <span class="string">"192.168.2.185"</span></span><br><span class="line">        port =&gt; <span class="number">514</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就相当于把日志转发到了192.168.2.185这台机器的514端口<br>编辑好配置文件以后执行<br><code>./logstash -f test-pipeline.conf --config.test_and_exit</code>     对配置文件进行检查，如果配置文件写得有问题，将会有错误提示。<br>配置文件检查没有问题后就可以启动logstash执行了<code>./logstash -f test-pipeline.conf  --config.reload.automatic</code><br>用udpsender工具往这台机器上发送日志信息，可以看到日志转发到192.168.2.185这台机器上了。<br><img src="https://img-blog.csdnimg.cn/20200414161139252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="updsend发送日志"><br>在控制台可以看到192.168.2.185，接收到了192.168.2.173转发过来的日志<br><img src="https://img-blog.csdnimg.cn/20200414161229147.png" alt="控制台日志"></p><h2 id="2、通过rsyslog、logstash采集nginx等中间件的日志送到ES"><a href="#2、通过rsyslog、logstash采集nginx等中间件的日志送到ES" class="headerlink" title="2、通过rsyslog、logstash采集nginx等中间件的日志送到ES"></a>2、通过rsyslog、logstash采集nginx等中间件的日志送到ES</h2><p>logstash可以与rsyslog、filebeat等无缝结合采集nginx等中间件日志，送给数据存储。<br><img src="https://img-blog.csdnimg.cn/20200414161255484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="通过rsyslog、logstash采集nginx等中间件的日志送到ES"><br>具体参见：<a href="https://xiejava.gitee.io/posts/f3e97829/">https://xiejava.gitee.io/posts/f3e97829/</a></p><h2 id="3、通过logstash将日志入kafka再入mysql或ES"><a href="#3、通过logstash将日志入kafka再入mysql或ES" class="headerlink" title="3、通过logstash将日志入kafka再入mysql或ES"></a>3、通过logstash将日志入kafka再入mysql或ES</h2><p>数据先放到kafka队列里缓存削峰，然后从kafka队列里读取数据到mysql或其他存储系统中进行保存。<img src="https://img-blog.csdnimg.cn/20200414161405732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="logstash将日志入kafka再入mysql或ES"><br>具体参见：<a href="https://xiejava.gitee.io/posts/54e4fd14/">https://xiejava.gitee.io/posts/54e4fd14/</a></p><h2 id="4、通过logstash进行日志补全后再转发或入库"><a href="#4、通过logstash进行日志补全后再转发或入库" class="headerlink" title="4、通过logstash进行日志补全后再转发或入库"></a>4、通过logstash进行日志补全后再转发或入库</h2><p>采集原始日志以后，需要对原始日志进行调整合补齐，比如最常见的是根据IP来补齐IP的经纬度等信息。<br><img src="https://img-blog.csdnimg.cn/2020041416162510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="logstash进行日志补全"><br>这里就可以用logstash的geotip，也可以用其他的外部API接口，为了更具代表性的说明，这里调用的是第三方的http接口（<a href="http://ip-api.com/json/），这个接口也是可以自己定义的。" target="_blank" rel="noopener">http://ip-api.com/json/），这个接口也是可以自己定义的。</a><br>参考配置文件如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    stdin &#123; &#125;</span><br><span class="line">    syslog &#123;</span><br><span class="line">      port =&gt; <span class="string">"514"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    grok&#123;</span><br><span class="line">         <span class="comment">#匹配获取IP</span></span><br><span class="line">         match =&gt; &#123;<span class="string">"message"</span> =&gt; <span class="string">"%&#123;IPV4:ip&#125;"</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    http &#123;</span><br><span class="line">        <span class="comment">#调用外部接口获取IP的详细信息</span></span><br><span class="line">        url =&gt; <span class="string">"http://ip-api.com/json/%&#123;ip&#125;"</span></span><br><span class="line">        verb =&gt; <span class="string">"GET"</span></span><br><span class="line">        add_field =&gt; &#123;</span><br><span class="line">          <span class="string">"new_field"</span> =&gt; <span class="string">"new_static_value"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutate &#123;</span><br><span class="line">        replace =&gt; &#123;     </span><br><span class="line">            <span class="comment">#这里对原始日志数据进行补全，如加了新的字段及从接口中获取的信息</span></span><br><span class="line">            <span class="string">"message"</span> =&gt; <span class="string">"%&#123;message&#125;|%&#123;ip&#125;: My new message|%&#123;new_field&#125;|%&#123;[body][as]&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    stdout &#123; &#125;</span><br><span class="line">    syslog &#123;</span><br><span class="line">        host =&gt; <span class="string">"192.168.2.173"</span></span><br><span class="line">        port =&gt; <span class="string">"7514"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过http接口调用API取得数据，然后通过mutate重新组合补全信息，这里通过调用获取IP地址信息的API获取IP的信息，然后补全到原始日志中。<br><img src="https://img-blog.csdnimg.cn/20200414161738867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>可以看出logstash是一个非常灵活好用的数据采集框架工具，可以通过简单的配置满足绝大多数数据采集场景的需求。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语学渣的我是如何撸完一本英文原著的</title>
      <link href="/posts/1e6a75de/"/>
      <url>/posts/1e6a75de/</url>
      
        <content type="html"><![CDATA[<p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/20200407/blogimage/englishimage.png" alt="英语原著"><br>2020年初立的flag就有要看完十本英文原著。看英文原著对于英语学渣的我来说几乎是很难想像的事情。说英语烂那只有自己知道，读书的时候从来就没有学好过，工作这么多年更是忘得一干二净了。与英语相爱相杀若干年，经历了无数次从开始到放弃……</p><p>非常羡慕别人能够很顺畅的看懂英文原著，能够丢开字幕看懂英语大片，能够飚一口的英文。有人说学好了英文就给自己多开了一扇了解世界的窗户，比别人多一半的人生经历。英语对于生活在全球化信息时代的我们来说有多么的重要，不用多说，道理啥的咱都知道，可是经历了这么多年还是学不会啊。买了N多的英语学习资料，下了N多的视频教程，查找了各种学习英语的方法。单词书永远都是翻了前面几页，英语学习资料屯了一堆从来没有开封过，市面上吹捧的各种英语学习方法感觉都很不错，尝试了很多种还是在尝试……</p><p>虽然有过无数次失败的经历，但也越来越认识到英语的重要性，也看到越来越多的人将英语学得很溜，让我清醒的认识到英语很重要，英语很难学，英语是一定是可以学好的，但是妄想速成是不可能的。如何才能最终习得英语的技能呢？</p><p>前新东方英语老师李笑来在他的《财富自由之路》中指出在智力上、知识上、经验上，复利效应对每个人来说都是存在的。知识和能力的习得与积累是有复利效应的。所以，大多数的人应该要相信自己能够通过知识和能力的积累和复利获得成功和成长。经过多年教训，所有什么打着21天搞定单词，一个月看懂原著啥的口号都是骗人的。在英语技能的习得上，我笃信只有坚持积累和复利才能最终成功。我坚信经过自己的努力和坚持，我在英语习得上投入的精力和时间超过成本线以后，我的英语水平将会有突破性的提高。</p><p>在英语学习的过程中有过<a href="https://xiejava.gitee.io/posts/48451ead/">《坚持了330天，我终于放弃了背单词》</a>的经历，让我认识到只有“用”英语，才能够真正的掌握英语。目前我最朴素的需求就是想能够看懂英文文档，能够流畅的阅读英文书籍。而目前所处的语言环境”说”英语的需求不是很迫切。对于我来说能够流利阅读英语已经足够了。既然开始“用”英语，那就从大量开始阅读英语原版书开始吧！英语这么菜，我为什么敢挑战英文原版书呢？因为我看到了李笑来老师提到掌握一门外语的最少必要知识。<br>1、认识字母<br>2、认识音标<br>3、会查字典<br>4、懂点基本语法<br>5、会用百度或google等搜索引擎。<br>如果掌握了这些最小必要的知识，你就已经“入门”了，接下了就只剩下所谓“执行”了，也就是要用起来。<br>我想，这些最小必要的知识我基本都已经具备了。在正式准备看英语原著之前，我看完了全套149本《书虫》（见<a href="https://xiejava.gitee.io/posts/40bbedc5/">《看完全套149本《书虫》是种什么样的体验》</a>）。对于英语的阅读相对来说没有那么怵了。<br>虽然我看完了全套149本《书虫》，但是《书虫》毕竟只是入门级的英语简写读物，与英语原版的原著还是有很大的距离的。</p><p>作为英语原著初读者来说，真正看完一本书，完成从0到1的过程，比深刻理解一本书更重要。而对于初读者来说如何撸完一本英文原著还是比较有挑战的。</p><p><strong>首先要找到一本自己非常感兴趣并且适合自己难度的书籍。自己不感兴趣或者难度太难了，就会容易放弃。</strong><br>对于挑选原版书的阅读材料来说，我也是花的一些功夫。网上有人建议刚开始接触英语原著建议是比较浅的原著如儿童读物《夏洛的网》、《格林童话》、《小王子》之类的。对于我这种成年人来说这类读物实在是提不起我的兴趣。还有人推荐《哈利波特》系列，我不是哈迷所以也没有选择《哈利波特》系列。我选择的是《奇迹男孩》。《奇迹男孩》的电影在2018年上映的时候我就想看，但是一直没有时间去看。正好买了这本英文原著来看看。《奇迹男孩》英文原著豆瓣评分9.1分，属于儿童成长类的书籍，老少皆宜，300来页长短适中不是那种大部头。因为是面向青少年的书籍所以单词不难，而且是近几年出的新书畅销书，比较口语化没有太多的长句子，非常通俗。事实证明《奇迹男孩》非常适合像我这样的英语原著初读者。<br><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/20200407/blogimage/wonder.png" alt="奇迹男孩"></p><p><strong>选择了阅读目标的原版书籍后，就要开始读并坚持下来</strong><br>作为英语原著初读者，即使是最通俗的原版书，单词也会是一个拦路虎。单词没有办法，那就是勤查字典。《奇迹男孩》是面向青少年的书籍，单词不难，但对我来说也是充斥着各种生词。不过还好每页大概是在6、7个左右。如果按照伍君仪的《把你的词汇用起来》中的透析法，隔一个生词查一个，只查一半的生词，剩下的靠猜，那每页只要查2-3个单词左右，这个查词量已经很小了。因为这本书对我来说生词量6、7个不算多，而且作为原著初读者，猜单词的意思往往猜不准，所以我就索性看到不懂的单词每个都会查字典。为了尽快的撸完这本书，我也是给自己定了个目标，每天看30页。看少了不记得前后的情节，看多了怕自己看不下去。别看只有区区的30页，看中文也就半个小时的事情，但是看英文又要查字典，平均要花掉2-3个小时才能看完。所以对于英语原著初读者来说30页是个比较适中的量，后续如果熟练的可以慢慢的增加。这本《奇迹男孩》300多页，大概花了我一周半的时间。</p><p><strong>对于英语原版书是看电子版的还是纸质版的，建议还是先看纸质版的</strong><br>作为英语原著初读者，我自己认为还是先看纸质版。看电子版的有个好处就是可以随时查字典，尤其是用kindle看，开启生词提示，并且长按生词就会调出字典查词，非常方便。正是因为太方便了，会让我们产生依赖，有时很容易的单词还会忍不住去查一下字典。而且有时候要往回看情节翻起来也不太方便。虽然有进度显示但是没有纸质书那么直观。纸质书看起来更加有感觉，可以前后翻，有时不记得前面的情节了可以方便的随时翻看，每天看了多少页插个书签就是。看着书签慢慢的插到了最后心里还是满满的成就感。</p><p>对于英语原著初读者来说，撸完一本英文原著，完成从0到1的过程。这种小小的成就感，更加坚定了学习英语的信心。相信经过自己的努力和坚持，看完数十本英文原著以后，英语水平将会有突破性的提高。</p><p>学习外语没有其他任何捷径，唯有“结硬寨,打呆仗;日拱一卒,功不唐捐!”</p><p>我读过的英文读本豆列： <a href="https://www.douban.com/doulist/118432400/" target="_blank" rel="noopener">https://www.douban.com/doulist/118432400/</a></p><p>爱分享读书豆瓣小组： <a href="https://www.douban.com/group/655112/" target="_blank" rel="noopener">https://www.douban.com/group/655112/</a></p><hr><center>关注：“爱分享读书”微信公众号 <p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/%E7%88%B1%E5%88%86%E4%BA%AB%E8%AF%BB%E4%B9%A6%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><p>读书我们是认真的</p></center>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>忘掉10000小时，如何快速获得某项技能</title>
      <link href="/posts/10547b72/"/>
      <url>/posts/10547b72/</url>
      
        <content type="html"><![CDATA[<p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/20200328/blogimage/%E4%B8%80%E4%B8%87%E5%B0%8F%E6%97%B6%E5%AE%9A%E5%BE%8B.png" alt="一万小时定律"></p><p>几乎每个人都知道1万小时定律，这个定律被人奉为圭臬。给每个渴望成功的同学们指明了方向，只要在某个领域付出不断的努力，达到10000个小时，就可以成为这方面的专家领袖。</p><p>所谓“一万小时定律”，最早出现于作家格拉德威尔《异类》一书。在书中，格拉德威尔举出了例如比尔盖茨这样的例子，言之凿凿的声称：那些天才和专家之所以卓越非凡，并非他们的天赋超人一等，而是他们付出了持续不断的努力。而任何普通人都可以达到这样的目标，只需要付出10000小时的训练即可。</p><p>这个定律非常符合大家的胃口，也有一定的道理，不怀疑在一个方向上持续不断的努力肯定会有所成功。在智力上、知识上、经验上，复利效应对每个人来说都是存在的。知识和能力的习得与积累是有复利效应的。所以，大多数的人应该要相信自己能够通过知识和能力的积累和复利获得成功和成长。</p><p>但是10000小时不是个很短的时间，如果每天投入2个半小时，那要10年才能成为专家。大多数人不用说坚持10000个小时，坚持100个小时还没有入门，就已经倒下放弃了。而对正常人现实需求来说，一万小时是成为顶尖高手的门槛，可遇而不可求。想要获得比较好的收入，能够做出较好的事情，基本上只需要超过平均水平即可。不必凡事都跟行业内最顶尖的几个人相比，但是能够超过一个行业的平均水平，也足够获取比较好的利润、回报和成绩。</p><p>对于任何一件事情、一个行业领域或者是一个学习任务而言也只有先入门了，取得了比较好的利润、回报和成绩，才会有兴趣持续的做下去，才可能有10000小时精进的努力。所以<strong>忘掉10000小时，先快速的入门达到超过行业平均水准，才能继续后面的牛逼</strong>。</p><p>那么问题来了，如何才能快速的入门呢？<br>李笑来的《财富自由之路》里，指出了两个关键字“<strong>最少必要知识</strong>”、”<strong>用</strong>“<br>当需要进入某个行业、获得某项技能的时候，一定要想办法在最短的时间里弄清楚都有哪些最小必要知识，然后迅速的掌握它们。任何人都可以完成快速入门。例如掌握一门外语的最少必要知识有哪些呢？<br>1、认识字母<br>2、认识音标<br>3、会查字典<br>4、懂点基本语法<br>5、会用百度或google等搜索引擎。<br>如果掌握了这些最小必要的知识，你就已经“入门”了，接下了就只剩下所谓“执行”了，也就是要用起来。通过用起来才能从入门到熟练。然后就要专注于改进了。<br>所以快速学习或快速掌握一门技能进入某个行业。无外乎就是快速的掌握最小必要的知识迅速入门，然后通过不断的用起来，在用的过程中不断的实践。逐步从入门到熟练，熟练后就可以专注创新改进而达到精进。</p><p>道理就是这么个道理，但是为什么有些人学什么东西入门就是比你快呢？<br>就是他已有的<strong>背景知识</strong>掌握得比你广、比你好，比如同样是学机器学习，数学系的大概率的要比计算机系的要入门快，计算机系的大概率的要比文科类专业的入门要快。因为学机器学习需要比较强的数学知识背景，虽然入门同样是要掌握那几种常用的算法，数学系的理解起来要比非数学系统理解起来要快得多。</p><p>所以要想快速进入某个行业、获得某项技能，先弄清楚这个行业都需要哪些最小必要知识，评估一下自己的背景知识的匹配度，迅速补齐掌握最小的必要知识，持续的用，不断的改进。实际上当你进入到某个行业实际上就已经补齐完善了你的背景知识。通过不断的学习，背景知识框架体系会越来越广，那你学东西会越来越快。形成一个正向循环。让你越来越牛逼！</p><hr><center>关注：“爱分享读书”微信公众号 <p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/%E7%88%B1%E5%88%86%E4%BA%AB%E8%AF%BB%E4%B9%A6%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><p>读书我们是认真的</p></center>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《暗时间》读书笔记</title>
      <link href="/posts/431cf122/"/>
      <url>/posts/431cf122/</url>
      
        <content type="html"><![CDATA[<p>刘未鹏说——</p><p><strong>写博客这件事情给我最大的体会就是，一件事情如果你能够坚持做8年，那么不管效率和频率多低，最终总能取得一些很可观的收益。而另一个体会就是，一件事情只要你坚持得足够久，“坚持”就会慢慢变成“习惯”。原本需要费力去驱动的事情便成了家常便饭，云淡风轻。</strong></p><p>这本书便是从刘未鹏8年的博客文章中精选出来的，主要关于心智模式、学习方法和时间利用，《暗时间》的书名便来自于此。</p><p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/20200328/blogimage/%E3%80%8A%E6%9A%97%E6%97%B6%E9%97%B4%E3%80%8B.png" alt="《暗时间》"></p><h1 id="第一章-暗时间"><a href="#第一章-暗时间" class="headerlink" title="第一章 暗时间"></a>第一章 暗时间</h1><p>善于利用思维时间的人，可以无形中比别人多出很多时间，从而实际意义上能比别人多活很多年。<br>学习一门专业应该是投入之间和效率的乘积。<br>你可以“投入”很多时间在一件事情上面，却发现毫无进展，因为你没有整天把你要做的事情，要学习的东西常驻在你的大脑中，时刻给予它最高的优先级。<br>如果你有做总结的习惯，你在度过一段时间之后总结自己在某某领域投入了多少时间，建议千万不要粗略地去计算有多少天下班后拿起书来翻看过，因为这样你也许会发现书倒是常翻，但领悟却不见得多深，表面上花的时间不少，收益却不见得那么大。因为<strong>看书并记住书中的东西只是记忆，并没有涉及推理，只有靠推理才能深入理解一个事物，看到别人看都不到的地方，这部分推理的过程就是你的思维时间，也是人一生中占据一个显著比例的“暗时间”</strong>，你走路、买菜、洗脸洗手、坐公车、逛街、出游、吃饭、睡觉，所有这些时间都可以成为“暗时间”，你可以充分利用这些时间进行思考，反刍和消化平时看和读的东西，让你的认识能够脱离照本宣科的层面。</p><h1 id="第二章-设计你自己的进度条"><a href="#第二章-设计你自己的进度条" class="headerlink" title="第二章 设计你自己的进度条"></a>第二章 设计你自己的进度条</h1><p>如果没有进度提示，我们无法判断这个等待什么时候才是个尽头。如果有不断增长的进度条，那么我们对于什么时候会达到100%就会有一个粗略的估计。做事情也是同样的道理，善于规划的人，会将目标分割成一个个的里程碑，再将里程碑分割成TODO列表。<br>过早退出是一切失败的根源。<br>兴趣遍地都是，专注和持之以恒才是真正稀缺的。<br>靠专业技能的成功是最具可复制性的。它需要的只是你在一个领域坚持不懈地专注下午，只需要选择一个不算太靠谱的方向，然后专心致志的专下去，最后必然能成为高手或绝顶高手。<br>反思是让人得以改进自己的最重要的思维品质。<br>一生的知识积累，自学的起码占90%</p><h1 id="第三章-如何有效地记忆与学习"><a href="#第三章-如何有效地记忆与学习" class="headerlink" title="第三章 如何有效地记忆与学习"></a>第三章 如何有效地记忆与学习</h1><p>你所拥有的知识并不取决于你记得多少，而在于它们能否在恰当的时候被回忆起来。<br> 如何有效的总结知识，学以致用<br>1）养成习惯，经常主动回顾一段时间学到的东西。<br>2）创造回忆的机会<br>  2.1）经常与别人讨论，或者讲给别人听。“教是最好的学”<br>  2.2）整理笔记。<br>  2.3）书写。“书写是更好的思考”<br>3）设身处地的“虚拟经历”别人经历过的事情。<br>4）抽象和推广<br>5）联系/比较自身的经历</p><h1 id="第五章-学习习惯"><a href="#第五章-学习习惯" class="headerlink" title="第五章 学习习惯"></a>第五章 学习习惯</h1><h2 id="一、学习与思考"><a href="#一、学习与思考" class="headerlink" title="一、学习与思考"></a>一、学习与思考</h2><p>1、Google&amp;Wiki 遇到问题先上网搜索，自己找答案。<br>2、看书只看经典。<br>3、做读书笔记。便于回顾、加深理解<br>     a.将自己阅读时候的思考总结下来。<br>     b.将书中的好例子摘抄下来。<br>4、无时不可不思考。思考可以避免焦虑。<br>5、要事优先<br>6、重要的事情营造比较大的时间块来完成。<br>7、多看心理学与思维的书。<br>8、学习一项知识三问（a.它的本质是什么。b.它的第一原则是什么。c.它的知识结构是怎样的）<br>9、获得的多少并不取决于读了多少，而取决于思考了多少，多深。<br>10、善于利用小块时间。<br>11、养成好习惯。</p><h2 id="二、时间管理"><a href="#二、时间管理" class="headerlink" title="二、时间管理"></a>二、时间管理</h2><p>1、学习和思考过程中常问自己几个问题<br>    a.你的问题到底是什么？（提醒自己思考不要偏离问题）<br>    b.到现在为止，我到底有了什么收获呢？（提醒自己时不时去总结，整理学习的东西）<br>    c.设想自己正在将东西讲给别人听。<br>    d.时常反省和注意自己的思维过程。（将思维的大致脉络写下来是个很好的习惯）<br>    e.养成反驳自己的想法的习惯。<br>    f.人的思维天生就是极易流于表面来理解事物的。觉得自己理解了一个问题了吗？条件反射的问自己：你真的理解了吗？你真的理解了问题的本质吗？问题的本质到底是什么？目前我的理解是什么？我对这个理解感到满意吗？这样的理解到底有什么建设性呢？等等。<br>2、重视知识的本质<br>3、重视积累的强大力量，万事提前准备。<br>4、抬起头来：时不时抬起头来审视一下自己正在做的事情，自问一下有什么价值，是不是你真正希望做的。它们重要吗？你需要在这个时候学这些吗？你的时间就是你的资源，你投入这些资源来掌握知识，所以到底用来掌握哪些知识是一个很重要的问题。</p><h2 id="三-知识结构"><a href="#三-知识结构" class="headerlink" title="三 知识结构"></a>三 知识结构</h2><p>抓住不变量<br>知识分为essential(必要)和non-essential（非必要）的。对于前者提前深入掌握牢靠，对于后者采取待用到的时刻RTM(Read the manual)方法。</p><h1 id="第八章-书写是为了更好的思考"><a href="#第八章-书写是为了更好的思考" class="headerlink" title="第八章 书写是为了更好的思考"></a>第八章 书写是为了更好的思考</h1><p>1、书写是对思维的备忘<br>2、书写是对思维的缓存<br>3、书写是与自己的对话<br>4、书写是与别人的交流<br>如果你着自己将一些不成熟的想法写下来，看着自己写的内容，试着进一步拓展它们，就有可能在理性的道路上走得很远，很远。</p><h1 id="第九章-为什么你从现在开始就应该写博客"><a href="#第九章-为什么你从现在开始就应该写博客" class="headerlink" title="第九章 为什么你从现在开始就应该写博客"></a>第九章 为什么你从现在开始就应该写博客</h1><p>用博客的形式来记录下你有价值的思考，会带来很多好处，却没有任何明显的坏处。<br>价值博客的几点好处<br>1、能交到很多志同道合的朋友。<br>2、书写是为了更好的思考<br>3、教是最好的学<br>4、讨论是绝佳的反思<br>5、激励你去持续学习和思考<br>6、学会持之以恒地做一件事情。<br>7、一个长期的价值博客是一份很好的简历。</p><h1 id="第十二章-什么才是你的不可替代性-amp-核心竞争力"><a href="#第十二章-什么才是你的不可替代性-amp-核心竞争力" class="headerlink" title="第十二章 什么才是你的不可替代性&amp;核心竞争力"></a>第十二章 什么才是你的不可替代性&amp;核心竞争力</h1><p>1、专业领域技能：成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。<br>2、跨领域的技能：解决问题的能力，创新思维，判断与决策能力，批判性思维能力，表达沟通能力等等。<br>3、学习能力：持续学习和思考<br>4、性格要素：专注、持之以恒、自信、自省、好奇心。等等。</p><hr><center>关注：“爱分享读书”微信公众号 <p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/%E7%88%B1%E5%88%86%E4%BA%AB%E8%AF%BB%E4%B9%A6%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><p>读书我们是认真的</p></center>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你所谓的财富自由是什么？</title>
      <link href="/posts/e3431c21/"/>
      <url>/posts/e3431c21/</url>
      
        <content type="html"><![CDATA[<p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/20200327/blogimage/%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1.jpg" alt="财富自由"></p><p>实现财富自由是现如今大部分人的理想。不管是加班工作赚钱也好，搞刚需副业也好，还是创业做投资也好都是为了一个目的实现财富自由。有些人早早的就已经实现了财富自由，有些人一辈子也没有实现财富自由，更多的人则是在追求财富自由的路上。</p><p>看过《穷爸爸富爸爸》的人都知道财富自由是指你无须为生活开销而努力为钱工作的状态。简单地说，你的资产生的被动收入必须至少等于或超过你的日常开资–这是我们大多数人向往的状态。这个定义非常清晰，大多数的人都认同这种说法。但是对我来说感触最深的还是李笑来老师在他的《财富自由之路》里面的定义：<strong>“个人财富自由，是指某个人再也不用为了满足生活必须而出售自己的时间了”</strong>。这是多么深刻的认识啊，你加班工作也好，副业也好不都是在出售自己的时间获得财富吗？即使是创业做投资本质上也是在出售自己的时间，是在购买别人的时间再出售出去，只是有可能这样出售自己时间的效率更高而已。</p><p>李笑来老师在对时间的理解、对心智的认识，对学习的认识、对成长的认识，我觉得都非常的深刻。有人说他的书是鸡汤，但是他总是可以用非常浅显深刻的道理让你心甘情愿的干了这碗鸡汤还回味无穷。他的《财富自由之路》就是这么一本书。</p><p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/20200327/blogimage/%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF.png" alt="《财富自由之路》"></p><p>我们要的自由，其本质不是财富，财富只是工具：我们要的自由，本质上是时间的自主权。所以个人财富自由，是指某个人再也不用为了满足生活必须而出售自己的时间了。</p><p>如何才能让自己财富自由呢？一个世人皆知的道理就是积累和复利。</p><p>爱因斯坦曾经说过：复利是“世界第八大奇迹”。知之者赚，不知之者被赚。但是复利并不是凭空来的，你得现有成本的积累，积累越大复利的效果随着时间的推移效果会越来越显著。</p><p>对于资产投资者来说，如果你的投资收益如果是正的话，你不断的积累复投，若干年后你的财富增长将相当的可观。如果天生有个好爹可以继承财富，那么你起点就比别人高，可以通过财富的复利实现自由。但是大多数人没有爹可以拼，没有大笔财富可以继承。不过万幸并且公平的是，在智力上、知识上、经验上，复利效应对每个人来说都是存在的。知识和能力的习得与积累是有复利效应的。所以，大多数的人应该要相信自己能够通过知识和能力的积累和复利获得成功和成长。</p><p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/20200327/blogimage/%E5%A4%8D%E5%88%A9%E6%9B%B2%E7%BA%BF.png" alt="复利曲线"> </p><p>一切有意义的成长过程都符合那个“复利曲线”。起初看来斜率突然发生变化的“点”，叫做“拐点”。如果作为一个投资者，你的投资是正利率，那么你的资产变化情况也符合这个有拐点、突破了成本线的、后端急速上扬的“复利曲线”。</p><p>如果没有资产可以继承，那就持续积累知识和能力吧。这是大多数人可以成功实现财富自由并且一定能成功的可靠路径。关注成长，而不是成功，因为当你的成长线终于穿越成本线时，你事实上已经成功了，可那肯定不是终点。因为如果你不成长了，有可能这个成长线还会往下掉，将你的成功的成果吞噬。</p><p>既然”复利曲线”那么有效，那为什么还有那么多人在成本线下苦苦挣扎，没有碰到所谓的拐点，更不用说什么财富自由了。这里要注意几个被容易忽视的东西，那就是“<strong>投入方向</strong>”、“<strong>沉没成本</strong>”、“<strong>利润</strong>”，“<strong>贬值</strong>”。</p><ul><li>投入方向</li></ul><p>如果方向有问题，那么你的努力就是南辕北辙，越努力离成功距离越远，那就谈不上什么积累和复利了。比如现在一个行业已经日落西山了要消亡，你还在这个行业傻傻的坚持努力。基本上是不可能成功的。</p><ul><li>沉没成本</li></ul><p>当你选择了一个正确的方向，经过了一段时间的努力，取得了一点小小的成绩，但是你停止了放弃了。在积累和复利之前就投降放弃了，以前的努力付出就成了沉没成本。</p><p>一个切身体会的例子，就是学英语。比如我通过一段时间的努力，看完了149本书虫，但是最近我放松了自己没有看英语了。如果还经过一段时间不坚持不努力，那我以前积累的这些单词什么的又会忘了。以前的努力将会白费了变成了“沉没成本”。</p><p>今天搞搞这个、明天搞搞那个，很多的努力就变成了沉没成本。回头一看，啥都没有积累更谈不上有复利了。所以如果要实现“复利曲线”。坚持和积累非常重要。</p><ul><li>利润</li></ul><p>复利复利，没有利润怎么能复利呢。利润高的复利效果更加明显，这个道理傻瓜都知道。所以说坚持做一件事情要考虑利润，也就是投入产出比。</p><p>比如花大量的时间放在看肥皂剧、刷社交软件上，这些事情不能让你成长或让你的能力提升有限，那对你能力成长产生复利的效果当然有限啊。</p><ul><li>贬值</li></ul><p>作为资本投资来说要考虑货币贬值，作为知识和能力的习得者来说要考虑知识的贬值。大家都知道计算机技术发展速度迅速，很多技术很快随着科技发展迅速的淘汰贬值。比如以前的CGI 、ASP、VB 等开发语言和技术现在都很少用了。那以前花精力学的这些知识都大幅度贬值了。当然有些知识和技能的贬值速度慢一些，比如通识知识、英语、驾驶、写作等。你赚钱的速度要大于你花钱的速度，你的资本才会有所以积累，有积累才有复利的可能。所以你的学习新知识的速度应该要大于知识贬值速度，你的知识和能力才会有积累和复利的可能。</p><p>用正确的方式做正确的事情，你一定会变得更好！</p><p>若长期持续用正确的方法做正确的事情，你的未来一定会很伟大！</p><hr><center>关注：“爱分享读书”微信公众号 <p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/%E7%88%B1%E5%88%86%E4%BA%AB%E8%AF%BB%E4%B9%A6%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><p>读书我们是认真的</p></center>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>syslog日志接口调试方法</title>
      <link href="/posts/7bbe2925/"/>
      <url>/posts/7bbe2925/</url>
      
        <content type="html"><![CDATA[<p>日志数据采集，比较方便常用的就是通过syslog来进行数据采集，syslog可以通过udp协议来进行高效的数据传输。一般来说在工程实施的过程中需要对接对端系统的数据采集源可以通过以下步骤来进行syslog日志接口的调试。主要是验证syslog日志是否能正常送到指定的日志服务器的指定端口，日志服务器的指定端口是否能正常收到对端发过来的日志。</p><h1 id="1、检查双方网络是否通畅"><a href="#1、检查双方网络是否通畅" class="headerlink" title="1、检查双方网络是否通畅"></a>1、检查双方网络是否通畅</h1><p>网络通畅是所有网络连接的前提条件，可以先通过ping的方式，先确认一下对端数据源是不是可以ping通这边的日志接收服务器地址，看网络是否是通的。<br>一般来说只到对端能够ping通日志服务器地址就可以了，单向ping通就OK。<br>如果ping不通，那就要检查日志服务器的网络设置，如是否开启了防火墙，禁ping了。根据网络实际情况调整网络策略，确保网络是通的。</p><h1 id="2、检查端口是否通畅"><a href="#2、检查端口是否通畅" class="headerlink" title="2、检查端口是否通畅"></a>2、检查端口是否通畅</h1><p>通过数据源服务器telnet一下日志服务器地址和端口，看端口是不是通的。<br>有很多服务器上可能没有装telnet，也可以用ssh ip 端口  来验证一下。</p><h1 id="3、发送简单的报文测试"><a href="#3、发送简单的报文测试" class="headerlink" title="3、发送简单的报文测试"></a>3、发送简单的报文测试</h1><p>在对端通过发送udp报文来进行简单的测试<br>如日志接收服务器地址是172.28.65.32，端口514 则可以通过<code>echo “hello” &gt; /dev/udp/172.28.65.32/514</code> 来发送测试报文<br>在日志接收服务器用tcpdump收下有没有监听到报文过来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump udp port 514 -A -i any</span><br></pre></td></tr></table></figure><p>如果有就会有相应的显示<br><img src="https://img-blog.csdnimg.cn/20200318100042259.png" alt="tcpdump"></p><h1 id="4、进行正式接口对接"><a href="#4、进行正式接口对接" class="headerlink" title="4、进行正式接口对接"></a>4、进行正式接口对接</h1><p>如果tcpdump可以收到日志，那就说明syslog的通信是没有问题的，接下来就可以进行具体的syslog的配置的调测了。</p><hr><p>作者博客:<a href="http://xiejava.gitee.io">http://xiejava.gitee.io</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> syslog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logstash集成kafka，mysql实现数据采集</title>
      <link href="/posts/54e4fd14/"/>
      <url>/posts/54e4fd14/</url>
      
        <content type="html"><![CDATA[<p>logstash是一个非常灵活好用的数据采集框架工具，可以通过简单的配置满足绝大多数数据采集场景的需求。<br>采集数据一个非常典型的场景就是将数据先放到kafka队列里削峰，然后从kafka队列里读取数据到mysql或其他存储系统中进行保存。<br><img src="https://img-blog.csdnimg.cn/20200316171007439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="从syslog采集日志到kafka然后在从kafka写到mysql数据库中"><br>本文通过一个简单的示例来演示从syslog采集日志到kafka然后在从kafka写到mysql数据库中。<br>默认已经安装好了kafka、mysql、logstash，并已经经过简单的验证。</p><h1 id="准备logstash的环境"><a href="#准备logstash的环境" class="headerlink" title="准备logstash的环境"></a>准备logstash的环境</h1><h2 id="一、下载mysql的jdbc驱动包"><a href="#一、下载mysql的jdbc驱动包" class="headerlink" title="一、下载mysql的jdbc驱动包"></a>一、下载mysql的jdbc驱动包</h2><p>下载地址：<a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java/8.0.15" target="_blank" rel="noopener">https://mvnrepository.com/artifact/mysql/mysql-connector-java/8.0.15</a><br>下载后放到logstash的安装目录的/vendor/jar/目录下</p><h2 id="二、安装logstash插件"><a href="#二、安装logstash插件" class="headerlink" title="二、安装logstash插件"></a>二、安装logstash插件</h2><p>logstash默认安装了kafka插件，但是mysql插件没有默认安装需要自己安装。<br>具体安装方法 /bin/logstash-plugin install logstash-output-jdbc ，这里应为要用到logstash写入mysql数据库，所以安装的插件是logstash-output-jdbc，如果要用到从mysql读数据，那么就要安装logstash-input-jdbc。安装方法类似。<br>因为安装时需要访问国外的源，安装进度很慢很慢，还经常安装不成功，所以需要更改国内的源。<br>也就是给 Ruby 换成国内的镜像站：<a href="https://gems.ruby-china.com/，替代https://rubygems.org。*请注意：国内的镜像站从https://gems.ruby-china.org" target="_blank" rel="noopener">https://gems.ruby-china.com/，替代https://rubygems.org。*请注意：国内的镜像站从https://gems.ruby-china.org</a> 换成了 <a href="https://gems.ruby-china.com" target="_blank" rel="noopener">https://gems.ruby-china.com</a> ！！！* 现在很多网上的资料就都是写的<a href="https://gems.ruby-china.org，导致很多人换了镜像源也装不上。" target="_blank" rel="noopener">https://gems.ruby-china.org，导致很多人换了镜像源也装不上。</a><br>具体方法如下：</p><h3 id="1-安装Gem并更新"><a href="#1-安装Gem并更新" class="headerlink" title="1. 安装Gem并更新"></a>1. 安装Gem并更新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install -y gem</span></span><br><span class="line"><span class="comment"># gem -v</span></span><br><span class="line">2.0.14.1</span><br><span class="line"><span class="comment"># gem update --system</span></span><br><span class="line"><span class="comment"># gem -v</span></span><br><span class="line">2.7.7</span><br></pre></td></tr></table></figure><h3 id="2-检查并修改镜像源"><a href="#2-检查并修改镜像源" class="headerlink" title="2. 检查并修改镜像源"></a>2. 检查并修改镜像源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gem sources -l</span></span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"> </span><br><span class="line">https://rubygems.org/</span><br><span class="line"></span><br><span class="line"><span class="comment"># gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span></span><br><span class="line">https://gems.ruby-china.org/ added to sources</span><br><span class="line">https://rubygems.org/ removed from sources</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat ~/.gemrc </span></span><br><span class="line">---</span><br><span class="line">:backtrace: <span class="literal">false</span></span><br><span class="line">:bulk_threshold: 1000</span><br><span class="line">:sources:</span><br><span class="line">- https://gems.ruby-china.org/</span><br><span class="line">:update_sources: <span class="literal">true</span></span><br><span class="line">:verbose: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><em>请注意：国内的镜像站从<a href="https://gems.ruby-china.org" target="_blank" rel="noopener">https://gems.ruby-china.org</a> 换成了 <a href="https://gems.ruby-china.com" target="_blank" rel="noopener">https://gems.ruby-china.com</a> ！！！现在很多网上的资料就都是写的<a href="https://gems.ruby-china.org，导致很多人换了镜像源也装不上。" target="_blank" rel="noopener">https://gems.ruby-china.org，导致很多人换了镜像源也装不上。</a></em></p><h3 id="3-修改-logstash的-gem-镜像源"><a href="#3-修改-logstash的-gem-镜像源" class="headerlink" title="3. 修改 logstash的 gem 镜像源"></a>3. 修改 logstash的 gem 镜像源</h3><p>cd到logstach的安装目录，可以看到Gemfile文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vi Gemfile</span></span><br><span class="line"><span class="comment"># This is a Logstash generated Gemfile.</span></span><br><span class="line"><span class="comment"># If you modify this file manually all comments and formatting will be lost.</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">source</span> <span class="string">"https://rubygems.org"</span></span><br><span class="line">gem <span class="string">"logstash-core"</span>, :path =&gt; <span class="string">"./logstash-core"</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>更改默认的 <a href="https://rubygems.org" target="_blank" rel="noopener">https://rubygems.org</a> 为<a href="https://gems.ruby-china.com" target="_blank" rel="noopener">https://gems.ruby-china.com</a><br><img src="https://img-blog.csdnimg.cn/20200316171241910.png" alt="更换国内镜像源地址"></p><h3 id="4-安装-logstash-output-jdbc"><a href="#4-安装-logstash-output-jdbc" class="headerlink" title="4. 安装 logstash-output-jdbc"></a>4. 安装 logstash-output-jdbc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/bin/logstash-plugin install logstash-output-jdbc</span></span><br><span class="line">Validating logstash-output-jdbc</span><br><span class="line">Installing logstash-output-jdbc</span><br><span class="line">Installation successful</span><br></pre></td></tr></table></figure><h3 id="5-查看插件是否安装成功"><a href="#5-查看插件是否安装成功" class="headerlink" title="5.查看插件是否安装成功"></a>5.查看插件是否安装成功</h3><p>在logstash的bin目录下执行./logstash-plugin list 可以查看已经安装的插件，可以看到logstash-output-jdbc的插件已经装好。<br><img src="https://img-blog.csdnimg.cn/20200316171324491.png" alt="检查插件安装"></p><h1 id="配置logstash"><a href="#配置logstash" class="headerlink" title="配置logstash"></a>配置logstash</h1><p>新建一个pipline.conf的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="built_in">test</span>-pipeline.conf</span><br></pre></td></tr></table></figure><p>文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    stdin&#123;            #用于测试标准控制台输入的数据</span><br><span class="line">      type =&gt; <span class="string">"test-log"</span></span><br><span class="line">    &#125;</span><br><span class="line">    syslog&#123;           #用于接收来自syslog的日志</span><br><span class="line">        type =&gt; <span class="string">"test-log"</span></span><br><span class="line">        port =&gt; <span class="number">514</span></span><br><span class="line">    &#125;</span><br><span class="line">    kafka &#123;</span><br><span class="line">       bootstrap_servers =&gt; "172.28.65.26:9092" #kafka服务器地址</span><br><span class="line">       topics =&gt; "test1"           #kafka订阅的topic主题</span><br><span class="line">       codec =&gt; "json" #写入的时候使用json编码，因为logstash收集后会转换成json格式</span><br><span class="line">       consumer_threads =&gt; <span class="number">1</span></span><br><span class="line">       decorate_events =&gt; <span class="literal">true</span></span><br><span class="line">       add_field =&gt; &#123;</span><br><span class="line">             <span class="string">"logsource"</span> =&gt; <span class="string">"kafkalog"</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([type]==<span class="string">"test-log"</span> and <span class="string">"kafkalog"</span> not <span class="keyword">in</span> [logsource]) &#123;</span><br><span class="line">       kafka &#123;</span><br><span class="line">            codec =&gt; json</span><br><span class="line">            topic_id =&gt; <span class="string">"test1"</span></span><br><span class="line">            bootstrap_servers =&gt; <span class="string">"172.28.65.26:9092"</span></span><br><span class="line">            batch_size =&gt; <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([type] == <span class="string">"test-log"</span> and <span class="string">"kafkalog"</span> <span class="keyword">in</span> [logsource]) &#123;</span><br><span class="line">        jdbc &#123;</span><br><span class="line">            driver_jar_path =&gt; <span class="string">"/opt/elk/logstash-7.6.0/vendor/jar/jdbc/mysql-connector-java-8.0.15.jar"</span></span><br><span class="line">            driver_class =&gt; <span class="string">"com.mysql.jdbc.Driver"</span></span><br><span class="line">            connection_string =&gt; <span class="string">"jdbc:mysql://172.28.65.32:3306/testdb?user=yourdbuser&amp;password=yourpassword"</span></span><br><span class="line">            statement =&gt; [ <span class="string">"INSERT INTO test_nginx_log (message) VALUES(?)"</span>, <span class="string">"message"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stdout &#123;</span><br><span class="line">       codec =&gt; rubydebug</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个逻辑就是从stdin或syslog接收数据output到kafka,然后从kafka中取出数据加入了一个logsource的字标识是从kafka过来的数据，然后又output到 jdbc写到mysql中去。<br>如果没有这几个if的逻辑判断，那么就会是个死循环。从kafka读同样的数据又写到kafka中。如果在两台机器上装有logstash一台取数据放到kafka,一台从kafka中取数据放到mysql中就可以不用加这样的判断逻辑会单纯简单一些。</p><h1 id="执行logstash并查看效果"><a href="#执行logstash并查看效果" class="headerlink" title="执行logstash并查看效果"></a>执行logstash并查看效果</h1><p>通过在logstash安装目录下执行 bin/logstash -f test-pipeline.conf –config.test_and_exit 检查配置文件是否有问题，没有问题以后执行bin/logstash -f test-pipeline.conf –config.reload.automatic 运行logstash。<br>在控制台输入 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is a <span class="built_in">test</span>!</span><br></pre></td></tr></table></figure><p><strong>效果：</strong><br>从控制台输入信息，可以看到从stdin输入output到stdout的没有logsource标识，input从kafka订阅过来的信息加了一个logsource=&gt;kafkalog的标识。<br><img src="https://img-blog.csdnimg.cn/20200316171423390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="logsource=&gt;kafkalog的标识"><br>用kafka tool工具看到kafka收到了从stdin发过来的信息。<br><img src="https://img-blog.csdnimg.cn/20200316171453670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="用kafka tool工具看到kafka收到了从stdin发过来的信息"><br>在看MySQL表里的数据，已经通过logstash从kafka中将数据采集到了MySQL的表中。<br><img src="https://img-blog.csdnimg.cn/20200316171523708.png" alt="MySQL的表的信息数据"><br>再来看从syslog采集日志的效果<br>从控制台看到的信息效果<br><img src="https://img-blog.csdnimg.cn/20200316171552633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="控制台看到的信息效果"><br>从kafka tool看到的效果<br><img src="https://img-blog.csdnimg.cn/20200316171613337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="kafka tool看到的效果"><br>从mysql 表中看到的效果。<br><img src="https://img-blog.csdnimg.cn/20200316171630325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="mysql 表中看到的效果"><br><strong>可以看到，logstash是一个非常灵活好用的数据采集框架工具，可以通过简单的配置就能满足绝大多数数据采集场景的需求。</strong></p><hr><p>作者博客:<a href="http://xiejava.gitee.io">http://xiejava.gitee.io</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Hexo博客模板hexo-theme-next的翻页按钮不正常显示问题</title>
      <link href="/posts/272f3054/"/>
      <url>/posts/272f3054/</url>
      
        <content type="html"><![CDATA[<p>用Hexo搭了个Gitpage的博客，兴冲冲的发了11篇博文后发现翻页按钮不正常显示，显示为<code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>的HTML编码。如下图：<br><img src="https://img-blog.csdnimg.cn/20200310154450109.png" alt="HTML编码"><br><code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>这是个什么鬼？<br>这是一个Font Awesome的字体图标，按道理来说这个图标应该可以正常显示的，现在这个图标不能显示了显示成了html源码。<br><img src="https://img-blog.csdnimg.cn/20200310154516827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="Font Awesone图标"><br><strong>解决办法:</strong><br>最简单的办法就是将<code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>这个不能正常显示的字体图标改成一般的字符，我这里就是改成正常的一般左右键字符“&gt;”，“&lt;”。<br>在 themes\hexo-theme-next\layout_partials 下找到hexo-theme-next的翻页组件，就是pagination.swig<br>将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.prev or page.next %&#125;</span><br><span class="line">  &lt;nav class&#x3D;&quot;pagination&quot;&gt;</span><br><span class="line">    &#123;&#123;</span><br><span class="line">      paginator(&#123;</span><br><span class="line">        prev_text: &#39;&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;&#39;,</span><br><span class="line">        next_text: &#39;&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;&#39;,</span><br><span class="line">        mid_size: 1</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &lt;&#x2F;nav&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.prev or page.next %&#125;</span><br><span class="line">  &lt;nav class&#x3D;&quot;pagination&quot;&gt;</span><br><span class="line">    &#123;&#123;</span><br><span class="line">      paginator(&#123;</span><br><span class="line">        prev_text: &#39;&lt;&#39;,</span><br><span class="line">        next_text: &#39;&gt;&#39;,</span><br><span class="line">        mid_size: 1</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &lt;&#x2F;nav&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>重新发布以后可以看到翻页按钮可以正常显示了<br><img src="https://img-blog.csdnimg.cn/20200310154621131.png" alt="正常显示箭头"></p><hr><p>作者博客:<a href="http://xiejava.gitee.io">http://xiejava.gitee.io</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过filebeat、logstash、rsyslog采集nginx日志的几种方式</title>
      <link href="/posts/f3e97829/"/>
      <url>/posts/f3e97829/</url>
      
        <content type="html"><![CDATA[<p>由于nginx功能强大，性能突出，越来越多的web应用采用nginx作为http和反向代理的web服务器。而nginx的访问日志不管是做用户行为分析还是安全分析都是非常重要的数据源之一。如何有效便捷的采集nginx的日志进行有效的分析成为大家关注的问题。本文通过几个实例来介绍如何通过filebeat、logstash、rsyslog采集nginx的访问日志和错误日志。</p><p>大家都知道ELK技术栈是采集、分析日志的利器。所以这里介绍的是从nginx采集日志到ES。当然至于日志采集以后存到看大家的需要。通过logstash可以方便的配置日志输出存储的方式。</p><p>一般来说nginx默认安装后，日志文件在 /usr/local/nginx/logs 目录下。分别有 access.log和error.log 访问日志和错误日志。<br>这次示例Elasitcsearch是三个节点组成的集群172.28.65.22、172.28.65.23、172.28.65.24，172.28.65.30 是kibana的地址，172.28.65.32是数据采集服务器，上面装有logstash、nginx、 filebeat。一般来说采集服务器上有logstash，而nginx、 filebeat应该是装在采集目标上。</p><h2 id="一、直接通过filebeat采集日志到ES"><a href="#一、直接通过filebeat采集日志到ES" class="headerlink" title="一、直接通过filebeat采集日志到ES"></a>一、直接通过filebeat采集日志到ES</h2><p><img src="https://img-blog.csdnimg.cn/20200309222757224.png" alt="filebeat到ES"><br>在filebeat的安装目录找到filebeat.yml 配置获取日志文件的路径及输出到ES的配置。<br> 具体：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- type: log</span><br><span class="line">  <span class="comment"># Change to true to enable this input configuration.</span></span><br><span class="line">  enabled: true</span><br><span class="line">  <span class="comment"># Paths that should be crawled and fetched. Glob based paths.</span></span><br><span class="line">  paths:</span><br><span class="line">    <span class="comment">#- /var/log/*.log</span></span><br><span class="line">    - /usr/local/nginx/logs/*.log</span><br><span class="line">    <span class="comment">#- c:\programdata\elasticsearch\logs\*</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309222853340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="filebeat.yml配置"><br>如果需要在kibana中友好显示的化，可进行kibana配置<br><img src="https://img-blog.csdnimg.cn/20200309222955878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="kibana配置"><br>输出到es中，在hosts中配置好你的ES服务地址。如果单机只有一个节点，就可以只配一个ip和端口。<br><img src="https://img-blog.csdnimg.cn/20200309223104639.png" alt="filebeat.yml配置中配置es"><br>启动filebeat 进行日志数据采集</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filebeat <span class="literal">-e</span> <span class="literal">-c</span> filebeat.yml <span class="literal">-d</span> <span class="string">"publish"</span></span><br></pre></td></tr></table></figure><p>通过elasticsearch-head插件查看es索引中的日志信息<br><img src="https://img-blog.csdnimg.cn/20200309223159337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="elasticsearch-head插件查看es索引"><br>可以看到nginx中的access.log和error.log的日志都已经上来了。<br>在kibana中通过filebeat-*过滤看filebeat的索引，可以看到通过filebeat采过来的数据。</p><p><img src="https://img-blog.csdnimg.cn/20200309223308928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="kibana中通过filebeat-*过滤看filebeat的索引"><br>这种直接通过filebeat直接对接ES采日志的方式简单直接，但是无法对采集的日志进行预处理和其他一些操作，也不够灵活。<br>可以在filebeat 和 ES之间加一层Logstash，可以将filebeat于ES解耦，通过Logstash可以做一些预处理，也可以通过Logstash采集到除ES以外的其他数据存储上。</p><h2 id="二、通过filebeat采集日志到logstash再送到ES"><a href="#二、通过filebeat采集日志到logstash再送到ES" class="headerlink" title="二、通过filebeat采集日志到logstash再送到ES"></a>二、通过filebeat采集日志到logstash再送到ES</h2><p><img src="https://img-blog.csdnimg.cn/20200309223343261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="通过filebeat采集日志到logstash再送到ES"><br>首先得安装 logstash ，安装完后在logstash的安装目录下新建vi filebeat-pipeline.conf<br>filebeat-pipeline.conf的具体配置如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    beats &#123;</span><br><span class="line">        port =&gt; <span class="string">"5044"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123; hosts =&gt; [<span class="string">"172.28.65.24:9200"</span>] &#125;</span><br><span class="line">    stdout &#123; codec =&gt; rubydebug&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input配置表示通过5044端口接收beats的数据<br>output配置表示输出到elasticsearch，并且同时输出到标准输出也就是控制台。<br>然后通过命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash <span class="operator">-f</span> filebeat<span class="literal">-pipeline</span>.conf -<span class="literal">-config</span>.reload.automatic</span><br></pre></td></tr></table></figure><p>应用filebeat-pipeline.conf启动logstash。<br><img src="https://img-blog.csdnimg.cn/20200309223435991.png" alt="应用filebeat-pipeline.conf启动logstash"><br>启动以后可以看到logstash的启动日志5044端口的服务已经起了，可以接受通过filebeat通过5044端口传过来的数据了。<br>接下来配置filebeat<br>在filebeat的安装目录找到filebeat.yml 配置获取日志文件的路径及输出到logstash的配置。不直接输出到ES了。<br>具体配置如下：<br>将output.elasticsearch的配置屏蔽<br>配置output.logstash，配置正确的logstash的服务主机和端口<br><img src="https://img-blog.csdnimg.cn/20200309223511426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="配置output.logstash"><br>启动filebeat 进行日志数据采集</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filebeat <span class="literal">-e</span> <span class="literal">-c</span> filebeat.yml <span class="literal">-d</span> <span class="string">"publish"</span></span><br></pre></td></tr></table></figure><p>我们访问nginx服务提供的web服务<a href="http://172.28.65.32/" target="_blank" rel="noopener">http://172.28.65.32/</a><br>在logstash的控制台 可以看到相应的访问access.log 日志<br><img src="https://img-blog.csdnimg.cn/20200309223557623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="logstash的控制台 可以看到相应的访问access.log 日志"><br>同时在ES 中也可以看到有相应的日志数据<br><img src="https://img-blog.csdnimg.cn/20200309223625788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="在ES 中也可以看到有相应的日志数据"></p><h2 id="三、直接通过rsyslog采集日志到logstash在送到ES"><a href="#三、直接通过rsyslog采集日志到logstash在送到ES" class="headerlink" title="三、直接通过rsyslog采集日志到logstash在送到ES"></a>三、直接通过rsyslog采集日志到logstash在送到ES</h2><p>在很多情况下你需要采集的web服务器并不是自己能够控制的，不是说你想装filebeat就可以让你装的，这时候就可以要求目标数据源通过 syslog  的方式将日志发出来。我们可以再通过 logstash送到ES或其他的日志存储处理平台。<br><img src="https://img-blog.csdnimg.cn/2020030922365724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="直接通过rsyslog采集日志到logstash在送到ES"><br>通过syslog往日志服务器上发nginx的日志有两种方式，一种就是利用nginx的配置往外发日志，一种就是通过配置linux的rsyslog的配置往外发日志。</p><h3 id="通过nginx配置发送syslog到logstash"><a href="#通过nginx配置发送syslog到logstash" class="headerlink" title="通过nginx配置发送syslog到logstash"></a>通过nginx配置发送syslog到logstash</h3><p>参考见nginx官方文档：<a href="http://nginx.org/en/docs/syslog.html" target="_blank" rel="noopener">http://nginx.org/en/docs/syslog.html</a><br>具体配置如下：<br>在nginx的配置文件nginx.conf中<br>在server下配置access_log和error_log的输出方式</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">access_log syslog:server=<span class="number">172.28</span>.<span class="number">65.32</span>:<span class="number">514</span>,facility=local7,tag=nginx_access_log,severity=info;</span><br><span class="line">error_log syslog:server=<span class="number">172.28</span>.<span class="number">65.32</span>:<span class="number">514</span>,facility=local7,tag=nginx_error_log,severity=info;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020030922391711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="nginx.conf配置"><br>配置完成后执行 <code>./nginx -s reload</code> 使配置生效。这样就通过linux的rsyslog服务将nginx的日志往外发了。<br>接着来配置logstash的syslog的服务接收配置 。在logstash的安装目录下新建<code>vi syslog-pipeline.conf</code><br>syslog-pipeline.conf的具体配置如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    syslog&#123;</span><br><span class="line">        type =&gt; <span class="string">"system-syslog"</span></span><br><span class="line">        port =&gt; <span class="number">514</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [<span class="string">"172.28.65.24:9200"</span>]</span><br><span class="line">        index =&gt; <span class="string">"system-syslog-%&#123;+YYYY.MM&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">    stdout &#123; codec =&gt; rubydebug&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input配置表示通过514端口接收syslog的数据<br>output配置表示输出到elasticsearch，并且同时输出到标准输出也就是控制台。<br>通过执行 <code>bin/logstash -f syslog-pipeline.conf --config.reload.automatic</code> 启动logstash<br><img src="https://img-blog.csdnimg.cn/20200309224021167.png" alt="可以看到logstash启动以后开启了514端口的tcp和upd协议的侦听"><br>可以看到logstash启动以后开启了514端口的tcp和upd协议的侦听。<br>我们访问nginx服务提供的web服务<a href="http://172.28.65.32/" target="_blank" rel="noopener">http://172.28.65.32/</a><br>在logstash的控制台 可以看到相应的nginx访问access和error的日志<br><img src="https://img-blog.csdnimg.cn/20200309224058280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="logstash的控制台可以看到相应的nginx访问access和error的日志"><br>同样通过Elasticsearch-head在ES 中也可以看到有相应的日志数据<br><img src="https://img-blog.csdnimg.cn/20200309224153318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="通过Elasticsearch-head在ES 中也可以看到有相应的日志"></p><h3 id="通过配置rsyslog发送syslog日志到logstash"><a href="#通过配置rsyslog发送syslog日志到logstash" class="headerlink" title="通过配置rsyslog发送syslog日志到logstash"></a>通过配置rsyslog发送syslog日志到logstash</h3><p>有些老版本的nginx不支持配置syslog输出日志，或者说我想输出其他不是nginx的日志该怎么办呢？可以通过直接配置rsyslog的方式来往外发送日志。<br>在/etc/rsyslog.conf 中配置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$IncludeConfig</span> /etc/rsyslog.d/*.conf</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309224226484.png" alt="/etc/rsyslog.conf"><br>意思是可以引用外部的配置文件，引用外部的配置文件一方面可以不影响主配置文件，另一方面也比较好管理<br>在/etc/rsyslog.d目录下新建nginx-log.conf<br>配置如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ModLoad</span> imfile</span><br><span class="line"><span class="variable">$InputFilePollInterval</span> <span class="number">1</span></span><br><span class="line"><span class="variable">$WorkDirectory</span> /var/spool/rsyslog</span><br><span class="line"><span class="variable">$PrivDropToGroup</span> adm</span><br><span class="line"></span><br><span class="line"><span class="comment">##Nginx访问日志文件路径，根据实际情况修改:</span></span><br><span class="line"><span class="variable">$InputFileName</span> /usr/local/nginx/logs/access.log</span><br><span class="line"><span class="variable">$InputFileTag</span> nginx<span class="literal">-access</span>:</span><br><span class="line"><span class="variable">$InputFileStateFile</span> stat<span class="literal">-nginx</span><span class="literal">-access</span></span><br><span class="line"><span class="variable">$InputFileSeverity</span> info</span><br><span class="line"><span class="variable">$InputFilePersistStateInterval</span> <span class="number">25000</span></span><br><span class="line"><span class="variable">$InputRunFileMonitor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##Nginx错误日志文件路径，根据实际情况修改:</span></span><br><span class="line"><span class="variable">$InputFileName</span> /usr/local/nginx/logs/error.log</span><br><span class="line"><span class="variable">$InputFileTag</span> nginx<span class="literal">-error</span>:</span><br><span class="line"><span class="variable">$InputFileStateFile</span> stat<span class="literal">-nginx</span><span class="literal">-error</span></span><br><span class="line"><span class="variable">$InputFileSeverity</span> error</span><br><span class="line"><span class="variable">$InputFilePersistStateInterval</span> <span class="number">25000</span></span><br><span class="line"><span class="variable">$InputRunFileMonitor</span></span><br><span class="line"></span><br><span class="line">*.* @<span class="number">172.28</span>.<span class="number">65</span>:<span class="number">514</span></span><br></pre></td></tr></table></figure><p>配置好了以后，重启rsyslog服务</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rsyslog</span><br></pre></td></tr></table></figure><p>我们访问nginx服务提供的web服务<a href="http://172.28.65.32/" target="_blank" rel="noopener">http://172.28.65.32/</a><br>在logstash的控制台 可以看到同样的效果。<br><img src="https://img-blog.csdnimg.cn/20200309224257449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="logstash的控制台"></p><p>本文介绍了如何通过filebeat、logstash、rsyslog采集nginx的访问日志和错误日志的几种方式，具体需要根据实际情况灵活的运用。</p><hr><p>作者博客:<a href="http://xiejava.gitee.io">http://xiejava.gitee.io</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析SIEM、态势感知平台、安全运营中心</title>
      <link href="/posts/e29f28e5/"/>
      <url>/posts/e29f28e5/</url>
      
        <content type="html"><![CDATA[<p>近年来SIEM、态势感知平台、安全运营中心等概念炒的火热，有的人认为这都是安全管理产品，这些产品就是一回事，有人认为还是有所区分。那么到底什么是SIEM、什么是态势感知平台、什么是安全运营中心，他们之间有什么联系和区别呢？</p><h1 id="一、SIEM"><a href="#一、SIEM" class="headerlink" title="一、SIEM"></a>一、SIEM</h1><p>SIEM英文是security information and event managemen安全信息和事件管理<br>SIEM是一个由多个监视和分析组件组成的安全系统，旨在帮助组织检测和减轻威胁<br>一款典型的SIEM产品是将许多其他安全规则和工具结合在一个综合的框架下形成的一个合集。<br>典型的包括以下模块<br>日志管理(LMS)——用于传统日志收集和存储的工具。<br>安全信息管理(SIM)——集中于从多个数据源收集和管理与安全相关的数据的工具或系统。例如，这些数据源可以是防火墙、DNS服务器、路由器和防病毒应用程序。<br>安全事件管理(SEM)——基于主动监视和分析的系统，包括数据可视化、事件相关性和警报<br>大多数的SIEM包括以下元素<br><strong>1、安全数据采集</strong><br>主要是基于安全日志数据，日志表示在数字环境中运行的进程的原始输出，是提供实时发生的事情的准确图像的最佳来源，因此是SIEM系统的主要数据源。无论是防火墙日志、服务器日志、数据库日志，还是在实际网络环境中生成的任何其他类型的日志，SIEM系统都能够收集这些数据并将其存储在一个中心位置以进行扩展的保留。此采集过程通常由代理或应用程序执行，部署在监视的系统上，并配置为将数据转发到SIEM系统的中央数据存储。<br><strong>2、安全数据解析处理和标准化</strong><br>为了能够跨不同源和事件相关性高效地解释数据，SIEM系统能够规范化日志。这个规范化过程包括将日志处理为可读的结构化格式，从日志中提取重要数据，并映射日志中包含的不同字段。<br><strong>3、安全数据集中存储</strong><br>安全信息数据存储的目地当然是为了利用数据进行管理分析发现安全事件。<br><strong>4、安全数据分析</strong><br>一旦收集、解析和存储，SIEM系统中的下一步将负责连接这些点并关联来自不同数据源的事件。这种关联工作基于各种SIEM工具提供的规则、为不同的攻击场景预定义的规则，或者由分析人员创建和调整的规则。大多数SIEM系统还提供生成报告的内置机制。这些报告可以用于管理、审计或合规性原因。例如，可以将详细描述触发警报或规则的每日报告嵌入到仪表板中。<br><strong>5、安全数据呈现</strong><br>可视化数据和事件的能力是SIEM系统中的另一个关键组件，因为它允许分析人员方便地查看数据。包含多个可视化或视图的仪表板有助于识别趋势、异常情况，并监控环境的总体健康或安全状态。一些SIEM工具将附带预先制作的仪表板，而另一些工具将允许用户创建和调整自己的仪表板。<br>基于目前海量的安全信息数据，<strong>大数据架构已经成为主流</strong>。并不是说SIEM必须使用大数据架构，因为这是一个应用场景问题而非技术问题。但面对大量数据需要处理的场景时，基于大数据架构的SIEM则必不可少。所以有些厂商提出了SDC（security data center）安全大数据中心的概念就是把所有的安全数据集中管理起来，在SDC的基础上构建安全数据分析和展现能力，形成SIEM平台。</p><p>目前成熟的SIEM产品有很多，开源的有OSSIM、Elastic SIEM、Opensoc<br>OSSIM是SIEM的代表性产品，在产品形式上和Kali类似是一个基于Debain进行二次开发的Linux发行版，当前5.6.5版本基于Dibian 8（jessie）。<br>OSSIM使用Nmap等实现资产发现、使用Nessus等实现漏洞扫描、使用Snort等实现入侵检测、使用MySQL等进行数据存储，自己实现的部分主要是工具、数据整合和可视化展示。ossim存储架构是mysql，支持多种日志格式，包括鼎鼎大名的Snort、Nmap、 Nessus以及Ntop等，对于数据规模不大的情况是个不错的选择，新版界面很酷炫<br>从架构上来看，OSSIM系统是一个开放的框架，它的核心价值在于创新的集成各开源软件之所长，它里面的模块既有C/S架构，又有B/S架构，但作为最终用户主要掌握OSSIM WebUI主要采用B/S架构，Web服务器使用Apache。OSSIM系统结构示意图如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200302211541393.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第1层，属于数据采集层，使用各种采集技术采集流量信息、日志、各种资产信息，经过归一化处理后传入核心层。改层体现安全事件来源，入侵检测、防火墙、重要主机发出的日志都是安全事件来源，它们按发出机制分为两类：模式侦查器和异常监控（两者都采集警告信息，功能互补）由它们采集的安全事件，再被Agent转换为统一的格式发到OSSIM服务器，这一层就是Sensor要完成的内容。<br>第2层，属于核心处理层，主要实现对各种数据的深入加工处理，包括运行监控、安全分析、策略管理、风险评估、关联分析、安全对象管理、脆弱性管理、事件管理、报表管理等。该层中OSSIM Server是主角，OSSIM服务器，主要功能是安全事件的集中并对集中后的事件进行关联分析、风险评估及严重性标注等。所谓的集中就是以一种统一格式组织所有系统产生的安全事件告警信息（Alarms）并将所有的网络安全事件告警存储到数据库，这样就完成了对网络中所产生事件的一个庞大视图。系统通过事件序列关联和启发式算法关联来更好的识别误报和侦查攻击的能力。<br>OSSIM本质上通过对各种探测器和监控产生的告警进行格式化处理，再进行关联分析，通过后期这些处理能提高检测性能，即减少告警数量，减小关联引擎的压力，从整体上提高告警质量。<br>第3层，属于数据展现层，主要负责完成与用户之间的交互，达到安全预警和事件监控、安全运行监控、综合分析的统一展示，形式上以图形化方式展示给用户。Web框架(Framework)控制台界面即OSSIM的Web UI（Web User Interface，Web用户界面），其实就是OSSIM系统对外的门户站点，它主要由仪表盘、SIEM控制台、Alarm控制台、资产漏洞扫描管理、可靠性监控、报表及系统策略等部分组成。<br>OSSIM主要模块的关系<br>OSSIM系统主要使用了PHP、Python、Perl和C等四种编程语言，从软件层面上看OSSIM框架系统包括五大模块：Agent模块、Server模块、Database数据库模块、Frameworkd模块以及Framework模块，逻辑结构如图所示。<br><img src="https://img-blog.csdnimg.cn/20200302213041778.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Elastic SIEM 的核心是全新的 SIEM 应用，此应用是安全团队的交互式工作空间，可允许他们对事件进行分类并开展初期调查。其中包括的时间线事件查看器 (Timeline Event Viewer) 能够允许分析师收集和存储攻击证据，固定相关活动并添加注释，以及添加评论并分享他们的发现，而且这一切在 Kibana 中即可完成；这样一来，您便能够轻松处理符合 ECS 格式的任何数据了。<br><img src="https://img-blog.csdnimg.cn/20200302213101396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">Opensoc是思科2014年在BroCon大会上公布的开源项目，但是没有真正开源其源代码，只是发布了其技术框架。可以参考Opensoc发布的架构，结合实际落地SIEM的方案。Opensoc完全基于开源的大数据框架kafka、storm、spark和es等，天生具有强大的横向扩展能力<br><img src="https://img-blog.csdnimg.cn/20200302213127295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>所以从SIEM的定义和功能来看有两个核心能力，一个是安全信息数据的采集汇聚能力，一个就是安全事件的分析能力。</strong></p><h1 id="二、安全态势感知平台"><a href="#二、安全态势感知平台" class="headerlink" title="二、安全态势感知平台"></a>二、安全态势感知平台</h1><p>“态势感知”早在 20 世纪 80 年代由美国空军提出，其包含感知、理解和预测三个层次。截止目前，业界对网络安全态势感知还没有一个统一全面的定义，基于美国Endsley 博士的理论对网络安全态势感知做出的定义：“网络安全态势感知是综合分析网络安全要素，评估网络安全状况，预测其发展趋势，并以可视化的方式展现给用户，并给出相应的报表和应对措施。”<br>什么是态势感知平台，大家都认为应该是利用大数据、机器学习等技术对态势感知态势海量数据进行提取，进行多维度的关联分析。能够提供对安全风险保持报警、趋势预测等，海量数据、关联分析、大屏展示和趋势预测是四个重点。而趋势预测最核心，目前做起来也比较难。<br>个人理解，<strong>SIEM重点在于对安全事件的感知和理解，态势感知重点在于通过大数据、机器学习等技术加深了对安全趋势的预测</strong>。国外一般不提态势感知系统，而国内，很多厂商都推出了态势感知系统。<br>目前国内安全厂商提供的“态势感知产品”包含的功能模块有：资产管理、漏洞管理、大数据平台、日志分析平台、威胁情报、沙箱、用户行为分析、网络流量分析、取证溯源、威胁捕捉等能力。<br>几个关键点：<br>1、 大数据平台。随着监测范围的扩大，数据量也在扩大，需要一个具备大数据处理和计算能力的平台，这是整个态势感知平台建设很重要的基础。<br>2、 基于威胁情报的监测。威胁情报对于降低大量数据和报警中的垃圾数据或者报警噪声，帮助更快速、更高效的发现攻击行为和攻击者非常关键，威胁情报的质量是检验态势感知平台能力的很重要的方面。<br>3、 全要素数据的采集。利用态势感知这样的平台能力的核心目的，是要监测到复杂的、高级的攻击，就需要态势感知平台首先要捕获到微观的状态，低成本、高效率的全要素数据采集能力是基础。<br>4、 基于攻击场景的分析研判。攻击不再是基于特征的监测，需要运用威胁情报、运用一些专家的经验，来构建基于场景的分析系统，它不是一个静态的东西，是一个与时俱进的攻防对抗过程中不断学习、学习参考的过程，需要持续运营这样的分析管理，需要更多的专家的经验和安全运营人员的参与。</p><h1 id="三、安全运营中心"><a href="#三、安全运营中心" class="headerlink" title="三、安全运营中心"></a>三、安全运营中心</h1><p>SOC（安全运营中心）来源于NOC（网络运营中心）。<br>随着信息安全问题的日益突出，安全管理理论与技术的不断发展，需要从安全的角度去管理整个网络和系统，而传统的NOC在这方面缺少技术支撑，于是，出现了SOC的概念。<br>以前大家所说的SOC是SOC 1.0阶段，只是在SOC的核心部件SIEM的买卖，国外所说的SOC是一个复杂的系统，它使用SIEM产品进行运维又以此向客户提供服务，也就是我们所说的SOC 2.0<br>SOC(安全运营中心)是以资产为核心，以安全事件管理为关键流程，采用安全域划分的思想，建立一套实时的资产风险模型，协助管理员进行事件及风险分析，预警管理，应急响应的集中安全管理系统。<br>SOC是一个复杂的系统，它既有产品，又有服务，还有运维，SOC是技术、流程和人的有机结合。<br>随着<strong>安全态势感知平台的兴起，安全运营中心将以态势感知平台作为智能安全运营的载体</strong>，在风险监测、分析研判、通知协作、响应处置、溯源取证等各方面进行了增强，同时融入了当前流行的技术和平台作为支撑，如大数据技术、东西向流量采集技术，EDR 终端检测响应技术、机器学习、欺骗攻击技术等。同时态势感知平台与 ITIL（Information Technology Infrastructure Library，ITIL）理念与信息安全管理标准相融合，将安全运营划分为不同角色，如安全管理人员、安全专家、安全运维、安全分析师、安全应急响应人员、安全研究人员等，在集成了安全事件管理全生命周期的流程中，通过工作流程将其串联起来，使安全运营流程更加规范和有序。</p><p><strong>所以个人认为SDC&lt;SIEM&lt;态势感知&lt;安全运营中心</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Git Pages+Hexo搭建自己的博客</title>
      <link href="/posts/79ebd763/"/>
      <url>/posts/79ebd763/</url>
      
        <content type="html"><![CDATA[<h1 id="一、申请并配置Github-Pages"><a href="#一、申请并配置Github-Pages" class="headerlink" title="一、申请并配置Github Pages"></a>一、申请并配置Github Pages</h1><h2 id="step1-在github上创建一个git库"><a href="#step1-在github上创建一个git库" class="headerlink" title="step1 在github上创建一个git库"></a>step1 在github上创建一个git库</h2><p>用github账号登录<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> ，如没有github账号则申请一个github账号。登录后点击“New repository”新建一个名为username.github.io（username是你的github用户名）如我的是：xiejava1018.github.io ，如果库名以及存在则会报库名已经存在的错误。<br><img src="https://img-blog.csdnimg.cn/20200212151727627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="新建库"></p><h2 id="step2-绑定自己的域名（如果没有自己的域名也可以不绑）"><a href="#step2-绑定自己的域名（如果没有自己的域名也可以不绑）" class="headerlink" title="step2 绑定自己的域名（如果没有自己的域名也可以不绑）"></a>step2 绑定自己的域名（如果没有自己的域名也可以不绑）</h2><p>访问刚申请的git库，点击Settings<br><img src="https://img-blog.csdnimg.cn/20200212151814995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="Settings"><br>如果库名不是username.github.io（username是你的github用户名）在这里可以修改成username.github.io<br><img src="https://img-blog.csdnimg.cn/202002121518548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="修改库名"><br>拖到下面可以看到GitHub Pages的信息，如果不绑定自己的域名实际可以通过<a href="https://username.github.io/来访问你的站点了。" target="_blank" rel="noopener">https://username.github.io/来访问你的站点了。</a><br><img src="https://img-blog.csdnimg.cn/20200212151939704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="站点地址"><br>如果有申请自己的域名，可以将域名解析到你的GithubPages username.github.io 如我的是xiejava1018.github.io<br><img src="https://img-blog.csdnimg.cn/20200212152026730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="解析自定义域名"><br>在GitHub Pages的自定义域名Custom domain中输入刚解析的域名保存后就可以看到你的站点被发布到你的域名上了，如<a href="https://xiejavablog.ishareread.com/" target="_blank" rel="noopener">https://xiejavablog.ishareread.com/</a><br><img src="https://img-blog.csdnimg.cn/20200212152056432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="绑定自定义域名"><br>这时候你就可以用自己的域名来访问GitHub Pages的网站了，不过现在什么都没有，只有个空白页面。这就需要我们借助Hexo这个静态站点生成工具来生我们站点的内容了。</p><h1 id="二、安装Hexo并生成站点"><a href="#二、安装Hexo并生成站点" class="headerlink" title="二、安装Hexo并生成站点"></a>二、安装Hexo并生成站点</h1><p>安装Hexo并生成站点可以参考官方的文档 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a>  </p><h2 id="1、安装前的准备"><a href="#1、安装前的准备" class="headerlink" title="1、安装前的准备"></a>1、安装前的准备</h2><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：<br>Node.js (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)<br>Git</p><h2 id="2、安装Hexo"><a href="#2、安装Hexo" class="headerlink" title="2、安装Hexo"></a>2、安装Hexo</h2><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完了以后可以通过hexo version 查看相应的版本<br><img src="https://img-blog.csdnimg.cn/2020021215253021.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="版本信息"></p><h2 id="3、生成站点"><a href="#3、生成站点" class="headerlink" title="3、生成站点"></a>3、生成站点</h2><p>安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：<br><img src="https://img-blog.csdnimg.cn/20200212152343204.png" alt="目录"><br>其中_config.yml 文件是网站的配置文件<br>package.json 是应用程序的信息<br>scaffolds<br>模版文件夹。当新建文章时，Hexo 会根据 scaffold 来建立文件。<br>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。<br>source<br>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。<br>themes<br>主题 文件夹。Hexo 会根据主题来生成静态页面。</p><h2 id="4、安装主题"><a href="#4、安装主题" class="headerlink" title="4、安装主题"></a>4、安装主题</h2><p>Hexo提供了很多主题，我用的是hexo-theme-next主题，大家可以直接克隆我的主题<a href="https://github.com/xiejava1018/hexo-theme-next.git" target="_blank" rel="noopener">https://github.com/xiejava1018/hexo-theme-next.git</a> 这里修复了一些bug如乱码问题等。<br>cd 切换到站点目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/xiejava1018/hexo-theme-next.git themes/hexo-theme-next</span><br></pre></td></tr></table></figure><p>也可以用其他git客户端工具将主题拉取到themes目录下<br>修改_config.yml文件的theme改为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme :</span> <span class="string">hexo-theme-next</span></span><br></pre></td></tr></table></figure><h2 id="5、写作"><a href="#5、写作" class="headerlink" title="5、写作"></a>5、写作</h2><p>可以执行下列命令来创建一篇新文章或者新的页面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。<br>如执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 2020-02-11-2020-02-11-看完全套149本《书虫》是种什么样的体验</span><br></pre></td></tr></table></figure><p>执行该命令后就会在响应的站点目录的source_posts下生成2020-02-11-看完全套149本《书虫》是种什么样的体验.md文件。<br><img src="https://img-blog.csdnimg.cn/2020021215265521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="文件"><br>用任何喜欢的编辑器编辑这个.md文件即可，排版是支持MarkDown的。</p><h2 id="6、生成和发布"><a href="#6、生成和发布" class="headerlink" title="6、生成和发布"></a>6、生成和发布</h2><p>编辑好需要发表的内容后。执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>就会生成相应的静态文件。改命令也可以简写成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就可以通过该地址访问本地的站点。<br>在本地检查没有问题以后就可以发布到Github Pages上通过互联网上访问了。<br>首先在配置_config.yml文件配置需要发布的地址。这个地址就是你在github上申请的Github Pages库的git地址<br><img src="https://img-blog.csdnimg.cn/20200212152738164.png" alt="发布地址配置"><br>然后就可以通过命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>进行发布了。发布以后就可以通过<a href="https://xiejava1018.github.io" target="_blank" rel="noopener">https://xiejava1018.github.io</a> 或者自定义的域名 <a href="https://xiejavablog.ishareread.com" target="_blank" rel="noopener">https://xiejavablog.ishareread.com</a> 来访问了。需要注意的是，每次重新发布以后，需要重新设置域名绑定才能正确访问，否则会报404的错误。</p><p>欢迎大家访问我的BLOG  <a href="https://xiejavablog.ishareread.com/" target="_blank" rel="noopener">https://xiejavablog.ishareread.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看完全套149本《书虫》是种什么样的体验</title>
      <link href="/posts/40bbedc5/"/>
      <url>/posts/40bbedc5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200211/blogimage/english.png" alt="English" title="English"></p><p>一直想学好英语，可惜一直在陷入”从入门到放弃”的怪圈，这么多年来一直尝试各种方式方法来学英语始终未成正果。当然这一切都归因于自己没有恒心没有毅力。有过坚持了330天终于放弃了背单词的经历，也找了很多如何学好英语的书籍和方法。受了李笑来老师的《人人都能用英语》及伍君仪的《把你的词汇用起来》的影响。经过自己仔细思考认为确实如果要把英语学好必须要用起来。考虑到自己的实际情况，没有相应的语言环境，从听说开始用起来可能也不太现实，最现实的方式就是从大量的阅读开始将英语用起来。即学了知识又学了英语，还没有那么枯燥。</p><p>如何开始阅读，读什么东西呢？自己的水平还没有达到能够读懂英文原版书的程度，望着满片英文的原版书还是心生畏惧。也是在网上看大家学习英语的经验，有人就介绍了阅读的方式方法。初学者一开始就不要挑战太高难度了，容易打击自己的自信心。最好的方式是采取分级阅读的方式，阅读i+1的英语材料。也就是阅读比自己能力稍微高一点的英语材料。在找英语阅读的材料过程中发现了很多人推荐了《书虫》，也就是”书虫·牛津英汉双语读物”，这套读物是外语教学与研究出版社和牛津大学出版社联袂奉献给英语学习者的一大分级阅读精品书系，提供了从小学高年级至大学的全套阅读方案。图书按照词汇量和语言难度进行科学分级。共分了七个级别，15套，共149本书。</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200211/blogimage/%E4%B9%A6%E8%99%AB2.png" alt="《书虫》系列" title="《书虫》系列"></p><p>我觉得这套读物比较适合像我这样的初学者。离开学校多年了，也不知道自己的英语水平究竟是属于什么级别，抱着空杯的心态，干脆就从最低级的开始看起（想想还可以给小孩看）。我是2019年6月18日购买的全套，从快递点搬回来的时候一大箱子很重。看着这满满一箱足足149本，比较兴奋又比较忐忑。兴奋的是我终于可以开始我的英语阅读之旅了，忐忑的是这也149本也忒多了吧？从来没有尝试过一次性读过这么多的书，即使是中文书也没有挑战过。</p><p>很欣赏伍君仪在《把你的词汇用起来》中的一句话，就是“学英语既然开始了，就一定要把它学好！”。反反复复从”从入门到放弃”浪费时间精力又没有什么效果。于是从2019年7月正式从书虫第一套入门级的第一本《 Survive！》生存游戏开始。入门级相当于小学高年级的水平，当然读起来很流畅很爽。有时候可以一口气看三、四本。入门级每一本都比较薄只有几十页，而且有一半还是中文解释。基本上没有什么挑战。毕竟有近150本怎么才能全部读完呢？我做了个计划给自己规定每天看40页或以上，准备用大半年的时间将这套书全部看完。书虫这套书可读性还是比较强，内容非常丰富，主题多样，包括悬疑、侦探、间谍等多种题材，大部分都是世界名著。小时候读名著读得比较少，这下可以过一下名著的瘾了，虽然是简写版的。尽管是简写版的但是改编得故事性挺强的，非常吸引人，很能提高阅读兴趣。为了让自己能够坚持下去，我每读一本都会在豆瓣上进行标记，并加入到自己的已读英文读本的豆列里。每读完一本就感觉到离胜利越近了一点。前面1至5级读得还很顺利，几乎都可以不用看中文翻译，后面到了第6级以后就有点磕磕绊绊了，有时候需要借助中文翻译才能看懂。不管怎么样，终于在2020年2月9日将全套书虫的最后一本《印度之行》全部读完，历时半年。除了其中11月底有段时间公司加班很厉害确实没有读以外，基本上每天都有阅读。看着满满的一箱书，这一本本标记已读的书，心里还是满满的成就感。</p><p>通过阅读全套书虫的经历，让我建立了学好英语的信心，培养了我阅读英语的兴趣。我想我再也不会“从入门到放弃”了。我花了半年的时间和精力把全套《书虫》都看完了，你要我放弃，那不这半年的努力都白费了吗？</p><p>但是有人可能会问我，看完全套书虫以后你的英语水平达到了什么程度。我想我会很遗憾的告诉你，“革命尚未成功，同志仍需努力”。我也曾经报有幻想，以为看完全套《书虫》自己的英语水平就很牛B了。但是越看到后面越清晰的认识到《书虫》这套书有它的局限性。整套书下来，最高级别的单词量才3000。也是高中毕业大学低年级的水平。也使我清晰的认识到自己目前的英语水平也就是高中毕业大学低年级的水平。一个意外的收获就是通过阅读《书虫》全套，大致的了解了英语的小说文学史，相当于给了我一个目录和一个指引。有哪些好的小说有兴趣可以更加深入的读下去。比如通过阅读书虫对英国文学史上著名的勃朗特三姐妹有了深刻的了解，因为里面有本书是写《勃朗特一家的故事》。这套书里还有《呼啸山庄》和《简·爱》,分别是勃朗特三姐妹中的艾米莉·勃朗特和夏洛蒂·勃朗特的名著，看了他们的简介再读了她们的作品理解更加全面和深刻了。让我有进一步看这两部名著的英文原版的欲望了。还有英国侦探小说女王阿加莎·克里斯蒂有本书《神秘女人——阿加莎•克里斯蒂》就是介绍她的经历和作品，看完以后我立马找了她的中文版的《东方快车谋杀案》看了觉得很有意思。还有狄更斯、哈代等的名作都让人看了还想看。通过这样大量的阅读体验以后，我对名著产生了浓厚的兴趣，我觉得我应该具备了阅读英文原版书的能力。下一个阶段我有信心准备开始我的英文原版书阅读了。今年我的计划是挑战看完十本英文原版书。</p><p>我读过的英文读本豆列： <a href="https://www.douban.com/doulist/118432400/" target="_blank" rel="noopener">https://www.douban.com/doulist/118432400/</a></p><p>爱分享读书豆瓣小组： <a href="https://www.douban.com/group/655112/" target="_blank" rel="noopener">https://www.douban.com/group/655112/</a></p><hr><center>关注：“爱分享读书”微信公众号 </center><p><img src="http://image.ishareread.com/qrcode_for_gh_70fb5d85a824_258.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><center>读书我们是认真的</center>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>坚持了330天，我终于放弃了背单词</title>
      <link href="/posts/48451ead/"/>
      <url>/posts/48451ead/</url>
      
        <content type="html"><![CDATA[<p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200211/blogimage/bdc.png" alt="不背单词，能学好英语吗？" title="不背单词，能学好英语吗？"><br>不背单词，能学好英语吗？<br>学习英语是我永远的痛，读书的时候没有把英语学好，工作后觉得英语很重要，经历了N多次从坚持到放弃。这一次，我是来真的，发誓不把英语学好不罢休，为此我下载了百词斩。为了有人监督我加入了打卡群，每天坚持英语背单词打卡，这是我坚持做得最好的一件事情，每天早上起床第一件事情就是背单词，每天20-30个，几乎从来没有中断过。但是我坚持到330天后，我还是决定放弃背单词了。为什么呢？因为没效果！！！我已经背完了从小学到大学以及新概念1-2册的单词，APP上显示我的词汇量已经达到7000，超过了80%的网友。可是我看英语文章还是一脸懵逼，即使是最浅的英语读物也有单词不认识。听不懂，更别奢望能说了。英语单词背了忘、忘了背，严重怀疑这个APP上显示7000多的单词量是哄我开心的，要不背了这么久的单词，英语水平还这么菜，依旧啥也看不懂……</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200211/blogimage/englishisharet.png" alt="学英语是会呼吸的痛" title="学英语是会呼吸的痛"></p><p>放弃背单词，并不代表我放弃了英语，因为我找了一本书–《人人都能用英语》。经过傻傻的认为打卡背单词就可以学好英语沉痛而失败的教训后，越发认为这本书相见恨晚。学英语就是要用，要不学英语干啥？坚持非常重要，但是坚持的方向错了一切都是白搭！</p><p>这不是一本英语的单词书、语法书。是一本教你如何学英语，不，应该是如何“用”英语的书。作者是我们都很熟悉的曾经是新东方专业英语老师，现在是比特币首富的–李笑来老师，《把时间当做朋友》的作者。虽然是专业的英语老师，在书中他没有卖弄自己的专业，而是非常真诚的讲述了自己学习英语的过程。整本书解决了我所有学英语的疑惑。</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200211/blogimage/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E7%94%A8%E8%8B%B1%E8%AF%AD1.png" alt="《人人都能用英语》" title="《人人都能用英语》"></p><p>经历了N多次从坚持到放弃，我曾经就差点相信学习英语要有天赋才能学好，自己不是学英语的那块料。在书中作者花了很大量的篇幅来告诉我们，人人都可以学好英语！书中举了个例子，大约在1988年前后，他父亲的同事一位教英语的副教授去考了一次托福，成绩是570（满分677分），一个专职的英语教授考托福才考570分，想想这是个多么难的考试。当年，甚至若干年作者都不敢想象自己能够去考托福。直到2000年底，他急需要一份稳定的工作，想去新东方应聘，他花了4个月的时间专注学习，考了托福，考了GRE，拿了变态的成绩去应聘了新东方成为了那里的英语教师。他以亲身经历说明了一个问题，你学不好，是因为你不信，只有你相信你能做好，你才能真正做好。哪里有那么多天才呢？所谓的天才，只不过是反复练习，持之以恒的结果。</p><p>不要再“学”英语，你就应该“用”英语！这是最触动我的一句话，也是整本书的核心。大部分的人，包括我都是从初中、高中、大学，“学”了近十来年的英语，真正学会的人又有几个呢？只“学”不“用”的下场就是在十几年之后依然在学依然无用。依旧陷入从坚持到放弃的怪圈。学英语的核心其实是在用。只有不断地“用”，才能真正地学到，要不就会一直停留在“学”的阶段。既然不“用”就“学”不好，那不如从一开始就直接“用”。无论如何，一定要想明白对自己来说，英语真正的用处在哪儿？对于很多人来说，其实只要能够流利阅读英语或许已经足够了，至少对我来说已经够了。既然想要流利的阅读英语，那就直接从“用”英语阅读开始，抛开所谓的单词量、语法、语音、语调。不会的单词查字典，看不懂的句子查语法书。不管你是想流利的阅读，还是用英语交流，反正，用就是了。回想一下，也是哦，想想自己小学语文的经历，小学一年级还学下生字，二年级就开始学用字典查生字，以后慢慢的抛开字典可以自由的读写了。</p><p>其实如何通过“用”来学习外语，国学大师、学界泰斗季羡林，季老先生在自己的言传身教中已经说的非常清楚，并且可操作性非常强。他说到：“我想斗胆提出一个，‘无师自通’的办法，供胡同志和其他读者参考。你只需要找一位通德语的人，用上二三个小时，把字母读音学好。从此你就可以丢掉老师这个拐棍，自己行走了。你找一本有可靠的汉文译文的德文科技图书，伴之以一本浅易的德文语法。先把语法了解个大概的情况，不必太深入，就立即读德文原文，字典反正不能离手，语法也放在手边。一开始必然如堕入五里雾中。读不懂，再读，也许不止一遍两遍。等到你认为对原文已经有了一个大概的了解，为了验证自己了解的正确程度，只是到了此时，才把那一本可靠的译本拿过来，看看自己了解得究竟如何。就这样一页页读下去，一本原文读完了，再加以努力，你慢慢就能够读没有汉译本的德文原文了。”</p><p>嗯，我想我可以放心的放弃背单词，拿起我的那本英文版的《Spring in Action》开始慢慢啃了……</p><hr><center>关注：“爱分享读书”微信公众号 </center><p><img src="http://image.ishareread.com/qrcode_for_gh_70fb5d85a824_258.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><center>读书我们是认真的</center>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把时间当作朋友，相信我，你并不孤独</title>
      <link href="/posts/a0bb2f7e/"/>
      <url>/posts/a0bb2f7e/</url>
      
        <content type="html"><![CDATA[<p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200106/blogimage/3.jpg" alt="把时间当做朋友" title="把时间当做朋友"><br>相信我，你并不孤独！自卑、对任何事情都没有兴趣、在工作多年后，对未来还是很迷茫，对自己的效率不满，对自己的能力怀疑。相信在此世间，此时此刻，困恼的不是我一个。  </p><p>《把时间当作朋友》这本书2009年出版，现在这本书已经是第三版了，并且还推出了逻辑思维独家定制版。该书长期在豆瓣上评分都是在8.3分以上，无数人看了以后都感觉到相见恨晚，受益匪浅。作者李笑来原来是新东方的老师，现在号称是投资人，比特币首富。新东方的老师像创始人俞敏洪、锤子手机的老罗、古典等都有个特点，都很都善于灌鸡汤，兜售所谓的成功学，很有煽动性。可以理解像英语那么枯燥有难度的学习过程，如果没有成功学的激励被放弃的几率还是蛮大的。成功离不开鸡血，也少不了鸡汤。   </p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200106/blogimage/4.jpg" alt="《把时间当做朋友》" title="《把时间当做朋友》"><br>《把时间当作朋友》这本书从心智成长的角度来谈时间管理、学习方法、兴趣、人脉等成功的关键所在。虽然书中有个章节是”小心所谓的成功学”。但不可否认，这本书就是告诉大家如何了解时间，和时间做朋友，用心智成长开启自己的人生成功之旅的“成功学”。其中的某些观点和做法我觉得很有道理并值得付之于行动。  </p><p>首先是对时间管理的认识，有很多书都在谈时间管理，而时间每天每个人都只有24小时，都在静静的不以人的意识为转移地流逝。时间它是不会听从任何人的管理，我们无法管理时间，我们真正能够管理的是我们自己。而管理好自己就是需要通过自己的大脑控制自己的大脑，需要有很强的意志力和成熟的心智。  </p><p>管理好自己利用好时间，需要对自己的时间有个清楚的了解，知道自己的时间都花到哪里去了。最有效的办法就是《奇特的一生》的作者，苏联生物学家柳比歇夫的事件-事件日志记录方法。将自己每天做的每件事情都花的多少时间详细的记录下来。想尽一切办法真正了解自己，真正了解时间，精确地感知时间，而后再想办法使自己的行为与时间”合拍”，与时间做朋友。  </p><p>学会了如何利用好自己的时间，接下来的就是行动。什么时候开始行动呢？如果要打算做某件事情，并且想做成的话，应该是立刻、马上、立即、now就开始行动！  </p><p>开始行动后就要学会坚持。所有学习上的成功，都只靠两件事：策略和坚持，而坚持本身就是最重要的策略，坚持其实就是重复，而重复说到底就是时间的投入，任何领域想要取得卓越的成就都必须用一生的努力才能取得，想要出类拔萃，就要努力至少一万小时。</p><h2 id="关于学习方法："><a href="#关于学习方法：" class="headerlink" title="关于学习方法："></a><strong>关于学习方法：</strong></h2><p>除了“试错”、“观察”、“阅读”之外，“思考”准确的说是“正确地思考”才是获得真正意义上的知识的主要手段。<br>提高自学能力</p><ol><li>自学能力的基础技能是阅读理解能力。</li><li>检索能力是建立在相当熟练的阅读能力之上的能力。</li><li>写作能力在自学能力中占据着重要的地位。</li><li>实践能力是自学能力最终能够转换为真正价值的根本。<br>教是最好的学习方法。</li></ol><h2 id="关于兴趣："><a href="#关于兴趣：" class="headerlink" title="关于兴趣："></a><strong>关于兴趣：</strong></h2><p>很多人，包括我自己，不知道自己的兴趣在哪里？或试图要培养自己的兴趣。书中的一段话给我很大的启示，只要一件事你能做好，并且做得比谁都好，或者至少比大多数人好，你就不会对那件事情没兴趣。往往并不是有兴趣才能做好，而是做好了才有兴趣。  </p><p>大多数事情都需要孰能生巧，做得多了，自然就擅长了，擅长了，就自然比别人做得好，做得比别人好，兴趣就大起来了，而后就更加喜欢做，更擅长，更……良性循环。但同样做得多久需要大量的时间投入，没兴趣，往往只不过是结果而已，如果被当做不去做好的理由，最终的惩罚就是大量的时间白白的流逝。</p><h2 id="关于人脉："><a href="#关于人脉：" class="headerlink" title="关于人脉："></a><strong>关于人脉：</strong></h2><p>打造人脉不如打造自己，只有优秀的人才拥有有效的人脉。  </p><p>关于书中讲到了通过自己的大脑控制自己的大脑。其实就是个人意志力的问题，只是书中换了个说法。个人的成功很大程度都是取决于个人意志力。通过意志力控制心智成长，让人成熟，成功。  </p><p>如果你现在还在迷茫，相信我，你并不孤独。把这本书看完吧。再牛逼的人都有段苦逼的经历，如果你还在苦逼的过程中，请把时间当做朋友，沉下心来慢慢学习积累，收获成长，笃性自己能够成功！大家一起共勉。</p><hr><center>关注：“爱分享读书”微信公众号 <p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/%E7%88%B1%E5%88%86%E4%BA%AB%E8%AF%BB%E4%B9%A6%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><p>读书我们是认真的</p></center>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终身学习时代，阅读是你大脑的磨刀石</title>
      <link href="/posts/da35ea85/"/>
      <url>/posts/da35ea85/</url>
      
        <content type="html"><![CDATA[<p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200106/blogimage/1.jpg" alt="图书馆" title="图书馆"><br>  在这个互联网信息知识大爆炸的时代，学习能力是每个人的核心能力，如何通过学习把知识转化为自己的能力，拓宽人生的可能性，是每个人孜孜不倦渴求的。而阅读，尤其是高效的阅读是掌握知识最简单、成本最低、也是最高效的学习方式。阅读能力是学习能力的根本，会阅读的人才会具备快速学习的能力和良好思维以及应变能力。认识到这一点，所以想读书的人越来越多，爱读书的人越来越多。但是很多人在阅读或培养阅读的过程中碰到了各种各样的困难和问题。如：知道阅读很重要，但是拿起书就想睡觉根本看不进书；没有时间阅读；读不懂，记不住，用不上等等。市面上也涌现了不少教大家阅读的书籍，如被誉为阅读圣经的《如何阅读一本书》、《越读者》、《书都不会读，你还想成功》、《如何高效读懂一本书》等等。</p><p>  好脑筋需要书本，就如同宝剑需要磨刀石。</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200106/blogimage/2.jpg" alt="好脑筋需要书本，就如同宝剑需要磨刀石" title="好脑筋需要书本，就如同宝剑需要磨刀石"></p><p>  通过阅读我们可以系统性地获取知识，但很多人在阅读习惯养成的前期也会面临很多问题，很多人对阅读有障碍、有困难，实际上是我们对阅读这件事的理解并不清晰透彻，我们应该了解阅读的本质。阅读的本质就是在可以利用的时间里，以你自己能理解的程度去学习。有些初学者了解到阅读的重要性以后，心情非常迫切，一上来就捧起大部头的书，或者比较深奥烧脑的书看，结果要不就是看几页昏昏入睡，要不就是看了几天都看不完，渐渐的失去了耐心，阅读兴趣和想培养的阅读习惯也就在屡次的打击中放弃了。其实要想开始阅读或培养阅读习惯，最有效的办法就是根据自己的能力先从一些入门级的自己感兴趣的书籍着手。在《书都不会读，你还想成功》的书中，就是建议先给自己定个计划读100本书开始，这100本书先抛开任何功利性的想法，不管什么书，只要是自己感兴趣的或者能够看得下去的书就可以，看不下去的书先放一边，通过100本书慢慢培养自己的阅读兴趣和习惯。先有了阅读兴趣和习惯，想看了愿意看了。再来谈阅读方法的问题，通过阅读方法解决看得快，记得牢的问题。再来逐渐选择高于自己目前能力的书籍进行有目的性的阅读。</p><p>  其实阅读方法正如《洋葱阅读法》里所述，无非就是碎片化阅读、快速阅读、主题阅读。不管是那种阅读方法，都是需要带有强烈目的性的阅读，只有有目的的阅读，然后学以致用才能看得快，记得牢，用得上。</p><p>  碎片阅读实际就是利用碎片化的时间，学习碎片化的内容。如何取得碎片化阅读的效果呢？有人每天都碎片化的阅读一些微信文章啥的，但是长期以来除了感觉有些文章写得不错每天点赞外，对自己并没有什么提高呢。其中最关键的就是要建立自己的知识体系。在基于自己的知识体系的基础上将阅读到的碎片化的内容补充到自己的知识体系中建立相应的联系。要不然阅读到的碎片还是碎片，不和已有的知识进行关联，永远都是碎片，久而久之久会忘记掉。没有自己的知识体系就相当于没有建立自己的银行账户，碎片化阅读看到的内容相当于打零工赚回来的钱没有地方放。东放一点，西放一点时间久了自然就忘记了。有了自己的知识体系就相当于建立自己的知识银行账户，打零工赚的钱可以零存整取，不断的往自己的知识体系中填砖加瓦，让自己的知识银行账户余额越存越多。</p><p>  如何构建自己的知识体系呢，就要通过快速阅读和主题阅读。一本书本身的就是某个知识系统化的描述。所以要想系统的构建自己的知识体系，系统的看书是必经之路。</p><p>  快速阅读的本质就是提升阅读的速度，快速掌握书中的知识。核心就是带着问题来阅读。在阅读之前，先了解一下自己读这本书的目的，梳理一下问题，为什么要读这本书，这本书能够解决我什么问题，自己以前有没有读过类似的书等等。通过快速的阅读，在书中找这些问题。有些无关紧要的描述就可以快速略看，与问题相关的仔细阅读。通过变速阅读达到快速了解一本书掌握关键知识点的目的。</p><p>  主题阅读则更是为了构建自己的知识体系，在某个知识主题领域，通过广泛的阅读，同时阅读多本相同主题书的方式来深入对某个知识主题领域学习的过程。其主要目的是搞懂某个主题领域的知识。</p><p>  当然不管是碎片化阅读、快速阅读、主题阅读，要想通过阅读来提高自己的能力，首先要有构建自己知识体系的意识；其次是通过某种方式彻底的搞懂自己没有懂的知识如通过反复阅读，一本书重复多读几遍或通过读同一知识点不同作者写的书来搞懂，或者通过费曼读书法将阅读的知识通过自己的理解用自己的方式讲述给懂的人；最后就是要学以制用，将通过阅读学到的知识在平时的工作、生活、学习等各个方面用起来。只有这样才能真正的通过阅读不断的提高自己的能力，真正找到阅读的乐趣，越读越有味，越读越想读！</p><hr><center>关注：“爱分享读书”微信公众号 <p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/%E7%88%B1%E5%88%86%E4%BA%AB%E8%AF%BB%E4%B9%A6%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><p>读书我们是认真的</p></center>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用系统方式思考，高效的工作</title>
      <link href="/posts/f7e86db6/"/>
      <url>/posts/f7e86db6/</url>
      
        <content type="html"><![CDATA[<p>　　用系统方式工作的思想是萨姆·卡彭特在《用系统来工作》的书中提到的。大家可以想想华为、富士康等公司为什么效率高？因为有一套系统化的流程让各个环节高效的运作。所以咱们也可以参考，运用到我们的工作、学习、生活中来，让我们更高效。 </p><p>　　所有工作都可以用系统的视角的思考。如管理公司、上班的日常工作、学一门技能、健身等等。<br>　　首先我们要明确目标，比如管理公司我要达到什么经营目标，学习我要学到什么东西达到什么程度，减肥健身要达到什么效果，一定要有非常清晰的目标，最好是能够写下来，放在显眼的地方，时时关注。<br>　　其次我们要制定准则，即达到实现目标的大的方针，比如减肥健身，准则可以定义为控制饮食、加强锻炼等。<br>　　最后我们要明确做事的流程，如何明确流程？可以按照以下几点整理。<br>　　1、分解每个工作的任务项。<br>　　 将一个工作分解成一个个可以操作的具体任务项。如开会可以分解为确定会议室、准备会议材料、通知会议参与人、做会议纪要、跟踪会议结论执行情况等等。<br>　　 如减肥健身可以分解为：合理饮食、准备活动、有氧运动、肌肉强化运动、睡眠休息等等。<br>　　2、将每个工作任务项按依赖顺序整理形成固化的流程<br>　　 有些工作项是有依赖关系的，所以我们要按照依赖关系顺序整理成流程。先干什么，后干什么，这样做事才会更有条理，减少等待的时间更高效。<br>　　3、给每个工作任务项提供说明指导<br>　　 就是将每个细化的工作项做到最好。在华为，所有的岗位，每项工作都有具体的作业指导书。在作业指导书中详细定义了这个环节需要做什么，具体怎么做，完成后如何检查反馈。这个作业指导书是不断总结完善的。所以不管是老手，还是新来的菜鸟，都可以很好并高效的完成。<br>　　4、在实践的工作中不断完善流程<br>　　 一开始可能流程并不完善，我们可以在实际实施的过程中不断的优化调整，去掉一些不必要的环节，优化一些效率低下的环节，一切优化都是遵循我们开始定义的目标。 </p><p>　　通过系统方式思考做事情可以用到工作、学习、生活的各个方面，总的来说，就是明确目标、制定准则、定义流程，不断完善流程。将事情高效的做好。作为领导者，有了流程后，你还可以将这个流程交给任何一个人都可以做好。将自己释放出来。有更多的时间平衡工作、学习、生活。这就是系统的力量。</p><hr><center>关注：“爱分享读书”微信公众号 <p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/%E7%88%B1%E5%88%86%E4%BA%AB%E8%AF%BB%E4%B9%A6%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><p>读书我们是认真的</p></center>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Hexo博客导航栏链接URL乱码问题</title>
      <link href="/posts/5661/"/>
      <url>/posts/5661/</url>
      
        <content type="html"><![CDATA[<p>今年的计划之一是搭建一个博客，开始写博客。于是在网上找了一些博客程序发现用Hexo在gitHub上搭建自己的个人博客是比较简单而且易于维护的做法。<br>在网上找了一些教程后开始搭建，用自己比较中意的hexo-theme-next模板，发现搭建成功后导航栏链接不对，出现了URL乱码的问题。在网上搜索了一把发现有些网友也碰到了类似的问题不过都还没有解决。<br>我是从 <a href="https://github.com/Doublemine/hexo-theme-next.git" target="_blank" rel="noopener">https://github.com/Doublemine/hexo-theme-next.git</a> 这里Fork下来的。仔细看了一下Fork下来的hexo-theme-next模板代码,尝试自己解决。</p><h2 id="问题现象："><a href="#问题现象：" class="headerlink" title="问题现象："></a>问题现象：</h2><p>URL乱码出现在两个地方，一个是上面的导航栏，一个是右边栏的“日志”菜单部分。<br>导航栏链接乱码问题<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200105/blogimage/blogerror1.png" alt="乱码" title="导航栏链接乱码问题"><br>右边栏的“日志”菜单部分链接乱码问题<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200105/blogimage/blogerror3.png" alt="乱码" title="右边栏的“日志”菜单部分"><br>发现链接后面都有乱码<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200105/blogimage/blogerror2.png" alt="乱码" title="链接乱码"></p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><h3 id="1-解决导航栏URL乱码"><a href="#1-解决导航栏URL乱码" class="headerlink" title="1.解决导航栏URL乱码"></a>1.解决导航栏URL乱码</h3><p>查看themes\hexo-theme-next\layout_partials 下面的 header.swig 代码和模板的配置文件 \themes\hexo-theme-next_config.yml，发现导航栏链接乱码是因为菜单配置是有空格造成的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;li class&#x3D;&quot;menu-item menu-item-&#123;&#123; itemName | replace(&#39; &#39;, &#39;-&#39;) &#125;&#125;&quot;&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;&#123;&#123; url_for(path.split(&#39;||&#39;)[0]) | trim &#125;&#125;&quot; rel&#x3D;&quot;section&quot;&gt;</span><br><span class="line">&#123;% if theme.menu_icons.enable %&#125;</span><br><span class="line">  &lt;i class&#x3D;&quot;menu-item-icon fa fa-fw fa-&#123;&#123; path.split(&#39;||&#39;)[1] | trim | default(&#39;question-circle&#39;) &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt; &lt;br &#x2F;&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;&#123; __(&#39;menu.&#39; + name) | replace(&#39;menu.&#39;, &#39;&#39;) &#125;&#125;</span><br><span class="line">  &lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure><p>因为url_for函数会将字符串转码，碰到空格或其他特殊字符会进行转意，就会出现乱码。<br>解决的办法是修改模板的配置文件 \themes\hexo-theme-next_config.yml文件去掉空格就是的。<br>原始配置文件配置如下：<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200105/blogimage/codeblock1.png" alt="原始配置文件" title="原始配置文件"><br>去掉链接字符串的空格<br><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200105/blogimage/codeblock2.png" alt="去掉空格后的配置文件" title="去掉空格后的配置文件"></p><h3 id="2-解决右边栏的“日志”菜单部分URL的乱码"><a href="#2-解决右边栏的“日志”菜单部分URL的乱码" class="headerlink" title="2.解决右边栏的“日志”菜单部分URL的乱码"></a>2.解决右边栏的“日志”菜单部分URL的乱码</h3><p>在 themes\hexo-theme-next\layout_macro 找到sidebar.swig 文件 找到如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if config.archive_dir !&#x3D; &#39;&#x2F;&#39; and site.posts.length &gt; 0 %&#125;</span><br><span class="line">  &lt;div class&#x3D;&quot;site-state-item site-state-posts&quot;&gt;</span><br><span class="line">  &#123;% if theme.menu.archives %&#125;</span><br><span class="line">&lt;a href&#x3D;&quot;&#123;&#123; url_for(theme.menu.archives).split(&#39;||&#39;)[0] | trim &#125;&#125;&quot;&gt;</span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">&lt;a href&#x3D;&quot;&#123;&#123; url_for(config.archive_dir) &#125;&#125;&quot;&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &lt;span class&#x3D;&quot;site-state-item-count&quot;&gt;&#123;&#123; site.posts.length &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;site-state-item-name&quot;&gt;&#123;&#123; __(&#39;state.posts&#39;) &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&#123;&#123; url_for(theme.menu.archives).split(&#39;||&#39;)[0] | trim &#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><p>修改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&#123;&#123; url_for(theme.menu.archives.split(&#39;||&#39;)[0]) | trim &#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><p>即可解决。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020是时候开启最棒的一年了！</title>
      <link href="/posts/ebb1fd51/"/>
      <url>/posts/ebb1fd51/</url>
      
        <content type="html"><![CDATA[<p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200105/blogimage/dream1.png" alt="2020是时候开启最棒的一年了！" title="2020是时候开启最棒的一年了！"></p><p>2019已经过去，回首过去你是否懊恼？本来计划要坚持每天跑步健身的，结果买好了装备坚持了几天后半途而废。雄心勃勃的每天阅读的计划也无疾而终。想把英语学好，却总是停留在书的前几页。我想成为最好的自己、想减肥健康、想多存钱少花钱、想学习新技能、想开创自己的事业……有很多美好的想法，但是事到如今只是美好的想法，回首往事时后悔不已，后悔没有正确的做出决定，后悔没有开始，后悔没有坚持。然而后悔又有什么用呢？岁月还是这样无情的流逝了，你还是原来的那个你。2020年，是时候开启最棒的一年了！</p><p>今年是突破之年！是很多人发自内心的渴望。人们都喜欢在新年制定目标。但是在实现目标的过程中，一开始我们斗志昂扬，大步向前，信心满满。但之后要么计划被打乱，要么最终不了了之。然后大多数人开始以一种失落和懊悔的心情诉说自己的遭遇的一次次挫折和失败。大部分的人都曾经在某些年份制定过新年目标。但是人人都制定目标，并不意味着总是有效。今年是突破之年吗？能够突破制定计划-失败-懊恼-制定计划的怪圈吗？能够真正的突破成就最好的自己吗？</p><p>今年必须是突破的一年！来自全球知名高效能专家迈克尔·海亚特的这本《规划最好的一年》。写给无力改变现状的你，让你从个人、职业、财富、人际关系等全面升级。如果你想摆脱失意与迷茫，走向自信与明朗，获得成功一年的力量。相信《规划最好的一年》一书中有你想要的答案。</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200105/blogimage/book1.png" alt="《规划最好的一年》" title="《规划最好的一年》"></p><p>作者迈克尔·海亚特（Michael Hyatt），是全球知名高效能专家，《纽约时报》畅销书作家。全球极具魅力的传媒领袖、平台应用大师、自媒体营销泰斗。曾任美国最大的出版公司之一托马斯·纳尔逊出版公司董事会主席、CEO。他创作过《生命向前》（与丹尼尔·哈卡维合著）以及《平台：从喧闹世界脱颖而出》，荣登过《华尔街日报》《福布斯》《快公司》《企业家》的封面人物。迈克尔·海亚特在美国开设有“5天即达最棒的一年”线上及线下课程，改变了逾千万美国年轻人的命运。</p><p>相信无论你有过什么好的或是不好的经历，即使是在你曾经深度受挫的领域，今年都绝对有可能成为你最有意义的一年。因为这本书告诉了你改变自己具体的做法。是时候开始最棒的一年了。</p><h2 id="STEP-1-相信可能"><a href="#STEP-1-相信可能" class="headerlink" title="STEP 1 相信可能"></a>STEP 1 相信可能</h2><p>要创造最好的一年，首先就要升级观念，树立自我开放性观念，相信一切皆有可能。</p><p>有益的思维习惯往往产生积极的结果，例如幸福感、个体满足感，甚至是物质上的成就。然而，不好的思维习惯往往会产生相反的结果：不幸福感、不满足感，甚至是时运不济的哀怨感。个人的生活格律可以由你改变。即使现有的思维习惯已经带来不错的成果，你还是可以通过升级自己的信念，在生活的各个领域体验变革性的个人进步。一旦我们开始关注信念升级，我们的境况往往也会随之改善。</p><p>如果一个人经历的挫折越多，就会越不相信自己能够战胜挫折。自我怀疑是目标的毒药。消极的心态会毒害我们的灵魂，破坏我们的未来。所以我们要升级观念，改变信念，相信自己能够完成目标。这是决定目标能够实现的第一个关键因素。</p><p>观念升级，避开自我设限性观念陷阱。相信你现在所拥有的，足以改变你的生活。不管现在处于什么环境，我们都有能力追求更好的未来。资源从来都不是我们实现目标过程中的主要挑战。</p><p><em>具体行动计划：</em></p><h3 id="1-认识信念的力量"><a href="#1-认识信念的力量" class="headerlink" title="1.认识信念的力量"></a>1.认识信念的力量</h3><p>如塞尔维亚维托夫尼卡的僧侣撒迪厄斯所言:“我们的想法决定我们的生活。”无论是积极的信念还是消极的信念，都会对生活经历产生巨大影响。明白这个事实，是进入最好的一年的第一阶段。 </p><h3 id="2-直面自我设限性观念"><a href="#2-直面自我设限性观念" class="headerlink" title="2.直面自我设限性观念"></a>2.直面自我设限性观念</h3><p>我们都会有对世界、他人、自己的自我设限性观念。四个检验你是否陷入自我设限性观念的指标，你的观点是否有以下思维形成:非黑即白、主观化、小题大做、普遍化。还有很重要的一点，就是要识别出自我设限性观念的来源，即你的自我设限性观念是来自过去的经验、新闻媒体、社交媒体还是负面关系。 </p><h3 id="3-观念升级-识别自我设限性观念。"><a href="#3-观念升级-识别自我设限性观念。" class="headerlink" title="3.观念升级 识别自我设限性观念。"></a>3.观念升级 识别自我设限性观念。</h3><p>升级观念要从认识观念开始，因此首先要仔细思考阻碍你前进的观念。记录自我设限性观念。在左边的一栏写下自我设限性观念，文字表达有助于将自我设限，性观念客观化。反思自我实现新观念。评估某种观念对你的贡献，这种观念赋予你力量了吗？对你实现目标有帮助吗？摒弃/重构自我设限性观念。有时候你可以直接否定一种自我设限性观念；有时候你可能需要论证推翻它，或是从另一个角度审视障碍。修正自我设限性观念。针对旧的自我设限性观念写下新的自我开放性观念。重新定位。相信新的真理，重新投入生活。</p><h2 id="STEP-2-总结过去"><a href="#STEP-2-总结过去" class="headerlink" title="STEP 2 总结过去"></a>STEP 2 总结过去</h2><p>通过后向思考总结过去，在遗憾中发现机会，以及利用感恩优势培养富足性思维。</p><p>人们都会陷入同样的困境，我们自己也在某种程度上处于这种困境中。除了自我设限性观念，第二个最常见的障碍就是过往的经历。我们把过去绑在身上，就像拖着一辆载满了破旧家具的拖车。因为我们太过受制于过去，所以才不能充分考虑未来。</p><p>如果不愿意承认过去，过去就不会完整。不管我们在过去的岁月里经历过什么，都必须处理这些经历。如果采取无视的态度，不好的事就会重现。如果不寻求解决办法，我们就会把过去遗留下来的东西带到未来，破坏我们对未来的精心设计。</p><p>不管我们有怎么样的过程，只要我们怀着感恩的心看待现在，就会发现我们所拥有的比想象中的要多得多。感恩能够放大生活中的一切美好事物。感恩是能够消除稀缺性思维，培养富足性思维的最好方法。</p><p><em>具体行动计划：</em></p><h3 id="1-事后回顾"><a href="#1-事后回顾" class="headerlink" title="1.事后回顾"></a>1.事后回顾</h3><p>事后回顾四个关键步骤：</p><ul><li>陈述理想结果</li></ul><p>首先问问自己，怎么看待过去的一年。你的计划是什么、梦想是什么，如果你有具体的目标，这些目标又是什么？要清楚自己的感受。</p><ul><li>承认实际结果</li></ul><p>在陈述理想结果时，你可能已经意识到了差距。理想与现实之间总是有距离的，你可能还有一些目标甚至很多目标没有实现。所以问问自己：你在过去的一年中有什么失意或遗憾？悔恨的意义不是让你奢求改变过去，而是让你更好地思考现在。问问自己：在过去的一年中，什么事情让你感到自豪？我们不仅要关注什么事情不成功，还要关注什么事情成功，分析是什么信念或行动带来了这种成功。这种分析对认识自己的力量及总结过去战胜困难的方法具有重要作用，同时也会增加我们对未来的信心。</p><ul><li>从经验中学习</li></ul><p>从经历中提炼经验教训，让经历成为前进的工具。</p><ul><li>调整行为</li></ul><p>如果是你的某种观念或行为造成了理想与实际结果之间的差距，那么是时候做出改变了。</p><h3 id="2-在遗憾中看到机会"><a href="#2-在遗憾中看到机会" class="headerlink" title="2.在遗憾中看到机会"></a>2.在遗憾中看到机会</h3><p>在回答:“你在过去一年中有什么失意或遗憾？”问题时采取积极补救措施的可能性越大，遗憾的感觉就越强烈。所以问问自己，你的遗憾中隐藏着什么机会。</p><h3 id="3-感恩练习"><a href="#3-感恩练习" class="headerlink" title="3.感恩练习"></a>3.感恩练习</h3><p>感恩不是一种情绪，而是一种行动，尝试一下三个练习:早晚自省；通过感激生活的恩赐，练习感恩；记感恩日记。</p><h2 id="STEP-3-设计未来"><a href="#STEP-3-设计未来" class="headerlink" title="STEP 3 设计未来"></a>STEP 3 设计未来</h2><p>学习如何根据SMART目标管理原则建立成就型目标与习惯性目标的最佳组合，以及为什么要在舒适区之外设立目标。</p><p>顺其自然不会本来非凡的成就随波逐流，不能达到想去的终点。我们只能有意识的去思考自己想要什么，为什么想要并根据目标制定行动方案，这一步在帮助我们清理自己的需要创造理想的生活，这也是乐趣的开始。</p><p><em>具体行动计划：</em></p><h3 id="1-设立目标"><a href="#1-设立目标" class="headerlink" title="1.设立目标"></a>1.设立目标</h3><p>每年设立7~10个目标，目标要满足smarter原则:明确性，可衡量性，可行性风险性，定时性，激励性，相关性，根据不同的生活领域制定相应的目标，将目标分散到各个季度，以保证注意力集中以及全年节奏稳定。</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200105/blogimage/smart1.png" alt="SMART法则" title="SMART法则"></p><h3 id="2-成就型与习惯性目标合理结合"><a href="#2-成就型与习惯性目标合理结合" class="headerlink" title="2.成就型与习惯性目标合理结合"></a>2.成就型与习惯性目标合理结合</h3><p>成就型目标代表一次完成的成就；习惯型目标代表持续且规律的行动。习惯型目标还可以是成就型目标的实现方式。两种类型的目标都对规划最好的一年有所帮助，但是我们要根据个人需求来平衡这两种目标。对我们有用的组合就是正确的组合。</p><h3 id="3-在不适区设立目标"><a href="#3-在不适区设立目标" class="headerlink" title="3.在不适区设立目标"></a>3.在不适区设立目标</h3><p>一个有意义的目标必须让我们提升自己。这就意味着我们必须离开舒适区。如果你明确知道一个目标应该怎么实现，那说明这个目标还太简单了。人生中所有重要的事都发生在舒适区之外。有意义的目标一定是处在不适区的。不适区的目标给我们带来挑战，让我们最大的发挥自己的能力。而恐慌区的目标可能导致失败，带来沮丧和失望。通常的做法是设立一个接近恐慌区的目标，然后再把它稍稍拖回来一些，处在学习区的目标是比较合适的。</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200105/blogimage/comfortzone.png" alt="舒适区三圈理论" title="舒适区三圈理论"></p><p>最好的是往往发生在我们不得不成长的时候。这在我们对未来一年的规划中是绝对真理，但这违反了我们规避风险的本能，以下4点将有助于我们克服阻力:</p><p>承认走出舒适区的价值。首先转变思维，只要你接受了挑战区的价值，接下来的事就简单多了。</p><p>直面痛苦。大多数阻碍来自我们的内心，但转变思维还不够，通过直面痛苦，我们改变的还有我们的意愿。</p><p>克服恐惧，负面情绪不可避免，不要无视负面情绪，你只需要将实现目标带来的成就感和负面情绪进行对比，是成就多，还是恐惧多？</p><p>避免过度分析。分析瘫痪是真实存在的，你不需要在开头就看到结尾，也不需要知道目标实现的整个过程，你只需要清楚自己下一步应该做什么。</p><h2 id="STEP-4-找到动力"><a href="#STEP-4-找到动力" class="headerlink" title="STEP 4 找到动力"></a>STEP 4 找到动力</h2><p>深入挖掘自己的内在动力，以及防止迷失自己的方法，与朋友同行。</p><p>切记，目标的设定必须明确、易于衡量、有章可循，且无太大风险，节点清晰、振奋人心，并与自己的生活息息相关。识别目标以及动机与目标相关联，给你的目标一个理由。这一点至关重要，因为我们注定会陷入泥沼。无论哪个梦想哪个目标、哪次尝试都逃脱不了这样的命运。我们有时会想，要是有更好的计划，到达终点的路便会少些痛苦、少些风雨。然而，往往事与愿违，要走出困境必须善加利用你的动机，只有这样才能获得动力与毅力，不畏险阻，不言放弃。</p><p><em>具体行动计划：</em></p><h3 id="1-回忆动机"><a href="#1-回忆动机" class="headerlink" title="1.回忆动机"></a>1.回忆动机</h3><p>从识别主要动机入手。你的初衷是什么？它对你来说为什么重要？找个本子，要不就拿出一张纸，一一列出主要动机。只列动机还远远不够，记得给他们排个序，把最好的理由写在前面。最后，用脑子去想，用心去体会。</p><h3 id="2-驾驭动机"><a href="#2-驾驭动机" class="headerlink" title="2.驾驭动机"></a>2.驾驭动机</h3><p>追逐目标的过程中，有4个方法能让我们坚持不懈:</p><p>（1）识别、憧憬未来。最终，事情本身便有了意义。</p><p>（2）要知道新习惯不是几个礼拜就能养成的，没准需要五六个月，所以别期望太高。</p><p>（3）游戏人生，请习惯使用一些养成软件和日历簿帮个忙。</p><p>（4）要衡量所得，而不是差距，珍视每个小的成就。</p><h3 id="3-组建团体"><a href="#3-组建团体" class="headerlink" title="3.组建团体"></a>3.组建团体</h3><p>若是有朋友同行，目标的实现便会容易不少。主动交朋友给了成功4个好处:学习、鼓励、责任、竞争，至少有7种朋友能够帮你成长，帮你实现目标:网络社区，跑步健身社区，交流社区，指导性社交圈，读书学习小组，责任小组，好朋友，若是找不到合适的团体，千万别犹豫，干脆自己建一个吧。</p><h2 id="STEP-5-付诸实践"><a href="#STEP-5-付诸实践" class="headerlink" title="STEP 5 付诸实践"></a>STEP 5 付诸实践</h2><p>规划是基础，行动才是关键。将目标付诸实现，勇于行动，全方位升级！</p><p>伟大并非来自一次冲动，而是由一系列小时汇集而成。确定目标是成功的一半，成功的另一半在于采取行动。</p><p><em>具体行动计划：</em></p><h3 id="1-将总目标分解为可执行的后续步骤"><a href="#1-将总目标分解为可执行的后续步骤" class="headerlink" title="1.将总目标分解为可执行的后续步骤"></a>1.将总目标分解为可执行的后续步骤</h3><p>设立目标在舒适区之外考虑，执行目标从舒适区开始。先完成最简单的任务，遇到困难的时候寻求外界帮助。快速取得初步成功能为后续行动带来动力。</p><h3 id="2-运动触发器"><a href="#2-运动触发器" class="headerlink" title="2.运动触发器"></a>2.运动触发器</h3><p>找到最有效的激活事件。利用杠杆效应，借助简单的任务完成困难的任务。不要依靠自己的即时自控力，通过清除诱惑、自动化、委托授权来优化触发器。</p><p>我们在追求目标的过程中，会遇到干扰事项，所以要预测干扰，预置回应。关键就是在被干扰事项打乱计划之前，先想好应对策略，如果应对策略效果不佳，则调整到满意为止。</p><h3 id="3-安排定期目标回顾"><a href="#3-安排定期目标回顾" class="headerlink" title="3.安排定期目标回顾"></a>3.安排定期目标回顾</h3><p>每日浏览目标列表，确保心中有目标，并在浏览时思考当天的具体任务，也就是“每日三大事”。</p><p>在每周回顾中重点关注主要动机对前一周的任务进展进行一次快速的事后回顾，审查每个目标的后续步骤，并确定接下来一周必须取得的三个成果，也就是“每周三大事”。用“每周三大事”指导“每日三大事”。</p><p>在季度回顾时，建议重新走一遍“5步实现新年目标”流程。重点如下:</p><p>如果已经取得完全或阶段性的胜利，就庆祝自己的胜利；</p><p>如果还没有取得任何形式的胜利，就重新开始追求目标；</p><p>如果不能重新开始，就修改目标；</p><p>如果不能修改，就删除目标；</p><p>用新目标替代被删除的目标。</p><p><em>不要拖着你的梦想。不要拖着你的目标。今日事今日毕，你的生活和工作才能有所起色。一旦下定决心，就行动起来。2020必须是突破的一年！</em></p><hr><center>关注：“爱分享读书”微信公众号 </center><p><img src="http://image.ishareread.com/qrcode_for_gh_70fb5d85a824_258.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><center>读书我们是认真的</center>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107/"/>
      <url>/posts/16107/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
