<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XieJava&#39;s blog</title>
  
  <subtitle>记录最好的自己</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiejava.ishareread.com/"/>
  <updated>2020-12-04T09:02:55.987Z</updated>
  <id>http://xiejava.ishareread.com/</id>
  
  <author>
    <name>XieJava</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020-12-04-网络信息安全管理要素和安全风险评估</title>
    <link href="http://xiejava.ishareread.com/posts/8a1fa561/"/>
    <id>http://xiejava.ishareread.com/posts/8a1fa561/</id>
    <published>2020-12-04T08:41:52.000Z</published>
    <updated>2020-12-04T09:02:55.987Z</updated>
    
    <content type="html"><![CDATA[<p>网络信息安全管理要素由网络管理对象、网络威胁、网络脆弱性、网络风险、网络保护措施组成。<br><img src="https://img-blog.csdnimg.cn/20201204163036136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="网络信息安全管理要素"><br>由于网络管理对象自身的脆弱性，使得威胁的发生成为可能，从而造成了不同的影响，形成了风险。</p><p>网络安全管理实际上就是风险控制，其基本过程是通过网络管理对象的威胁和脆弱性进行分析，确定网络管理对象的价值、网络管理对象威胁发生的可能性、网络管理对象的脆弱程度，从而确定网络管理对象的风险等级，然后据此选取合适的安全保护措施，降低网络管理对象的风险。</p><p>所有的安全管理、安全服务、安全技术等都是围绕网络信息安全管理要素来的。</p><p>网络安全风险评估是评价网络信息系统遭受潜在的安全威胁所产生的影响。</p><p>网络安全风险，是指由于网络系统所存在的脆弱性，因人为或自然的威胁导致安全事件发生所造成的可能性。网络风险评估就是评估威胁者利用网络资产的脆弱性，造成网络资产损失的严重程度。</p><p>网络安全风险评估过程，主要包括网络安全风险评估准备、资产识别、威胁识别、脆弱性识别、已有的安全措施分析、网络安全风险分析、网络安全风险处置与管理等。<br><img src="https://img-blog.csdnimg.cn/20201204163226746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="网络安全风险评估过程"><br><strong>资产识别</strong>包含“网络资产鉴定”和“网络资产价值估算”。前者给出评估所考虑的具体对象，确认网络资产种类和清单，是整个评估工作的基础。常见的网络资产主要分为网络设备、主机、服务器、应用、数据和文档资产等六个方面。</p><p>“网络资产价值估算”是某一具体资产在网络系统中的重要程度确认。</p><p>威胁是指可能对评估对象造成损害的外部原因。威胁利用评估对象自身的脆弱性，采用一定的途径和方式，对评估对象造成损害或损失，从而形成风险，<strong>威胁识别</strong>是对网络资产有可能受到的安全危害进行分析，一般从威胁来源、威胁途径、威胁意图等几个方面来分析。</p><p>脆弱性是指评估对象存在一个或多个脆弱的管理、技术、业务方面的漏洞，这些漏洞可能会被威胁所利用。<strong>脆弱性识别</strong>是指通过各种测试方法，获得网络资产中所存在的缺陷清单，这些缺陷会导致对信息资产的非授权访问、泄密、失控、破坏或不可用、绕过已有的安全机制，缺陷的存在将会危及网络资产的安全。</p><table><thead><tr><th>任务</th><th>输出文档</th><th>文档内容</th></tr></thead><tbody><tr><td>风险评估准备</td><td>会议记录并确认需要评估的系统、评估计划和评估程序</td><td>评估系统、评估计划和内容安排，双方负责人及需要明确的协调工作</td></tr><tr><td>访谈</td><td>针对业务系统进行技术安全和管理安全评估的访谈表</td><td>业务系统描述、运营情况和用户群体，并了解业务管理流程</td></tr><tr><td>文档审查（资产识别）</td><td>资产审查记录和业务系统审查记录</td><td>资产管理台账、网络拓扑图、业务运营管理制度和责任人</td></tr><tr><td>威胁识别</td><td>技术安全测评的网络、主机、应用测评结果记录，工具测试完成后的电子输出记录</td><td>漏洞扫描、渗透性测试、性能测试、入侵检测和协议分析等内容的技术测试结果</td></tr><tr><td>脆弱性识别</td><td>根据威胁识别结果，技术安全测评的网络、主机、应用测评</td><td>检查检查内容的记录，并根据威胁对业务系统脆弱性进行识别</td></tr><tr><td>风险处置</td><td>风险处置措施记录</td><td>对已识别的风险进行评估和处置，并评估是否存在残余风险</td></tr><tr><td>风险管理</td><td>对可接受的残余风险进行风险管理并出具风险评估报告</td><td>风险评估过程中发现的问题、问题的证据和证据源、每项检查活动中测评委托单位配合人员的书面认可</td></tr></tbody></table><p>网络安全风险分析是指在资产评估、威胁评估、脆弱性评估、安全管理评估、安全影响评估的基础上，综合利用定性和定量的分析方法，选择适当的风险计算方法或工具确定风险的大小与风险等级，即对网络系统安全管理范围内的每一个网络资产因遭受泄露、修改、不可用和破坏所带来的任何影响做出一个风险测量的列表，以便识别与选择适当和正确的安全控制方式。通过分析所评估的数据，进行风险值计算。</p><p><img src="https://img-blog.csdnimg.cn/20201204163838552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="网络安全风险分析"><br>网络安全风险分析的主要步骤如下：<br>一、对资产进行识别，并对资产的价值进行赋值。<br>二、对威胁进行识别，描述威胁的属性，并对威胁出现的频率赋值。<br>三、对脆弱性进行识别，并对具体资产的脆弱性的严重程度赋值。<br>四、根据威胁及威胁利用脆弱性的难易程度判断安全事件发生的可能性<br>五、根据脆弱性的严重程度及安全事件所作用的资产价值计算安全事件的损失。<br>六、根据安全事件发生的可能性及安全事件出现后的损失，计算安全事件一旦发生对组织的影响，即网络安全风险值。其中，安全事件损失是指确定已经鉴定的资产受到损害所带来的影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网络信息安全管理要素由网络管理对象、网络威胁、网络脆弱性、网络风险、网络保护措施组成。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204163036136.png?x-oss-process=image/watermark,
      
    
    </summary>
    
    
      <category term="网络安全" scheme="http://xiejava.ishareread.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="网络安全" scheme="http://xiejava.ishareread.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>pyinstaller打包exe后不能运行报Failed to execute script XXXX问题分析与处理</title>
    <link href="http://xiejava.ishareread.com/posts/19a32f6f/"/>
    <id>http://xiejava.ishareread.com/posts/19a32f6f/</id>
    <published>2020-11-03T09:16:00.000Z</published>
    <updated>2020-12-02T01:00:49.781Z</updated>
    
    <content type="html"><![CDATA[<p>最近用python的tkinter写了个小工具，发现用pyinstaller打包成exe后运行出错。报Failed to execute script XXXX</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F -w worksubmit.py</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201101171716408.png#pic_center" alt="报错"><br>为了搞清楚报错的原因，想看到程序具体执行的情况。可以通过不带-w的参数打包在控制台看程序执行情况。<br><code>pyinstaller -F worksubmit.py</code> 可以通过不带-w的参数打包，这时打包的exe运行是带控制台的命令行<br><img src="https://img-blog.csdnimg.cn/20201101172133371.png#pic_center" alt="运行情况"><br>可以清楚的看到</p><blockquote><p>ModuleNotFoundError:No module named ‘xlrd’</p></blockquote><p>这时就要解决打包时xlrd模块没有打进去的问题，找到xlrd模块的位置，并将该模块打到运行程序包里。<br>先找到程序依赖的xlrd模块的位置，在PyCharm中通过”File”-&gt;”Setting”,在项目设置里查看Project interpreter，可以看到xlrd的目录位置。<br><img src="https://img-blog.csdnimg.cn/20201101172227853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70#pic_center" alt="找包路径"></p><p>用pyinstall打包的时候通过加-p的参数将依赖的模块打进去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F -p J:\study\python\testsubmit\venv\Lib\site-packages worksubmit.py</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201101172053955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这样就可以顺利将依赖的模块打进去，再执行exe文件不再报错了。</p><p><strong>总结一下，碰到打包成exe后运行有问题，可以通过不带-w的参数打包，这时打包的exe运行是带控制台的命令行。基本上所有的运行问题都可以通过控制台的命令定位和排查。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近用python的tkinter写了个小工具，发现用pyinstaller打包成exe后运行出错。报Failed to execute script XXXX&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
      <category term="技术" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="开发" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="http://xiejava.ishareread.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>等级保护与分级保护的关系和区别</title>
    <link href="http://xiejava.ishareread.com/posts/dc4d08f1/"/>
    <id>http://xiejava.ishareread.com/posts/dc4d08f1/</id>
    <published>2020-10-24T08:35:36.000Z</published>
    <updated>2020-12-04T08:57:45.252Z</updated>
    
    <content type="html"><![CDATA[<p>等级保护与分级保护既有联系又有区别：</p><p>国家安全信息等级保护，重点保护的对象是非涉密的涉及国计民生的重要信息系统和通信基础信息系统；涉密信息系统分级保护是国家信息安全等级保护的重要组成部分，是等级保护在涉密领域的具体体现。</p><p>国家安全信息等级保护重点保护的对象是涉及国计民生的重要信息系统和通信基础信息系统，而不论它是否涉密。涉密信息系统分级保护保护的对象是所有涉及国家秘密的信息系统，重点是党政机关、军队和军工单位，由各级保密工作部门根据涉密信息系统的保护等级实施监督管理，确保系统和信息安全，确保国家秘密不被泄漏。</p><p>国家信息安全等级保护是国家从整体上、根本上解决国家信息安全问题的办法,进一步确定了信息安全发展的主线和中心任务,提出了总体要求。对信息系统实行等级保护是国家法定制度和基本国策，是开展信息安全保护工作的有效办法，是信息安全保护工作的发展方向。而涉密信息系统分级保护则是国家信息安全等级保护在涉及国家秘密信息的信息系统中的特殊保护措施与方法。</p><p><strong>等级保护与分级保护本质的区别是等级保护适用的对象为非涉密信息系统，分级保护适用的对象为涉密信息系统。</strong></p><p>具体区别如下：</p><table><thead><tr><th>项目</th><th>等级保护</th><th>分级保护</th></tr></thead><tbody><tr><td>管理体系</td><td>公安机关</td><td>国家保密部门</td></tr><tr><td>标准体系</td><td>国家标准（GB、GB/T）</td><td>国家保密标准（BMB，强制执行）</td></tr><tr><td>适用对象</td><td>非涉密信息系统</td><td>涉密信息系统</td></tr><tr><td>定级依据</td><td>等级保护定级是依据重要业务系统与承载业务运行的网络、设备、系统及单位属性、遭到破坏后所影响的主、客体关系等。</td><td>分级保护定级是依据信息的重要性，以信息最高密级确定受保护的级别。</td></tr><tr><td>级别划分</td><td>第一级：自主保护级<br>第二级：指导保护级<br>第三极：监督保护级<br>第四级：强制保护级<br>第五级：专控保护级</td><td>秘密级<br>机密级<br>绝密级</td></tr><tr><td>工作内容</td><td>信息系统等级保护工作包括：<br>系统定级、系统备案、安全建设整改、等级测评和监督检查五个环节。</td><td>涉密信息系统分级保护工作包括:<br>系统定级、方案设计、工程实施、系统测评、系统审批、日常管理、测评与检查和系统废止八个环节。</td></tr><tr><td>测评频率</td><td>第三级信息系统：应每年至少进行一次等级测评；<br>第四级信息系统：应每年至少进行一次等级测评；<br>第五级信息系统：应当根据特殊安全要求进行等级测评。</td><td>秘密级、机密级信息系统：应每两年至少进行一次安全保密测评或保密检查；<br>绝密级信息系统：应每年至少进行一次安全保密测评或保密检查。</td></tr><tr><td>评测机构</td><td>国家信息安全等级保护工作协调小组办公室授权的信息安全等级保护测评机构</td><td>由国家保密工作部门授权的系统测评机构</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;等级保护与分级保护既有联系又有区别：&lt;/p&gt;
&lt;p&gt;国家安全信息等级保护，重点保护的对象是非涉密的涉及国计民生的重要信息系统和通信基础信息系统；涉密信息系统分级保护是国家信息安全等级保护的重要组成部分，是等级保护在涉密领域的具体体现。&lt;/p&gt;
&lt;p&gt;国家安全信息等级保护重点
      
    
    </summary>
    
    
      <category term="网络安全" scheme="http://xiejava.ishareread.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="网络安全" scheme="http://xiejava.ishareread.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Supervisor离线安装及使用</title>
    <link href="http://xiejava.ishareread.com/posts/d670c9b8/"/>
    <id>http://xiejava.ishareread.com/posts/d670c9b8/</id>
    <published>2020-05-18T03:35:36.000Z</published>
    <updated>2020-05-18T03:39:02.356Z</updated>
    
    <content type="html"><![CDATA[<p>Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警</p><p>supervisor的安装有多种方式<br>配置好yum源后，可以直接安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install supervisor</span><br></pre></td></tr></table></figure><p>Debian/Ubuntu可通过apt安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install supervisor</span><br></pre></td></tr></table></figure><p>pip安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure><p>easy_install安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install</span><br></pre></td></tr></table></figure><p>这几种安装方式都需要在线联网。但大部分的生产环境都是离线环境，是封闭的网络没有办法在线安装。</p><p>这里整理了Supervisor的离线安装包和安装脚本，可以进行离线安装并能指定安装目录。</p><h1 id="一、整理Supervisor安装需要的工具和依赖包"><a href="#一、整理Supervisor安装需要的工具和依赖包" class="headerlink" title="一、整理Supervisor安装需要的工具和依赖包"></a>一、整理Supervisor安装需要的工具和依赖包</h1><p>包括有：<br>setuptools<br>elementtree<br>meld3<br>supervisor</p><h1 id="二、编写离线安装脚本"><a href="#二、编写离线安装脚本" class="headerlink" title="二、编写离线安装脚本"></a>二、编写离线安装脚本</h1><p>整体思路：依次解压并安装Supervisor所需要的工具和依赖包，将Supervisor的配置文件的默认安装目录路径替换成制定的目录路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi install_supervisor.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="keyword">function</span> Install_Supervisor()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">#Install supervisord</span></span><br><span class="line">    tar -zxvf setuptools-24.0.2.tar.gz 2&gt;&amp;1 &gt;/dev/null</span><br><span class="line">    <span class="built_in">cd</span> setuptools-24.0.2/</span><br><span class="line">    python setup.py install &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">    <span class="built_in">cd</span> ..</span><br><span class="line">    easy_install elementtree-1.2.7-20070827-preview.zip &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">    easy_install meld3-0.6.5.tar.gz 2&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">    easy_install supervisor-3.3.0.tar.gz &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">    mkdir -p <span class="variable">$&#123;INSTALL_DIR&#125;</span>/etc/</span><br><span class="line">    mkdir -p <span class="variable">$&#123;INSTALL_DIR&#125;</span>/tmp/</span><br><span class="line">    mkdir -p <span class="variable">$&#123;INSTALL_DIR&#125;</span>/logs/</span><br><span class="line">    cp etc/supervisord.conf <span class="variable">$&#123;INSTALL_DIR&#125;</span>/etc/</span><br><span class="line">    sed -i <span class="string">"s#__install_dir__#<span class="variable">$&#123;INSTALL_DIR&#125;</span>#g"</span> <span class="variable">$&#123;INSTALL_DIR&#125;</span>/etc/supervisord.conf</span><br><span class="line">    sed -i <span class="string">"s#__user__#<span class="variable">$&#123;USER&#125;</span>#g"</span> <span class="variable">$&#123;INSTALL_DIR&#125;</span>/etc/supervisord.conf</span><br><span class="line">    ln -s /usr/bin/supervisorctl <span class="variable">$&#123;INSTALL_DIR&#125;</span>/commandctl</span><br><span class="line">    cp run_supervisor.sh <span class="variable">$&#123;INSTALL_DIR&#125;</span>/</span><br><span class="line">    sed -i <span class="string">"s#__install_dir__#<span class="variable">$&#123;INSTALL_DIR&#125;</span>#g"</span> <span class="variable">$&#123;INSTALL_DIR&#125;</span>/run_supervisor.sh</span><br><span class="line">    chmod +x <span class="variable">$&#123;INSTALL_DIR&#125;</span>/run_supervisor.sh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">USER=<span class="string">'root'</span></span><br><span class="line"><span class="keyword">if</span> [ ! -n <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">   INSTALL_DIR=<span class="string">'/app/supervisor'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   INSTALL_DIR=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">Install_Supervisor</span><br></pre></td></tr></table></figure><p>安装脚本中默认的安装路径是/app/supervisor，可以根据实际情况进行调整。</p><p>另外整理了一个run_supervisor.sh的脚本，在安装以后根据安装目录来生成这个启动脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">cd</span> __install_dir__</span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"tmp"</span> ];<span class="keyword">then</span></span><br><span class="line">  mkdir tmp</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"tmp文件夹已经存在"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"logs"</span> ];<span class="keyword">then</span></span><br><span class="line">  mkdir logs</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"logs文件夹已经存在"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">/usr/bin/supervisord -c __install_dir__/etc/supervisord.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"supervisord 已执行。"</span></span><br></pre></td></tr></table></figure><h1 id="三、将所有的安装包脚本等打成离线安装包"><a href="#三、将所有的安装包脚本等打成离线安装包" class="headerlink" title="三、将所有的安装包脚本等打成离线安装包"></a>三、将所有的安装包脚本等打成离线安装包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf  supervisor_install_pack.tar.gz  supervisor</span><br></pre></td></tr></table></figure><p>已打好的离线安装包下载 <a href="https://545c.com/file/21165215-443895501" target="_blank" rel="noopener">https://545c.com/file/21165215-443895501</a><br><a href="https://545c.com/file/21165215-443895501" target="_blank" rel="noopener">城通网盘下载</a>   <a href="https://545c.com/file/21165215-443895501" target="_blank" rel="noopener">https://545c.com/file/21165215-443895501</a><br><a href="https://download.csdn.net/download/fullbug/12434225" target="_blank" rel="noopener">CSDN下载</a> <a href="https://download.csdn.net/download/fullbug/12434225" target="_blank" rel="noopener">https://download.csdn.net/download/fullbug/12434225</a></p><h1 id="四、离线安装包使用"><a href="#四、离线安装包使用" class="headerlink" title="四、离线安装包使用"></a>四、离线安装包使用</h1><p>下载离线安包，解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf supervisor_install_pack.tar.gz</span><br></pre></td></tr></table></figure><p>解压后看到supervisor的目录，在supervisor的目录中找到install_supervisor.sh的脚本<br><img src="https://img-blog.csdnimg.cn/20200518111602385.png" alt="supervisor离线包安装目录"><br>执行install_supervisor.sh的脚本，默认安装/app/supervisor下，可以带参数指定安装目录。也可以修改install_supervisor.sh脚本自定义默认的安装路径。<br>执行完安装脚本，就可以在/app/supervisor目录下看到有相应的启动脚本、配置文件目录、日志目录及临时文件目录。<br><img src="https://img-blog.csdnimg.cn/20200518111653544.png" alt="supervisor运行目录"><br>执行run_supervisor.sh就可以启动supervisor</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run_supervisor.sh</span><br></pre></td></tr></table></figure><h1 id="五、验证和使用supervisor"><a href="#五、验证和使用supervisor" class="headerlink" title="五、验证和使用supervisor"></a>五、验证和使用supervisor</h1><p>ps -ef|grep supervisor  查看supervisor是否已经启动<br><img src="https://img-blog.csdnimg.cn/20200518111736457.png" alt="查看supervisor是否已经启动"><br>通过web界面的9001看web界面控制台<a href="http://127.0.0.1:9001" target="_blank" rel="noopener">http://127.0.0.1:9001</a><br><img src="https://img-blog.csdnimg.cn/20200518111807123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="web界面控制台"></p><ul><li>supervisord<br>运行 Supervisor 时会启动一个进程 supervisord，它负责启动所管理的进程，并将所管理的进程作为自己的子进程来启动，而且可以在所管理的进程出现崩溃时自动重启。<br>supervisord -v 查看supervisor版本号</li><li>supervisorctl<br>是命令行管理工具，可以用来执行 stop、start、restart 等命令，来对这些子进程进行管理。<br>supervisor是所有进程的父进程，管理着启动的子进展，supervisor以子进程的PID来管理子进程，当子进程异常退出时supervisor可以收到相应的信号量。</li></ul><p><strong>supervisor常用管理命令</strong><br>supervisorctl restart &lt; application name&gt; ;重启指定应用<br>supervisorctl stop &lt; application name&gt; ;停止指定应用<br>supervisorctl start &lt; application name&gt; ;启动指定应用<br>supervisorctl restart all ;重启所有应用<br>supervisorctl stop all ;停止所有应用<br>supervisorctl start all ;启动所有应用</p><h1 id="六、配置文件说明"><a href="#六、配置文件说明" class="headerlink" title="六、配置文件说明"></a>六、配置文件说明</h1><h2 id="supervisor-conf配置文件"><a href="#supervisor-conf配置文件" class="headerlink" title="supervisor.conf配置文件"></a>supervisor.conf配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ;UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">;chmod=0700                 ;socket文件的mode，默认是0700</span><br><span class="line">;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid</span><br><span class="line"> </span><br><span class="line">;[inet_http_server]         ;HTTP服务器，提供web管理界面</span><br><span class="line">;port=127.0.0.1:9001        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span><br><span class="line">;username=user              ;登录管理后台的用户名</span><br><span class="line">;password=123               ;登录管理后台的密码</span><br><span class="line"> </span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.log ;日志文件，默认是 <span class="variable">$CWD</span>/supervisord.log</span><br><span class="line">logfile_maxbytes=50MB        ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span><br><span class="line">logfile_backups=10           ;日志文件保留备份数量默认10，设为0表示不备份</span><br><span class="line">loglevel=info                ;日志级别，默认info，其它: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ;pid 文件</span><br><span class="line">nodaemon=<span class="literal">false</span>               ;是否在前台启动，默认是<span class="literal">false</span>，即以 daemon 的方式启动</span><br><span class="line">minfds=1024                  ;可以打开的文件描述符的最小值，默认 1024。注意托管ES进程，这里要进行调整至65535</span><br><span class="line">minprocs=200                 ;可以打开的进程数的最小值，默认 200。注意托管ES进程，这里要进行调整至4096</span><br><span class="line"> </span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span><br><span class="line">;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span><br><span class="line"> </span><br><span class="line">; [program:xx]是被管理的进程配置参数，xx是进程的名称</span><br><span class="line">[program:xx]</span><br><span class="line"><span class="built_in">command</span>=/opt/apache-tomcat-8.0.35/bin/catalina.sh run  ; 程序启动命令</span><br><span class="line">autostart=<span class="literal">true</span>       ; 在supervisord启动的时候也自动启动</span><br><span class="line">startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span><br><span class="line">autorestart=<span class="literal">true</span>     ; 程序退出后自动重启,可选值：[unexpected,<span class="literal">true</span>,<span class="literal">false</span>]，默认为unexpected，表示进程意外杀死后才重启</span><br><span class="line">startretries=3       ; 启动失败自动重试次数，默认是3</span><br><span class="line">user=tomcat          ; 用哪个用户启动进程，默认是root</span><br><span class="line">priority=999         ; 进程启动优先级，默认999，值小的优先启动</span><br><span class="line">redirect_stderr=<span class="literal">true</span> ; 把stderr重定向到stdout，默认<span class="literal">false</span></span><br><span class="line">stdout_logfile_maxbytes=20MB  ; stdout 日志文件大小，默认50MB</span><br><span class="line">stdout_logfile_backups = 20   ; stdout 日志文件备份数，默认是10</span><br><span class="line">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class="line">stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.out</span><br><span class="line">stopasgroup=<span class="literal">false</span>     ;默认为<span class="literal">false</span>,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span><br><span class="line">killasgroup=<span class="literal">false</span>     ;默认为<span class="literal">false</span>，向进程组发送<span class="built_in">kill</span>信号，包括子进程</span><br><span class="line"> </span><br><span class="line">;包含其它配置文件</span><br><span class="line">[include]</span><br><span class="line">files = supervisord.d/*.ini    ;默认放在安装目录的supervisord.d目录下，可以指定一个或多个以.ini结束的配置文件。</span><br></pre></td></tr></table></figure><h2 id="子进程配置文件"><a href="#子进程配置文件" class="headerlink" title="子进程配置文件"></a>子进程配置文件</h2><p>需要给托管的子进程配置相应的配置文件，每个进程的配置文件都可以单独分拆也可以把相关的脚本放一起。目录及文件后缀可以在<br>supervisor.conf配置文件中进行自定义。见supervisor.conf的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">files = supervisord.d/*.ini  <span class="comment">#目录路径及文件后缀名都可以自定义。</span></span><br></pre></td></tr></table></figure><p>logstash.ini 样例说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#项目名</span></span><br><span class="line">[program:logstash-test]</span><br><span class="line"><span class="comment">#脚本目录</span></span><br><span class="line">directory=/app/elk/logstash-7.6.0</span><br><span class="line"><span class="comment">#脚本执行命令</span></span><br><span class="line"><span class="built_in">command</span>=/app/elk/logstash-7.6.0/bin/logstash -f /app/elk/logstash-7.6.0/bin/<span class="built_in">test</span>-pipeline.conf</span><br><span class="line"><span class="comment">#进程数</span></span><br><span class="line">numprocs=1</span><br><span class="line"><span class="comment">#supervisor启动的时候是否随着同时启动，默认True</span></span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line"><span class="comment">#当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的</span></span><br><span class="line">autorestart=<span class="literal">false</span></span><br><span class="line"><span class="comment">#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1</span></span><br><span class="line">startsecs=1</span><br><span class="line"><span class="comment">#脚本运行的用户身份 </span></span><br><span class="line">user = root</span><br><span class="line"><span class="comment">#把stderr重定向到stdout，默认 false</span></span><br><span class="line">redirect_stderr = <span class="literal">true</span></span><br><span class="line"><span class="comment">#stdout日志文件大小，默认 50MB</span></span><br><span class="line">stdout_logfile_maxbytes = 10M</span><br><span class="line"><span class="comment">#stdout日志文件备份数</span></span><br><span class="line">stdout_logfile_backups = 10</span><br><span class="line"><span class="comment">#日志输出 </span></span><br><span class="line">stderr_logfile=/app/elk/logstash-7.6.0/logs/logstash_test_error.log</span><br><span class="line">stdout_logfile=/app/elk/logstash-7.6.0/logs/logstash_test_out.log</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配
      
    
    </summary>
    
    
      <category term="技术" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="开发" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="运维" scheme="http://xiejava.ishareread.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>logstash简明实用教程</title>
    <link href="http://xiejava.ishareread.com/posts/a59d6c21/"/>
    <id>http://xiejava.ishareread.com/posts/a59d6c21/</id>
    <published>2020-04-14T08:35:26.000Z</published>
    <updated>2020-04-14T08:52:46.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、logstash是什么"><a href="#一、logstash是什么" class="headerlink" title="一、logstash是什么"></a>一、logstash是什么</h1><p>Logstash 是开源的服务器端<strong>数据处理管道</strong>，能够同时从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的“存储库”中。<br>官方介绍：Logstash is an open source data collection engine with real-time pipelining capabilities。简单来说logstash就是一根具备实时数据传输能力的管道，负责将数据信息从管道的输入端传输到管道的输出端；与此同时这根管道还可以让你根据自己的需求在中间加上滤网，Logstash提供里很多功能强大的滤网以满足你的各种应用场景。<br>Logstash 能够动态地采集、转换和传输数据，不受格式或复杂度的影响。利用 Grok 从非结构化数据中派生出结构，从 IP 地址解码出地理坐标，匿名化或排除敏感字段，并简化整体处理过程。</p><p>Logstash常用于日志关系系统中做日志采集设备；<br><img src="https://img-blog.csdnimg.cn/20200414152706269.png" alt="logstash"><br>系统结构<br><img src="https://img-blog.csdnimg.cn/20200414153844982.png" alt="logstash系统结构"><br>Logstash的事件（logstash将数据流中等每一条数据称之为一个event）处理流水线有三个主要角色完成：<strong>inputs –&gt; filters –&gt; outputs</strong>：</p><p><strong>输入（inpust）</strong>：必须，负责产生事件（Inputs generate events），常用：File、syslog、redis、beats（如：Filebeats）<br>Logstash 支持 各种输入选择 ，可以在同一时间从众多常用来源捕捉事件。能够以连续的流式传输方式，轻松地从日志、指标、Web 应用、数据存储以及各种 AWS 服务采集数据。</p><p><strong>过滤器（filters）</strong>：可选，负责数据处理与转换（filters modify them），常用：grok、mutate、drop、clone、geoip<br>过滤器能实时解析和转换数据<br>数据从源传输到存储库的过程中，Logstash 过滤器能够解析各个事件，识别已命名的字段以构建结构，并将它们转换成通用格式，以便更轻松、更快速地分析和实现商业价值。</p><ul><li>利用 Grok 从非结构化数据中派生出结构 </li><li>从 IP 地址破译出地理坐标 </li><li>将 PII 数据匿名化，完全排除敏感字段</li><li>简化整体处理，不受数据源、格式或架构的影响</li></ul><p><strong>输出（outpus）</strong>：必须，负责数据输出（outputs ship them elsewhere），常用：elasticsearch、file、graphite、statsd<br>Logstash 提供众多输出选择，可以将数据发送到指定的地方，并且能够灵活地解锁众多下游用例</p><p>其中inputs和outputs支持codecs（coder&amp;decoder）在1.3.0 版之前，logstash 只支持纯文本形式输入，然后以过滤器处理它。但现在，我们可以在输入 期处理不同类型的数据，所以完整的数据流程应该是：input | decode | filter | encode | output；codec 的引入，使得 logstash 可以更好更方便的与其他有自定义数据格式的运维产品共存，比如：graphite、fluent、netflow、collectd，以及使用 msgpack、</p><h1 id="二、为什么是logstash"><a href="#二、为什么是logstash" class="headerlink" title="二、为什么是logstash"></a>二、为什么是logstash</h1><p><strong>Logstash和Flume对比</strong><br>1、Logstash比较偏重于字段的预处理，在异常情况下可能会出现数据丢失，只是在运维日志场景下，一般认为这个可能不重要；而Flume偏重数据的传输，几乎没有数据的预处理，仅仅是数据的产生，封装成event然后传输；传输的时候flume比logstash多考虑了一些可靠性。因为数据会持久化在channel中，数据只有存储在下一个存储位置（可能是最终的存储位置，如HDFS；也可能是下一个Flume节点的channel），数据才会从当前的channel中删除。这个过程是通过事务来控制的，这样就保证了数据的可靠性。<br>2、Logstash有几十个插件，配置比较灵活，flume强调用户自定义开发；<br>3、Logstash的input和filter还有output之间都存在buffer，进行缓冲；Flume直接使用channel做持久化<br>4、Logstash性能以及资源消耗比较严重，且不支持缓存；<br><img src="https://img-blog.csdnimg.cn/20200414154043951.png" alt="Logstash和Flume对比"><br>详见参考：<a href="https://blog.csdn.net/songfeihu0810232/article/details/94406608" target="_blank" rel="noopener">https://blog.csdn.net/songfeihu0810232/article/details/94406608</a></p><h1 id="三、logstash安装与配置"><a href="#三、logstash安装与配置" class="headerlink" title="三、logstash安装与配置"></a>三、logstash安装与配置</h1><h2 id="1、logstash安装"><a href="#1、logstash安装" class="headerlink" title="1、logstash安装"></a>1、logstash安装</h2><p>环境要求：jdk1.8或以上<br>下载logstash软件包  logstash官方下载地址<a href="https://www.elastic.co/cn/downloads/logstash" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/logstash</a><br>下载后直接解压就可以用<br>如：tar zxvf logstash-7.6.0.tar.gz<br>解压后目录如下：<br><img src="https://img-blog.csdnimg.cn/20200414154300993.png" alt="logstash目录"><br>目录结构说明见官方文档：<a href="https://www.elastic.co/guide/en/logstash/7.1/dir-layout.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/7.1/dir-layout.html</a><br>解压以后可以对logstash进行简单的测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash -e <span class="string">'input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;'</span></span><br></pre></td></tr></table></figure><p>这条命令表示通过命令的方式指定logstash的输入输出分别是标准的输入输出，什么是标准的输入输出呢？就是控制台的输入输出。<br>等待启动成功，直接输入“hello world”<br>将会在控制台会有相应的输出<br>出现这些信息就表示logstash安装成功并且可以使用了。<br><img src="https://img-blog.csdnimg.cn/20200414154431921.png" alt="logstash测试"></p><h2 id="2、在线安装logstash插件"><a href="#2、在线安装logstash插件" class="headerlink" title="2、在线安装logstash插件"></a>2、在线安装logstash插件</h2><p>虽然logstash默认安装了大部分的插件，但是有些插件没有默认安装，如logstash-output-syslog、logstash-output-jdbc</p><h3 id="2-1-安装Gem并更新"><a href="#2-1-安装Gem并更新" class="headerlink" title="2.1. 安装Gem并更新"></a>2.1. 安装Gem并更新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install -y gem</span></span><br><span class="line"><span class="comment"># gem -v</span></span><br><span class="line">2.0.14.1</span><br><span class="line"><span class="comment"># gem update --system</span></span><br><span class="line"><span class="comment"># gem -v</span></span><br><span class="line">3.1.2</span><br></pre></td></tr></table></figure><h3 id="2-2-检查并修改镜像源"><a href="#2-2-检查并修改镜像源" class="headerlink" title="2.2 检查并修改镜像源"></a>2.2 检查并修改镜像源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gem sources -l</span></span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"> </span><br><span class="line">https://rubygems.org/</span><br><span class="line"></span><br><span class="line"><span class="comment"># gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span></span><br><span class="line">https://gems.ruby-china.com/ added to sources</span><br><span class="line">https://rubygems.org/ removed from sources</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat ~/.gemrc </span></span><br><span class="line">---</span><br><span class="line">:backtrace: <span class="literal">false</span></span><br><span class="line">:bulk_threshold: 1000</span><br><span class="line">:sources:</span><br><span class="line">- https://gems.ruby-china.com/</span><br><span class="line">:update_sources: <span class="literal">true</span></span><br><span class="line">:verbose: <span class="literal">true</span></span><br><span class="line">:concurrent_downloads: 8</span><br></pre></td></tr></table></figure><blockquote><p>请注意：国内的镜像站从<a href="https://gems.ruby-china.org" target="_blank" rel="noopener">https://gems.ruby-china.org</a> 换成了 <a href="https://gems.ruby-china.com" target="_blank" rel="noopener">https://gems.ruby-china.com</a><br>！！！现在很多网上的资料就都是写的<a href="https://gems.ruby-china.org，导致很多人换了镜像源也装不上。" target="_blank" rel="noopener">https://gems.ruby-china.org，导致很多人换了镜像源也装不上。</a></p></blockquote><h3 id="2-3-修改-logstash的-gem-镜像源"><a href="#2-3-修改-logstash的-gem-镜像源" class="headerlink" title="2.3. 修改 logstash的 gem 镜像源"></a>2.3. 修改 logstash的 gem 镜像源</h3><p>cd到logstach的安装目录，可以看到Gemfile文件 <code>vi Gemfile</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a Logstash generated Gemfile.</span></span><br><span class="line"><span class="comment"># If you modify this file manually all comments and formatting will be lost.</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">source</span> <span class="string">"https://rubygems.org"</span></span><br><span class="line">gem <span class="string">"logstash-core"</span>, :path =&gt; <span class="string">"./logstash-core"</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>更改默认的 <a href="https://rubygems.org" target="_blank" rel="noopener">https://rubygems.org</a> 为<a href="https://gems.ruby-china.com" target="_blank" rel="noopener">https://gems.ruby-china.com</a></p><h3 id="2-4、安装插件"><a href="#2-4、安装插件" class="headerlink" title="2.4、安装插件"></a>2.4、安装插件</h3><p><img src="https://img-blog.csdnimg.cn/20200414155435362.png" alt="安装插件"></p><h2 id="3、离线安装logstash插件"><a href="#3、离线安装logstash插件" class="headerlink" title="3、离线安装logstash插件"></a>3、离线安装logstash插件</h2><p>在实际应用过程中有些生产环境是封闭的网络环境，没法连接外网。这时候就需要离线安装插件。<br>说离线安装实际就是在一个有网络的环境下将插件装好，然后再装到离线环境中。<br>这里有两种方式,<br>一种就是在有网络的环境下将插件装好，将整个logsash包离线拷到生产环境。<br>另一种方式就是在有网络的环境下将插件装好后，将logstash的需要离线安装的插件打个离线包，然后再在生产环境进行离线安装。<br>离线插件包打包安装具体操作如下：</p><h3 id="3-1-通过logstash-plugin-prepare-offline-pack-命令将插件打成zip包"><a href="#3-1-通过logstash-plugin-prepare-offline-pack-命令将插件打成zip包" class="headerlink" title="3.1 通过logstash-plugin prepare-offline-pack 命令将插件打成zip包"></a>3.1 通过logstash-plugin prepare-offline-pack 命令将插件打成zip包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./logstash-plugin prepare-offline-pack --output logstash-output-syslog.zip logstash-output-syslog</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200414155806703.png" alt="打包"><br>打包命令执行成功以后，可以看到在logstash的bin目录下有打成的离线插件zip包<br><img src="https://img-blog.csdnimg.cn/20200414155831404.png" alt="打包后生成的离线包"></p><h3 id="3-2-通过logstash-plugin-install-进行离线安装"><a href="#3-2-通过logstash-plugin-install-进行离线安装" class="headerlink" title="3.2 通过logstash-plugin install 进行离线安装"></a>3.2 通过logstash-plugin install 进行离线安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash-plugin install file:///home/logstash/logstash-7.6.2/tools/logstash-output-syslog.zip</span><br></pre></td></tr></table></figure><p>安装后成功会有如下提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Installing file: /home/logstash/logstash-7.6.2/tools/logstash-output-syslog.zip</span><br><span class="line">Install successful</span><br></pre></td></tr></table></figure><h3 id="3-2-通过logstash-plugin-list命令检查插件是否安装成功"><a href="#3-2-通过logstash-plugin-list命令检查插件是否安装成功" class="headerlink" title="3.2 通过logstash-plugin list命令检查插件是否安装成功"></a>3.2 通过logstash-plugin list命令检查插件是否安装成功</h3><p><img src="https://img-blog.csdnimg.cn/20200414155929438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="logstash-plugin list"></p><h2 id="4、logstash简单配置说明"><a href="#4、logstash简单配置说明" class="headerlink" title="4、logstash简单配置说明"></a>4、logstash简单配置说明</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Logstash 设计了自己的 DSL ——包括有区域，注释，数据类型(布尔值，字符串，数值，数组，哈希)，条件判断，字段引用等。</p><h3 id="区段-section"><a href="#区段-section" class="headerlink" title="区段(section)"></a>区段(section)</h3><p>Logstash 用 {} 来定义区域。区域内可以包括插件区域定义，你可以在一个区域内定义多个插件。插件区域内则可以定义键值对设置。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    stdin &#123;&#125;</span><br><span class="line">    syslog &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Logstash 支持少量的数据值类型：</p><ul><li>bool<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug =&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li>string<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host =&gt; <span class="string">"hostname"</span></span><br></pre></td></tr></table></figure></li><li>number<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port =&gt; <span class="number">514</span></span><br></pre></td></tr></table></figure></li><li>array<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match =&gt; [<span class="string">"datetime"</span>, <span class="string">"UNIX"</span>, <span class="string">"ISO8601"</span>]</span><br></pre></td></tr></table></figure></li><li>hash<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">options =&gt; &#123;</span><br><span class="line">    key1 =&gt; <span class="string">"value1"</span>,</span><br><span class="line">    key2 =&gt; <span class="string">"value2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字段引用-field-reference"><a href="#字段引用-field-reference" class="headerlink" title="字段引用(field reference)"></a>字段引用(field reference)</h3>如果想在 Logstash 配置中使用字段的值，只需要把字段的名字写在中括号 [] 里就行了，这就叫字段引用。<br>对于 嵌套字段(也就是多维哈希表，或者叫哈希的哈希)，每层的字段名都写在 [] 里就可以了。比如，你可以从 geoip 里这样获取 longitude 值：<br>[geoip][location][0]<br>logstash 的数组也支持倒序下标，即 [geoip][location][-1] 可以获取数组最后一个元素的值。<br>Logstash 还支持变量内插，在字符串里使用字段引用的方法是这样：<br>“the longitude is %{[geoip][location][0]}”</li></ul><h3 id="条件判断-condition"><a href="#条件判断-condition" class="headerlink" title="条件判断(condition)"></a>条件判断(condition)</h3><p>表达式支持下面这些操作符：<br>equality, etc: ==, !=, &lt;, &gt;, &lt;=, &gt;=<br>regexp: =<del>, !</del><br>inclusion: in, not in<br>boolean: and, or, nand, xor<br>unary: !()<br>通常来说，你都会在表达式里用到字段引用。比如：<br>if “_grokparsefailure” not in [tags] {<br>} else if [status] !~ /^2\d\d/ and [url] == “/noc.gif” {<br>} else {<br>}</p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>Logstash 提供了一个 shell 脚本叫 logstash 方便快速运行。它支持一下参数：<br>-e<br>意即执行。我们在 “Hello World” 的时候已经用过这个参数了。事实上可以不写任何具体配置，直接运行 <code>bin/logstash -e</code> ‘’ 达到相同效果。这个参数的默认值是下面这样：<br>input {<br>    stdin { }<br>}<br>output {<br>    stdout { }<br>}<br>–config 或 -f<br>意即文件。真实运用中，我们会写很长的配置，甚至可能超过 shell 所能支持的 1024 个字符长度。所以我们必把配置固化到文件里，然后通过 <code>bin/logstash -f agent.conf</code> 这样的形式来运行。<br>此外，logstash 还提供一个方便我们规划和书写配置的小功能。你可以直接用 <code>bin/logstash -f /etc/logstash.d/</code> 来运行。logstash 会自动读取 /etc/logstash.d/ 目录下所有的文本文件，然后在自己内存里拼接成一个完整的大配置文件，再去执行。<br>–configtest 或 -t<br>意即测试。用来测试 Logstash 读取到的配置文件语法是否能正常解析。Logstash 配置语法是用 grammar.treetop 定义的。尤其是使用了上一条提到的读取目录方式的读者，尤其要提前测试。<br>–log 或 -l<br>意即日志。Logstash 默认输出日志到标准错误。生产环境下你可以通过 bin/logstash -l logs/logstash.log 命令来统一存储日志。<br>–filterworkers 或 -w<br>意即工作线程。Logstash 会运行多个线程。你可以用 <code>bin/logstash -w 5</code> 这样的方式强制 Logstash 为过滤插件运行 5 个线程。</p><h1 id="四、logstash使用的几种典型的应用场景"><a href="#四、logstash使用的几种典型的应用场景" class="headerlink" title="四、logstash使用的几种典型的应用场景"></a>四、logstash使用的几种典型的应用场景</h1><h2 id="1、通过logstash将syslog日志原始日志转发"><a href="#1、通过logstash将syslog日志原始日志转发" class="headerlink" title="1、通过logstash将syslog日志原始日志转发"></a>1、通过logstash将syslog日志原始日志转发</h2><p><img src="https://img-blog.csdnimg.cn/20200414161106796.png" alt="syslog日志原始日志转发"><br>在logstash的bin目录下新建配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="built_in">test</span>-pipeline.conf</span><br></pre></td></tr></table></figure><p>编辑input和output</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    stdin&#123;</span><br><span class="line">      type =&gt; <span class="string">"test-log"</span></span><br><span class="line">    &#125;</span><br><span class="line">    syslog&#123;</span><br><span class="line">        type =&gt; <span class="string">"test-log"</span></span><br><span class="line">        port =&gt; <span class="number">514</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output</span><br><span class="line">&#123;</span><br><span class="line">    stdout &#123;</span><br><span class="line">      codec =&gt; rubydebug</span><br><span class="line">    &#125;</span><br><span class="line">    syslog&#123;</span><br><span class="line">        host =&gt; <span class="string">"192.168.2.185"</span></span><br><span class="line">        port =&gt; <span class="number">514</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就相当于把日志转发到了192.168.2.185这台机器的514端口<br>编辑好配置文件以后执行<br><code>./logstash -f test-pipeline.conf --config.test_and_exit</code>     对配置文件进行检查，如果配置文件写得有问题，将会有错误提示。<br>配置文件检查没有问题后就可以启动logstash执行了<code>./logstash -f test-pipeline.conf  --config.reload.automatic</code><br>用udpsender工具往这台机器上发送日志信息，可以看到日志转发到192.168.2.185这台机器上了。<br><img src="https://img-blog.csdnimg.cn/20200414161139252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="updsend发送日志"><br>在控制台可以看到192.168.2.185，接收到了192.168.2.173转发过来的日志<br><img src="https://img-blog.csdnimg.cn/20200414161229147.png" alt="控制台日志"></p><h2 id="2、通过rsyslog、logstash采集nginx等中间件的日志送到ES"><a href="#2、通过rsyslog、logstash采集nginx等中间件的日志送到ES" class="headerlink" title="2、通过rsyslog、logstash采集nginx等中间件的日志送到ES"></a>2、通过rsyslog、logstash采集nginx等中间件的日志送到ES</h2><p>logstash可以与rsyslog、filebeat等无缝结合采集nginx等中间件日志，送给数据存储。<br><img src="https://img-blog.csdnimg.cn/20200414161255484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="通过rsyslog、logstash采集nginx等中间件的日志送到ES"><br>具体参见：<a href="https://xiejava.gitee.io/posts/f3e97829/" target="_blank" rel="noopener">https://xiejava.gitee.io/posts/f3e97829/</a></p><h2 id="3、通过logstash将日志入kafka再入mysql或ES"><a href="#3、通过logstash将日志入kafka再入mysql或ES" class="headerlink" title="3、通过logstash将日志入kafka再入mysql或ES"></a>3、通过logstash将日志入kafka再入mysql或ES</h2><p>数据先放到kafka队列里缓存削峰，然后从kafka队列里读取数据到mysql或其他存储系统中进行保存。<img src="https://img-blog.csdnimg.cn/20200414161405732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="logstash将日志入kafka再入mysql或ES"><br>具体参见：<a href="https://xiejava.gitee.io/posts/54e4fd14/" target="_blank" rel="noopener">https://xiejava.gitee.io/posts/54e4fd14/</a></p><h2 id="4、通过logstash进行日志补全后再转发或入库"><a href="#4、通过logstash进行日志补全后再转发或入库" class="headerlink" title="4、通过logstash进行日志补全后再转发或入库"></a>4、通过logstash进行日志补全后再转发或入库</h2><p>采集原始日志以后，需要对原始日志进行调整合补齐，比如最常见的是根据IP来补齐IP的经纬度等信息。<br><img src="https://img-blog.csdnimg.cn/2020041416162510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="logstash进行日志补全"><br>这里就可以用logstash的geotip，也可以用其他的外部API接口，为了更具代表性的说明，这里调用的是第三方的http接口（<a href="http://ip-api.com/json/），这个接口也是可以自己定义的。" target="_blank" rel="noopener">http://ip-api.com/json/），这个接口也是可以自己定义的。</a><br>参考配置文件如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    stdin &#123; &#125;</span><br><span class="line">    syslog &#123;</span><br><span class="line">      port =&gt; <span class="string">"514"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    grok&#123;</span><br><span class="line">         <span class="comment">#匹配获取IP</span></span><br><span class="line">         match =&gt; &#123;<span class="string">"message"</span> =&gt; <span class="string">"%&#123;IPV4:ip&#125;"</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    http &#123;</span><br><span class="line">        <span class="comment">#调用外部接口获取IP的详细信息</span></span><br><span class="line">        url =&gt; <span class="string">"http://ip-api.com/json/%&#123;ip&#125;"</span></span><br><span class="line">        verb =&gt; <span class="string">"GET"</span></span><br><span class="line">        add_field =&gt; &#123;</span><br><span class="line">          <span class="string">"new_field"</span> =&gt; <span class="string">"new_static_value"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutate &#123;</span><br><span class="line">        replace =&gt; &#123;     </span><br><span class="line">            <span class="comment">#这里对原始日志数据进行补全，如加了新的字段及从接口中获取的信息</span></span><br><span class="line">            <span class="string">"message"</span> =&gt; <span class="string">"%&#123;message&#125;|%&#123;ip&#125;: My new message|%&#123;new_field&#125;|%&#123;[body][as]&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    stdout &#123; &#125;</span><br><span class="line">    syslog &#123;</span><br><span class="line">        host =&gt; <span class="string">"192.168.2.173"</span></span><br><span class="line">        port =&gt; <span class="string">"7514"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过http接口调用API取得数据，然后通过mutate重新组合补全信息，这里通过调用获取IP地址信息的API获取IP的信息，然后补全到原始日志中。<br><img src="https://img-blog.csdnimg.cn/20200414161738867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>可以看出logstash是一个非常灵活好用的数据采集框架工具，可以通过简单的配置满足绝大多数数据采集场景的需求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、logstash是什么&quot;&gt;&lt;a href=&quot;#一、logstash是什么&quot; class=&quot;headerlink&quot; title=&quot;一、logstash是什么&quot;&gt;&lt;/a&gt;一、logstash是什么&lt;/h1&gt;&lt;p&gt;Logstash 是开源的服务器端&lt;strong&gt;数
      
    
    </summary>
    
    
      <category term="技术" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="开发" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="大数据" scheme="http://xiejava.ishareread.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="ELK" scheme="http://xiejava.ishareread.com/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>英语学渣的我是如何撸完一本英文原著的</title>
    <link href="http://xiejava.ishareread.com/posts/1e6a75de/"/>
    <id>http://xiejava.ishareread.com/posts/1e6a75de/</id>
    <published>2020-04-07T09:56:06.000Z</published>
    <updated>2020-04-07T10:17:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/20200407/blogimage/englishimage.png" alt="英语原著"><br>2020年初立的flag就有要看完十本英文原著。看英文原著对于英语学渣的我来说几乎是很难想像的事情。说英语烂那只有自己知道，读书的时候从来就没有学好过，工作这么多年更是忘得一干二净了。与英语相爱相杀若干年，经历了无数次从开始到放弃……</p><p>非常羡慕别人能够很顺畅的看懂英文原著，能够丢开字幕看懂英语大片，能够飚一口的英文。有人说学好了英文就给自己多开了一扇了解世界的窗户，比别人多一半的人生经历。英语对于生活在全球化信息时代的我们来说有多么的重要，不用多说，道理啥的咱都知道，可是经历了这么多年还是学不会啊。买了N多的英语学习资料，下了N多的视频教程，查找了各种学习英语的方法。单词书永远都是翻了前面几页，英语学习资料屯了一堆从来没有开封过，市面上吹捧的各种英语学习方法感觉都很不错，尝试了很多种还是在尝试……</p><p>虽然有过无数次失败的经历，但也越来越认识到英语的重要性，也看到越来越多的人将英语学得很溜，让我清醒的认识到英语很重要，英语很难学，英语是一定是可以学好的，但是妄想速成是不可能的。如何才能最终习得英语的技能呢？</p><p>前新东方英语老师李笑来在他的《财富自由之路》中指出在智力上、知识上、经验上，复利效应对每个人来说都是存在的。知识和能力的习得与积累是有复利效应的。所以，大多数的人应该要相信自己能够通过知识和能力的积累和复利获得成功和成长。经过多年教训，所有什么打着21天搞定单词，一个月看懂原著啥的口号都是骗人的。在英语技能的习得上，我笃信只有坚持积累和复利才能最终成功。我坚信经过自己的努力和坚持，我在英语习得上投入的精力和时间超过成本线以后，我的英语水平将会有突破性的提高。</p><p>在英语学习的过程中有过<a href="https://xiejava.gitee.io/posts/48451ead/" target="_blank" rel="noopener">《坚持了330天，我终于放弃了背单词》</a>的经历，让我认识到只有“用”英语，才能够真正的掌握英语。目前我最朴素的需求就是想能够看懂英文文档，能够流畅的阅读英文书籍。而目前所处的语言环境”说”英语的需求不是很迫切。对于我来说能够流利阅读英语已经足够了。既然开始“用”英语，那就从大量开始阅读英语原版书开始吧！英语这么菜，我为什么敢挑战英文原版书呢？因为我看到了李笑来老师提到掌握一门外语的最少必要知识。<br>1、认识字母<br>2、认识音标<br>3、会查字典<br>4、懂点基本语法<br>5、会用百度或google等搜索引擎。<br>如果掌握了这些最小必要的知识，你就已经“入门”了，接下了就只剩下所谓“执行”了，也就是要用起来。<br>我想，这些最小必要的知识我基本都已经具备了。在正式准备看英语原著之前，我看完了全套149本《书虫》（见<a href="https://xiejava.gitee.io/posts/40bbedc5/" target="_blank" rel="noopener">《看完全套149本《书虫》是种什么样的体验》</a>）。对于英语的阅读相对来说没有那么怵了。<br>虽然我看完了全套149本《书虫》，但是《书虫》毕竟只是入门级的英语简写读物，与英语原版的原著还是有很大的距离的。</p><p>作为英语原著初读者来说，真正看完一本书，完成从0到1的过程，比深刻理解一本书更重要。而对于初读者来说如何撸完一本英文原著还是比较有挑战的。</p><p><strong>首先要找到一本自己非常感兴趣并且适合自己难度的书籍。自己不感兴趣或者难度太难了，就会容易放弃。</strong><br>对于挑选原版书的阅读材料来说，我也是花的一些功夫。网上有人建议刚开始接触英语原著建议是比较浅的原著如儿童读物《夏洛的网》、《格林童话》、《小王子》之类的。对于我这种成年人来说这类读物实在是提不起我的兴趣。还有人推荐《哈利波特》系列，我不是哈迷所以也没有选择《哈利波特》系列。我选择的是《奇迹男孩》。《奇迹男孩》的电影在2018年上映的时候我就想看，但是一直没有时间去看。正好买了这本英文原著来看看。《奇迹男孩》英文原著豆瓣评分9.1分，属于儿童成长类的书籍，老少皆宜，300来页长短适中不是那种大部头。因为是面向青少年的书籍所以单词不难，而且是近几年出的新书畅销书，比较口语化没有太多的长句子，非常通俗。事实证明《奇迹男孩》非常适合像我这样的英语原著初读者。<br><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/20200407/blogimage/wonder.png" alt="奇迹男孩"></p><p><strong>选择了阅读目标的原版书籍后，就要开始读并坚持下来</strong><br>作为英语原著初读者，即使是最通俗的原版书，单词也会是一个拦路虎。单词没有办法，那就是勤查字典。《奇迹男孩》是面向青少年的书籍，单词不难，但对我来说也是充斥着各种生词。不过还好每页大概是在6、7个左右。如果按照伍君仪的《把你的词汇用起来》中的透析法，隔一个生词查一个，只查一半的生词，剩下的靠猜，那每页只要查2-3个单词左右，这个查词量已经很小了。因为这本书对我来说生词量6、7个不算多，而且作为原著初读者，猜单词的意思往往猜不准，所以我就索性看到不懂的单词每个都会查字典。为了尽快的撸完这本书，我也是给自己定了个目标，每天看30页。看少了不记得前后的情节，看多了怕自己看不下去。别看只有区区的30页，看中文也就半个小时的事情，但是看英文又要查字典，平均要花掉2-3个小时才能看完。所以对于英语原著初读者来说30页是个比较适中的量，后续如果熟练的可以慢慢的增加。这本《奇迹男孩》300多页，大概花了我一周半的时间。</p><p><strong>对于英语原版书是看电子版的还是纸质版的，建议还是先看纸质版的</strong><br>作为英语原著初读者，我自己认为还是先看纸质版。看电子版的有个好处就是可以随时查字典，尤其是用kindle看，开启生词提示，并且长按生词就会调出字典查词，非常方便。正是因为太方便了，会让我们产生依赖，有时很容易的单词还会忍不住去查一下字典。而且有时候要往回看情节翻起来也不太方便。虽然有进度显示但是没有纸质书那么直观。纸质书看起来更加有感觉，可以前后翻，有时不记得前面的情节了可以方便的随时翻看，每天看了多少页插个书签就是。看着书签慢慢的插到了最后心里还是满满的成就感。</p><p>对于英语原著初读者来说，撸完一本英文原著，完成从0到1的过程。这种小小的成就感，更加坚定了学习英语的信心。相信经过自己的努力和坚持，看完数十本英文原著以后，英语水平将会有突破性的提高。</p><p>学习外语没有其他任何捷径，唯有“结硬寨,打呆仗;日拱一卒,功不唐捐!”</p><p>我读过的英文读本豆列： <a href="https://www.douban.com/doulist/118432400/" target="_blank" rel="noopener">https://www.douban.com/doulist/118432400/</a></p><p>爱分享读书豆瓣小组： <a href="https://www.douban.com/group/655112/" target="_blank" rel="noopener">https://www.douban.com/group/655112/</a></p><hr><center>关注：“爱分享读书”微信公众号 </center><p><img src="http://image.ishareread.com/qrcode_for_gh_70fb5d85a824_258.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><center>读书我们是认真的</center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://xiejava.gitee.io/xiejavaimagesrc/images/20200407/blogimage/englishimage.png&quot; alt=&quot;英语原著&quot;&gt;&lt;br&gt;2020年初立的flag就有要看完十本英文原著。看英文原
      
    
    </summary>
    
    
      <category term="读书" scheme="http://xiejava.ishareread.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="英语" scheme="http://xiejava.ishareread.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>忘掉10000小时，如何快速获得某项技能</title>
    <link href="http://xiejava.ishareread.com/posts/10547b72/"/>
    <id>http://xiejava.ishareread.com/posts/10547b72/</id>
    <published>2020-03-28T09:23:39.000Z</published>
    <updated>2020-04-01T08:13:44.969Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/20200328/blogimage/%E4%B8%80%E4%B8%87%E5%B0%8F%E6%97%B6%E5%AE%9A%E5%BE%8B.png" alt="一万小时定律"></p><p>几乎每个人都知道1万小时定律，这个定律被人奉为圭臬。给每个渴望成功的同学们指明了方向，只要在某个领域付出不断的努力，达到10000个小时，就可以成为这方面的专家领袖。</p><p>所谓“一万小时定律”，最早出现于作家格拉德威尔《异类》一书。在书中，格拉德威尔举出了例如比尔盖茨这样的例子，言之凿凿的声称：那些天才和专家之所以卓越非凡，并非他们的天赋超人一等，而是他们付出了持续不断的努力。而任何普通人都可以达到这样的目标，只需要付出10000小时的训练即可。</p><p>这个定律非常符合大家的胃口，也有一定的道理，不怀疑在一个方向上持续不断的努力肯定会有所成功。在智力上、知识上、经验上，复利效应对每个人来说都是存在的。知识和能力的习得与积累是有复利效应的。所以，大多数的人应该要相信自己能够通过知识和能力的积累和复利获得成功和成长。</p><p>但是10000小时不是个很短的时间，如果每天投入2个半小时，那要10年才能成为专家。大多数人不用说坚持10000个小时，坚持100个小时还没有入门，就已经倒下放弃了。而对正常人现实需求来说，一万小时是成为顶尖高手的门槛，可遇而不可求。想要获得比较好的收入，能够做出较好的事情，基本上只需要超过平均水平即可。不必凡事都跟行业内最顶尖的几个人相比，但是能够超过一个行业的平均水平，也足够获取比较好的利润、回报和成绩。</p><p>对于任何一件事情、一个行业领域或者是一个学习任务而言也只有先入门了，取得了比较好的利润、回报和成绩，才会有兴趣持续的做下去，才可能有10000小时精进的努力。所以<strong>忘掉10000小时，先快速的入门达到超过行业平均水准，才能继续后面的牛逼</strong>。</p><p>那么问题来了，如何才能快速的入门呢？<br>李笑来的《财富自由之路》里，指出了两个关键字“<strong>最少必要知识</strong>”、”<strong>用</strong>“<br>当需要进入某个行业、获得某项技能的时候，一定要想办法在最短的时间里弄清楚都有哪些最小必要知识，然后迅速的掌握它们。任何人都可以完成快速入门。例如掌握一门外语的最少必要知识有哪些呢？<br>1、认识字母<br>2、认识音标<br>3、会查字典<br>4、懂点基本语法<br>5、会用百度或google等搜索引擎。<br>如果掌握了这些最小必要的知识，你就已经“入门”了，接下了就只剩下所谓“执行”了，也就是要用起来。通过用起来才能从入门到熟练。然后就要专注于改进了。<br>所以快速学习或快速掌握一门技能进入某个行业。无外乎就是快速的掌握最小必要的知识迅速入门，然后通过不断的用起来，在用的过程中不断的实践。逐步从入门到熟练，熟练后就可以专注创新改进而达到精进。</p><p>道理就是这么个道理，但是为什么有些人学什么东西入门就是比你快呢？<br>就是他已有的<strong>背景知识</strong>掌握得比你广、比你好，比如同样是学机器学习，数学系的大概率的要比计算机系的要入门快，计算机系的大概率的要比文科类专业的入门要快。因为学机器学习需要比较强的数学知识背景，虽然入门同样是要掌握那几种常用的算法，数学系的理解起来要比非数学系统理解起来要快得多。</p><p>所以要想快速进入某个行业、获得某项技能，先弄清楚这个行业都需要哪些最小必要知识，评估一下自己的背景知识的匹配度，迅速补齐掌握最小的必要知识，持续的用，不断的改进。实际上当你进入到某个行业实际上就已经补齐完善了你的背景知识。通过不断的学习，背景知识框架体系会越来越广，那你学东西会越来越快。形成一个正向循环。让你越来越牛逼！</p><hr><center>关注：“爱分享读书”微信公众号 </center><p><img src="http://image.ishareread.com/qrcode_for_gh_70fb5d85a824_258.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><center>读书我们是认真的</center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://xiejava.gitee.io/xiejavaimagesrc/images/20200328/blogimage/%E4%B8%80%E4%B8%87%E5%B0%8F%E6%97%B6%E5%AE%9A%E5%BE%8B.png&quot; a
      
    
    </summary>
    
    
      <category term="读书" scheme="http://xiejava.ishareread.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读后感" scheme="http://xiejava.ishareread.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>《暗时间》读书笔记</title>
    <link href="http://xiejava.ishareread.com/posts/431cf122/"/>
    <id>http://xiejava.ishareread.com/posts/431cf122/</id>
    <published>2020-03-28T05:55:55.000Z</published>
    <updated>2020-03-28T06:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>刘未鹏说——</p><p><strong>写博客这件事情给我最大的体会就是，一件事情如果你能够坚持做8年，那么不管效率和频率多低，最终总能取得一些很可观的收益。而另一个体会就是，一件事情只要你坚持得足够久，“坚持”就会慢慢变成“习惯”。原本需要费力去驱动的事情便成了家常便饭，云淡风轻。</strong></p><p>这本书便是从刘未鹏8年的博客文章中精选出来的，主要关于心智模式、学习方法和时间利用，《暗时间》的书名便来自于此。</p><p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/20200328/blogimage/%E3%80%8A%E6%9A%97%E6%97%B6%E9%97%B4%E3%80%8B.png" alt="《暗时间》"></p><h1 id="第一章-暗时间"><a href="#第一章-暗时间" class="headerlink" title="第一章 暗时间"></a>第一章 暗时间</h1><p>善于利用思维时间的人，可以无形中比别人多出很多时间，从而实际意义上能比别人多活很多年。<br>学习一门专业应该是投入之间和效率的乘积。<br>你可以“投入”很多时间在一件事情上面，却发现毫无进展，因为你没有整天把你要做的事情，要学习的东西常驻在你的大脑中，时刻给予它最高的优先级。<br>如果你有做总结的习惯，你在度过一段时间之后总结自己在某某领域投入了多少时间，建议千万不要粗略地去计算有多少天下班后拿起书来翻看过，因为这样你也许会发现书倒是常翻，但领悟却不见得多深，表面上花的时间不少，收益却不见得那么大。因为<strong>看书并记住书中的东西只是记忆，并没有涉及推理，只有靠推理才能深入理解一个事物，看到别人看都不到的地方，这部分推理的过程就是你的思维时间，也是人一生中占据一个显著比例的“暗时间”</strong>，你走路、买菜、洗脸洗手、坐公车、逛街、出游、吃饭、睡觉，所有这些时间都可以成为“暗时间”，你可以充分利用这些时间进行思考，反刍和消化平时看和读的东西，让你的认识能够脱离照本宣科的层面。</p><h1 id="第二章-设计你自己的进度条"><a href="#第二章-设计你自己的进度条" class="headerlink" title="第二章 设计你自己的进度条"></a>第二章 设计你自己的进度条</h1><p>如果没有进度提示，我们无法判断这个等待什么时候才是个尽头。如果有不断增长的进度条，那么我们对于什么时候会达到100%就会有一个粗略的估计。做事情也是同样的道理，善于规划的人，会将目标分割成一个个的里程碑，再将里程碑分割成TODO列表。<br>过早退出是一切失败的根源。<br>兴趣遍地都是，专注和持之以恒才是真正稀缺的。<br>靠专业技能的成功是最具可复制性的。它需要的只是你在一个领域坚持不懈地专注下午，只需要选择一个不算太靠谱的方向，然后专心致志的专下去，最后必然能成为高手或绝顶高手。<br>反思是让人得以改进自己的最重要的思维品质。<br>一生的知识积累，自学的起码占90%</p><h1 id="第三章-如何有效地记忆与学习"><a href="#第三章-如何有效地记忆与学习" class="headerlink" title="第三章 如何有效地记忆与学习"></a>第三章 如何有效地记忆与学习</h1><p>你所拥有的知识并不取决于你记得多少，而在于它们能否在恰当的时候被回忆起来。<br> 如何有效的总结知识，学以致用<br>1）养成习惯，经常主动回顾一段时间学到的东西。<br>2）创造回忆的机会<br>  2.1）经常与别人讨论，或者讲给别人听。“教是最好的学”<br>  2.2）整理笔记。<br>  2.3）书写。“书写是更好的思考”<br>3）设身处地的“虚拟经历”别人经历过的事情。<br>4）抽象和推广<br>5）联系/比较自身的经历</p><h1 id="第五章-学习习惯"><a href="#第五章-学习习惯" class="headerlink" title="第五章 学习习惯"></a>第五章 学习习惯</h1><h2 id="一、学习与思考"><a href="#一、学习与思考" class="headerlink" title="一、学习与思考"></a>一、学习与思考</h2><p>1、Google&amp;Wiki 遇到问题先上网搜索，自己找答案。<br>2、看书只看经典。<br>3、做读书笔记。便于回顾、加深理解<br>     a.将自己阅读时候的思考总结下来。<br>     b.将书中的好例子摘抄下来。<br>4、无时不可不思考。思考可以避免焦虑。<br>5、要事优先<br>6、重要的事情营造比较大的时间块来完成。<br>7、多看心理学与思维的书。<br>8、学习一项知识三问（a.它的本质是什么。b.它的第一原则是什么。c.它的知识结构是怎样的）<br>9、获得的多少并不取决于读了多少，而取决于思考了多少，多深。<br>10、善于利用小块时间。<br>11、养成好习惯。</p><h2 id="二、时间管理"><a href="#二、时间管理" class="headerlink" title="二、时间管理"></a>二、时间管理</h2><p>1、学习和思考过程中常问自己几个问题<br>    a.你的问题到底是什么？（提醒自己思考不要偏离问题）<br>    b.到现在为止，我到底有了什么收获呢？（提醒自己时不时去总结，整理学习的东西）<br>    c.设想自己正在将东西讲给别人听。<br>    d.时常反省和注意自己的思维过程。（将思维的大致脉络写下来是个很好的习惯）<br>    e.养成反驳自己的想法的习惯。<br>    f.人的思维天生就是极易流于表面来理解事物的。觉得自己理解了一个问题了吗？条件反射的问自己：你真的理解了吗？你真的理解了问题的本质吗？问题的本质到底是什么？目前我的理解是什么？我对这个理解感到满意吗？这样的理解到底有什么建设性呢？等等。<br>2、重视知识的本质<br>3、重视积累的强大力量，万事提前准备。<br>4、抬起头来：时不时抬起头来审视一下自己正在做的事情，自问一下有什么价值，是不是你真正希望做的。它们重要吗？你需要在这个时候学这些吗？你的时间就是你的资源，你投入这些资源来掌握知识，所以到底用来掌握哪些知识是一个很重要的问题。</p><h2 id="三-知识结构"><a href="#三-知识结构" class="headerlink" title="三 知识结构"></a>三 知识结构</h2><p>抓住不变量<br>知识分为essential(必要)和non-essential（非必要）的。对于前者提前深入掌握牢靠，对于后者采取待用到的时刻RTM(Read the manual)方法。</p><h1 id="第八章-书写是为了更好的思考"><a href="#第八章-书写是为了更好的思考" class="headerlink" title="第八章 书写是为了更好的思考"></a>第八章 书写是为了更好的思考</h1><p>1、书写是对思维的备忘<br>2、书写是对思维的缓存<br>3、书写是与自己的对话<br>4、书写是与别人的交流<br>如果你着自己将一些不成熟的想法写下来，看着自己写的内容，试着进一步拓展它们，就有可能在理性的道路上走得很远，很远。</p><h1 id="第九章-为什么你从现在开始就应该写博客"><a href="#第九章-为什么你从现在开始就应该写博客" class="headerlink" title="第九章 为什么你从现在开始就应该写博客"></a>第九章 为什么你从现在开始就应该写博客</h1><p>用博客的形式来记录下你有价值的思考，会带来很多好处，却没有任何明显的坏处。<br>价值博客的几点好处<br>1、能交到很多志同道合的朋友。<br>2、书写是为了更好的思考<br>3、教是最好的学<br>4、讨论是绝佳的反思<br>5、激励你去持续学习和思考<br>6、学会持之以恒地做一件事情。<br>7、一个长期的价值博客是一份很好的简历。</p><h1 id="第十二章-什么才是你的不可替代性-amp-核心竞争力"><a href="#第十二章-什么才是你的不可替代性-amp-核心竞争力" class="headerlink" title="第十二章 什么才是你的不可替代性&amp;核心竞争力"></a>第十二章 什么才是你的不可替代性&amp;核心竞争力</h1><p>1、专业领域技能：成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。<br>2、跨领域的技能：解决问题的能力，创新思维，判断与决策能力，批判性思维能力，表达沟通能力等等。<br>3、学习能力：持续学习和思考<br>4、性格要素：专注、持之以恒、自信、自省、好奇心。等等。</p><hr><center>关注：“爱分享读书”微信公众号 </center><p><img src="http://image.ishareread.com/qrcode_for_gh_70fb5d85a824_258.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><center>读书我们是认真的</center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刘未鹏说——&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写博客这件事情给我最大的体会就是，一件事情如果你能够坚持做8年，那么不管效率和频率多低，最终总能取得一些很可观的收益。而另一个体会就是，一件事情只要你坚持得足够久，“坚持”就会慢慢变成“习惯”。原本需要费力去驱动的事情便成了家常便
      
    
    </summary>
    
    
      <category term="读书" scheme="http://xiejava.ishareread.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书笔记" scheme="http://xiejava.ishareread.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>你所谓的财富自由是什么？</title>
    <link href="http://xiejava.ishareread.com/posts/e3431c21/"/>
    <id>http://xiejava.ishareread.com/posts/e3431c21/</id>
    <published>2020-03-27T09:09:46.000Z</published>
    <updated>2020-03-27T10:30:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/20200327/blogimage/%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1.jpg" alt="财富自由"></p><p>实现财富自由是现如今大部分人的理想。不管是加班工作赚钱也好，搞刚需副业也好，还是创业做投资也好都是为了一个目的实现财富自由。有些人早早的就已经实现了财富自由，有些人一辈子也没有实现财富自由，更多的人则是在追求财富自由的路上。</p><p>看过《穷爸爸富爸爸》的人都知道财富自由是指你无须为生活开销而努力为钱工作的状态。简单地说，你的资产生的被动收入必须至少等于或超过你的日常开资–这是我们大多数人向往的状态。这个定义非常清晰，大多数的人都认同这种说法。但是对我来说感触最深的还是李笑来老师在他的《财富自由之路》里面的定义：<strong>“个人财富自由，是指某个人再也不用为了满足生活必须而出售自己的时间了”</strong>。这是多么深刻的认识啊，你加班工作也好，副业也好不都是在出售自己的时间获得财富吗？即使是创业做投资本质上也是在出售自己的时间，是在购买别人的时间再出售出去，只是有可能这样出售自己时间的效率更高而已。</p><p>李笑来老师在对时间的理解、对心智的认识，对学习的认识、对成长的认识，我觉得都非常的深刻。有人说他的书是鸡汤，但是他总是可以用非常浅显深刻的道理让你心甘情愿的干了这碗鸡汤还回味无穷。他的《财富自由之路》就是这么一本书。</p><p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/20200327/blogimage/%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF.png" alt="《财富自由之路》"></p><p>我们要的自由，其本质不是财富，财富只是工具：我们要的自由，本质上是时间的自主权。所以个人财富自由，是指某个人再也不用为了满足生活必须而出售自己的时间了。</p><p>如何才能让自己财富自由呢？一个世人皆知的道理就是积累和复利。</p><p>爱因斯坦曾经说过：复利是“世界第八大奇迹”。知之者赚，不知之者被赚。但是复利并不是凭空来的，你得现有成本的积累，积累越大复利的效果随着时间的推移效果会越来越显著。</p><p>对于资产投资者来说，如果你的投资收益如果是正的话，你不断的积累复投，若干年后你的财富增长将相当的可观。如果天生有个好爹可以继承财富，那么你起点就比别人高，可以通过财富的复利实现自由。但是大多数人没有爹可以拼，没有大笔财富可以继承。不过万幸并且公平的是，在智力上、知识上、经验上，复利效应对每个人来说都是存在的。知识和能力的习得与积累是有复利效应的。所以，大多数的人应该要相信自己能够通过知识和能力的积累和复利获得成功和成长。</p><p><img src="http://xiejava.gitee.io/xiejavaimagesrc/images/20200327/blogimage/%E5%A4%8D%E5%88%A9%E6%9B%B2%E7%BA%BF.png" alt="复利曲线"> </p><p>一切有意义的成长过程都符合那个“复利曲线”。起初看来斜率突然发生变化的“点”，叫做“拐点”。如果作为一个投资者，你的投资是正利率，那么你的资产变化情况也符合这个有拐点、突破了成本线的、后端急速上扬的“复利曲线”。</p><p>如果没有资产可以继承，那就持续积累知识和能力吧。这是大多数人可以成功实现财富自由并且一定能成功的可靠路径。关注成长，而不是成功，因为当你的成长线终于穿越成本线时，你事实上已经成功了，可那肯定不是终点。因为如果你不成长了，有可能这个成长线还会往下掉，将你的成功的成果吞噬。</p><p>既然”复利曲线”那么有效，那为什么还有那么多人在成本线下苦苦挣扎，没有碰到所谓的拐点，更不用说什么财富自由了。这里要注意几个被容易忽视的东西，那就是“<strong>投入方向</strong>”、“<strong>沉没成本</strong>”、“<strong>利润</strong>”，“<strong>贬值</strong>”。</p><ul><li>投入方向</li></ul><p>如果方向有问题，那么你的努力就是南辕北辙，越努力离成功距离越远，那就谈不上什么积累和复利了。比如现在一个行业已经日落西山了要消亡，你还在这个行业傻傻的坚持努力。基本上是不可能成功的。</p><ul><li>沉没成本</li></ul><p>当你选择了一个正确的方向，经过了一段时间的努力，取得了一点小小的成绩，但是你停止了放弃了。在积累和复利之前就投降放弃了，以前的努力付出就成了沉没成本。</p><p>一个切身体会的例子，就是学英语。比如我通过一段时间的努力，看完了149本书虫，但是最近我放松了自己没有看英语了。如果还经过一段时间不坚持不努力，那我以前积累的这些单词什么的又会忘了。以前的努力将会白费了变成了“沉没成本”。</p><p>今天搞搞这个、明天搞搞那个，很多的努力就变成了沉没成本。回头一看，啥都没有积累更谈不上有复利了。所以如果要实现“复利曲线”。坚持和积累非常重要。</p><ul><li>利润</li></ul><p>复利复利，没有利润怎么能复利呢。利润高的复利效果更加明显，这个道理傻瓜都知道。所以说坚持做一件事情要考虑利润，也就是投入产出比。</p><p>比如花大量的时间放在看肥皂剧、刷社交软件上，这些事情不能让你成长或让你的能力提升有限，那对你能力成长产生复利的效果当然有限啊。</p><ul><li>贬值</li></ul><p>作为资本投资来说要考虑货币贬值，作为知识和能力的习得者来说要考虑知识的贬值。大家都知道计算机技术发展速度迅速，很多技术很快随着科技发展迅速的淘汰贬值。比如以前的CGI 、ASP、VB 等开发语言和技术现在都很少用了。那以前花精力学的这些知识都大幅度贬值了。当然有些知识和技能的贬值速度慢一些，比如通识知识、英语、驾驶、写作等。你赚钱的速度要大于你花钱的速度，你的资本才会有所以积累，有积累才有复利的可能。所以你的学习新知识的速度应该要大于知识贬值速度，你的知识和能力才会有积累和复利的可能。</p><p>用正确的方式做正确的事情，你一定会变得更好！</p><p>若长期持续用正确的方法做正确的事情，你的未来一定会很伟大！</p><hr><center>关注：“爱分享读书”微信公众号 </center><p><img src="http://image.ishareread.com/qrcode_for_gh_70fb5d85a824_258.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><center>读书我们是认真的</center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://xiejava.gitee.io/xiejavaimagesrc/images/20200327/blogimage/%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1.jpg&quot; alt=&quot;财富自由&quot;&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="读书" scheme="http://xiejava.ishareread.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读后感" scheme="http://xiejava.ishareread.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>syslog日志接口调试方法</title>
    <link href="http://xiejava.ishareread.com/posts/7bbe2925/"/>
    <id>http://xiejava.ishareread.com/posts/7bbe2925/</id>
    <published>2020-03-18T06:17:26.000Z</published>
    <updated>2020-03-18T06:19:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>日志数据采集，比较方便常用的就是通过syslog来进行数据采集，syslog可以通过udp协议来进行高效的数据传输。一般来说在工程实施的过程中需要对接对端系统的数据采集源可以通过以下步骤来进行syslog日志接口的调试。主要是验证syslog日志是否能正常送到指定的日志服务器的指定端口，日志服务器的指定端口是否能正常收到对端发过来的日志。</p><h1 id="1、检查双方网络是否通畅"><a href="#1、检查双方网络是否通畅" class="headerlink" title="1、检查双方网络是否通畅"></a>1、检查双方网络是否通畅</h1><p>网络通畅是所有网络连接的前提条件，可以先通过ping的方式，先确认一下对端数据源是不是可以ping通这边的日志接收服务器地址，看网络是否是通的。<br>一般来说只到对端能够ping通日志服务器地址就可以了，单向ping通就OK。<br>如果ping不通，那就要检查日志服务器的网络设置，如是否开启了防火墙，禁ping了。根据网络实际情况调整网络策略，确保网络是通的。</p><h1 id="2、检查端口是否通畅"><a href="#2、检查端口是否通畅" class="headerlink" title="2、检查端口是否通畅"></a>2、检查端口是否通畅</h1><p>通过数据源服务器telnet一下日志服务器地址和端口，看端口是不是通的。<br>有很多服务器上可能没有装telnet，也可以用ssh ip 端口  来验证一下。</p><h1 id="3、发送简单的报文测试"><a href="#3、发送简单的报文测试" class="headerlink" title="3、发送简单的报文测试"></a>3、发送简单的报文测试</h1><p>在对端通过发送udp报文来进行简单的测试<br>如日志接收服务器地址是172.28.65.32，端口514 则可以通过<code>echo “hello” &gt; /dev/udp/172.28.65.32/514</code> 来发送测试报文<br>在日志接收服务器用tcpdump收下有没有监听到报文过来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump udp port 514 -A -i any</span><br></pre></td></tr></table></figure><p>如果有就会有相应的显示<br><img src="https://img-blog.csdnimg.cn/20200318100042259.png" alt="tcpdump"></p><h1 id="4、进行正式接口对接"><a href="#4、进行正式接口对接" class="headerlink" title="4、进行正式接口对接"></a>4、进行正式接口对接</h1><p>如果tcpdump可以收到日志，那就说明syslog的通信是没有问题的，接下来就可以进行具体的syslog的配置的调测了。</p><hr><p>作者博客:<a href="http://xiejava.gitee.io" target="_blank" rel="noopener">http://xiejava.gitee.io</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;日志数据采集，比较方便常用的就是通过syslog来进行数据采集，syslog可以通过udp协议来进行高效的数据传输。一般来说在工程实施的过程中需要对接对端系统的数据采集源可以通过以下步骤来进行syslog日志接口的调试。主要是验证syslog日志是否能正常送到指定的日志服务
      
    
    </summary>
    
    
      <category term="技术" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="开发" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="大数据" scheme="http://xiejava.ishareread.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="syslog" scheme="http://xiejava.ishareread.com/tags/syslog/"/>
    
  </entry>
  
  <entry>
    <title>logstash集成kafka，mysql实现数据采集</title>
    <link href="http://xiejava.ishareread.com/posts/54e4fd14/"/>
    <id>http://xiejava.ishareread.com/posts/54e4fd14/</id>
    <published>2020-03-16T09:38:37.000Z</published>
    <updated>2020-03-16T09:40:42.433Z</updated>
    
    <content type="html"><![CDATA[<p>logstash是一个非常灵活好用的数据采集框架工具，可以通过简单的配置满足绝大多数数据采集场景的需求。<br>采集数据一个非常典型的场景就是将数据先放到kafka队列里削峰，然后从kafka队列里读取数据到mysql或其他存储系统中进行保存。<br><img src="https://img-blog.csdnimg.cn/20200316171007439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="从syslog采集日志到kafka然后在从kafka写到mysql数据库中"><br>本文通过一个简单的示例来演示从syslog采集日志到kafka然后在从kafka写到mysql数据库中。<br>默认已经安装好了kafka、mysql、logstash，并已经经过简单的验证。</p><h1 id="准备logstash的环境"><a href="#准备logstash的环境" class="headerlink" title="准备logstash的环境"></a>准备logstash的环境</h1><h2 id="一、下载mysql的jdbc驱动包"><a href="#一、下载mysql的jdbc驱动包" class="headerlink" title="一、下载mysql的jdbc驱动包"></a>一、下载mysql的jdbc驱动包</h2><p>下载地址：<a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java/8.0.15" target="_blank" rel="noopener">https://mvnrepository.com/artifact/mysql/mysql-connector-java/8.0.15</a><br>下载后放到logstash的安装目录的/vendor/jar/目录下</p><h2 id="二、安装logstash插件"><a href="#二、安装logstash插件" class="headerlink" title="二、安装logstash插件"></a>二、安装logstash插件</h2><p>logstash默认安装了kafka插件，但是mysql插件没有默认安装需要自己安装。<br>具体安装方法 /bin/logstash-plugin install logstash-output-jdbc ，这里应为要用到logstash写入mysql数据库，所以安装的插件是logstash-output-jdbc，如果要用到从mysql读数据，那么就要安装logstash-input-jdbc。安装方法类似。<br>因为安装时需要访问国外的源，安装进度很慢很慢，还经常安装不成功，所以需要更改国内的源。<br>也就是给 Ruby 换成国内的镜像站：<a href="https://gems.ruby-china.com/，替代https://rubygems.org。*请注意：国内的镜像站从https://gems.ruby-china.org" target="_blank" rel="noopener">https://gems.ruby-china.com/，替代https://rubygems.org。*请注意：国内的镜像站从https://gems.ruby-china.org</a> 换成了 <a href="https://gems.ruby-china.com" target="_blank" rel="noopener">https://gems.ruby-china.com</a> ！！！* 现在很多网上的资料就都是写的<a href="https://gems.ruby-china.org，导致很多人换了镜像源也装不上。" target="_blank" rel="noopener">https://gems.ruby-china.org，导致很多人换了镜像源也装不上。</a><br>具体方法如下：</p><h3 id="1-安装Gem并更新"><a href="#1-安装Gem并更新" class="headerlink" title="1. 安装Gem并更新"></a>1. 安装Gem并更新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install -y gem</span></span><br><span class="line"><span class="comment"># gem -v</span></span><br><span class="line">2.0.14.1</span><br><span class="line"><span class="comment"># gem update --system</span></span><br><span class="line"><span class="comment"># gem -v</span></span><br><span class="line">2.7.7</span><br></pre></td></tr></table></figure><h3 id="2-检查并修改镜像源"><a href="#2-检查并修改镜像源" class="headerlink" title="2. 检查并修改镜像源"></a>2. 检查并修改镜像源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gem sources -l</span></span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"> </span><br><span class="line">https://rubygems.org/</span><br><span class="line"></span><br><span class="line"><span class="comment"># gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span></span><br><span class="line">https://gems.ruby-china.org/ added to sources</span><br><span class="line">https://rubygems.org/ removed from sources</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat ~/.gemrc </span></span><br><span class="line">---</span><br><span class="line">:backtrace: <span class="literal">false</span></span><br><span class="line">:bulk_threshold: 1000</span><br><span class="line">:sources:</span><br><span class="line">- https://gems.ruby-china.org/</span><br><span class="line">:update_sources: <span class="literal">true</span></span><br><span class="line">:verbose: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><em>请注意：国内的镜像站从<a href="https://gems.ruby-china.org" target="_blank" rel="noopener">https://gems.ruby-china.org</a> 换成了 <a href="https://gems.ruby-china.com" target="_blank" rel="noopener">https://gems.ruby-china.com</a> ！！！现在很多网上的资料就都是写的<a href="https://gems.ruby-china.org，导致很多人换了镜像源也装不上。" target="_blank" rel="noopener">https://gems.ruby-china.org，导致很多人换了镜像源也装不上。</a></em></p><h3 id="3-修改-logstash的-gem-镜像源"><a href="#3-修改-logstash的-gem-镜像源" class="headerlink" title="3. 修改 logstash的 gem 镜像源"></a>3. 修改 logstash的 gem 镜像源</h3><p>cd到logstach的安装目录，可以看到Gemfile文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vi Gemfile</span></span><br><span class="line"><span class="comment"># This is a Logstash generated Gemfile.</span></span><br><span class="line"><span class="comment"># If you modify this file manually all comments and formatting will be lost.</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">source</span> <span class="string">"https://rubygems.org"</span></span><br><span class="line">gem <span class="string">"logstash-core"</span>, :path =&gt; <span class="string">"./logstash-core"</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>更改默认的 <a href="https://rubygems.org" target="_blank" rel="noopener">https://rubygems.org</a> 为<a href="https://gems.ruby-china.com" target="_blank" rel="noopener">https://gems.ruby-china.com</a><br><img src="https://img-blog.csdnimg.cn/20200316171241910.png" alt="更换国内镜像源地址"></p><h3 id="4-安装-logstash-output-jdbc"><a href="#4-安装-logstash-output-jdbc" class="headerlink" title="4. 安装 logstash-output-jdbc"></a>4. 安装 logstash-output-jdbc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/bin/logstash-plugin install logstash-output-jdbc</span></span><br><span class="line">Validating logstash-output-jdbc</span><br><span class="line">Installing logstash-output-jdbc</span><br><span class="line">Installation successful</span><br></pre></td></tr></table></figure><h3 id="5-查看插件是否安装成功"><a href="#5-查看插件是否安装成功" class="headerlink" title="5.查看插件是否安装成功"></a>5.查看插件是否安装成功</h3><p>在logstash的bin目录下执行./logstash-plugin list 可以查看已经安装的插件，可以看到logstash-output-jdbc的插件已经装好。<br><img src="https://img-blog.csdnimg.cn/20200316171324491.png" alt="检查插件安装"></p><h1 id="配置logstash"><a href="#配置logstash" class="headerlink" title="配置logstash"></a>配置logstash</h1><p>新建一个pipline.conf的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="built_in">test</span>-pipeline.conf</span><br></pre></td></tr></table></figure><p>文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    stdin&#123;            #用于测试标准控制台输入的数据</span><br><span class="line">      type =&gt; <span class="string">"test-log"</span></span><br><span class="line">    &#125;</span><br><span class="line">    syslog&#123;           #用于接收来自syslog的日志</span><br><span class="line">        type =&gt; <span class="string">"test-log"</span></span><br><span class="line">        port =&gt; <span class="number">514</span></span><br><span class="line">    &#125;</span><br><span class="line">    kafka &#123;</span><br><span class="line">       bootstrap_servers =&gt; "172.28.65.26:9092" #kafka服务器地址</span><br><span class="line">       topics =&gt; "test1"           #kafka订阅的topic主题</span><br><span class="line">       codec =&gt; "json" #写入的时候使用json编码，因为logstash收集后会转换成json格式</span><br><span class="line">       consumer_threads =&gt; <span class="number">1</span></span><br><span class="line">       decorate_events =&gt; <span class="literal">true</span></span><br><span class="line">       add_field =&gt; &#123;</span><br><span class="line">             <span class="string">"logsource"</span> =&gt; <span class="string">"kafkalog"</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([type]==<span class="string">"test-log"</span> and <span class="string">"kafkalog"</span> not <span class="keyword">in</span> [logsource]) &#123;</span><br><span class="line">       kafka &#123;</span><br><span class="line">            codec =&gt; json</span><br><span class="line">            topic_id =&gt; <span class="string">"test1"</span></span><br><span class="line">            bootstrap_servers =&gt; <span class="string">"172.28.65.26:9092"</span></span><br><span class="line">            batch_size =&gt; <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([type] == <span class="string">"test-log"</span> and <span class="string">"kafkalog"</span> <span class="keyword">in</span> [logsource]) &#123;</span><br><span class="line">        jdbc &#123;</span><br><span class="line">            driver_jar_path =&gt; <span class="string">"/opt/elk/logstash-7.6.0/vendor/jar/jdbc/mysql-connector-java-8.0.15.jar"</span></span><br><span class="line">            driver_class =&gt; <span class="string">"com.mysql.jdbc.Driver"</span></span><br><span class="line">            connection_string =&gt; <span class="string">"jdbc:mysql://172.28.65.32:3306/testdb?user=yourdbuser&amp;password=yourpassword"</span></span><br><span class="line">            statement =&gt; [ <span class="string">"INSERT INTO test_nginx_log (message) VALUES(?)"</span>, <span class="string">"message"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stdout &#123;</span><br><span class="line">       codec =&gt; rubydebug</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个逻辑就是从stdin或syslog接收数据output到kafka,然后从kafka中取出数据加入了一个logsource的字标识是从kafka过来的数据，然后又output到 jdbc写到mysql中去。<br>如果没有这几个if的逻辑判断，那么就会是个死循环。从kafka读同样的数据又写到kafka中。如果在两台机器上装有logstash一台取数据放到kafka,一台从kafka中取数据放到mysql中就可以不用加这样的判断逻辑会单纯简单一些。</p><h1 id="执行logstash并查看效果"><a href="#执行logstash并查看效果" class="headerlink" title="执行logstash并查看效果"></a>执行logstash并查看效果</h1><p>通过在logstash安装目录下执行 bin/logstash -f test-pipeline.conf –config.test_and_exit 检查配置文件是否有问题，没有问题以后执行bin/logstash -f test-pipeline.conf –config.reload.automatic 运行logstash。<br>在控制台输入 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is a <span class="built_in">test</span>!</span><br></pre></td></tr></table></figure><p><strong>效果：</strong><br>从控制台输入信息，可以看到从stdin输入output到stdout的没有logsource标识，input从kafka订阅过来的信息加了一个logsource=&gt;kafkalog的标识。<br><img src="https://img-blog.csdnimg.cn/20200316171423390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="logsource=&gt;kafkalog的标识"><br>用kafka tool工具看到kafka收到了从stdin发过来的信息。<br><img src="https://img-blog.csdnimg.cn/20200316171453670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="用kafka tool工具看到kafka收到了从stdin发过来的信息"><br>在看MySQL表里的数据，已经通过logstash从kafka中将数据采集到了MySQL的表中。<br><img src="https://img-blog.csdnimg.cn/20200316171523708.png" alt="MySQL的表的信息数据"><br>再来看从syslog采集日志的效果<br>从控制台看到的信息效果<br><img src="https://img-blog.csdnimg.cn/20200316171552633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="控制台看到的信息效果"><br>从kafka tool看到的效果<br><img src="https://img-blog.csdnimg.cn/20200316171613337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="kafka tool看到的效果"><br>从mysql 表中看到的效果。<br><img src="https://img-blog.csdnimg.cn/20200316171630325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="mysql 表中看到的效果"><br><strong>可以看到，logstash是一个非常灵活好用的数据采集框架工具，可以通过简单的配置就能满足绝大多数数据采集场景的需求。</strong></p><hr><p>作者博客:<a href="http://xiejava.gitee.io" target="_blank" rel="noopener">http://xiejava.gitee.io</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;logstash是一个非常灵活好用的数据采集框架工具，可以通过简单的配置满足绝大多数数据采集场景的需求。&lt;br&gt;采集数据一个非常典型的场景就是将数据先放到kafka队列里削峰，然后从kafka队列里读取数据到mysql或其他存储系统中进行保存。&lt;br&gt;&lt;img src=&quot;h
      
    
    </summary>
    
    
      <category term="技术" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="开发" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="大数据" scheme="http://xiejava.ishareread.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="ELK" scheme="http://xiejava.ishareread.com/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>解决Hexo博客模板hexo-theme-next的翻页按钮不正常显示问题</title>
    <link href="http://xiejava.ishareread.com/posts/272f3054/"/>
    <id>http://xiejava.ishareread.com/posts/272f3054/</id>
    <published>2020-03-10T08:11:33.000Z</published>
    <updated>2020-03-16T09:38:53.642Z</updated>
    
    <content type="html"><![CDATA[<p>用Hexo搭了个Gitpage的博客，兴冲冲的发了11篇博文后发现翻页按钮不正常显示，显示为<code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>的HTML编码。如下图：<br><img src="https://img-blog.csdnimg.cn/20200310154450109.png" alt="HTML编码"><br><code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>这是个什么鬼？<br>这是一个Font Awesome的字体图标，按道理来说这个图标应该可以正常显示的，现在这个图标不能显示了显示成了html源码。<br><img src="https://img-blog.csdnimg.cn/20200310154516827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="Font Awesone图标"><br><strong>解决办法:</strong><br>最简单的办法就是将<code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>这个不能正常显示的字体图标改成一般的字符，我这里就是改成正常的一般左右键字符“&gt;”，“&lt;”。<br>在 themes\hexo-theme-next\layout_partials 下找到hexo-theme-next的翻页组件，就是pagination.swig<br>将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.prev or page.next %&#125;</span><br><span class="line">  &lt;nav class&#x3D;&quot;pagination&quot;&gt;</span><br><span class="line">    &#123;&#123;</span><br><span class="line">      paginator(&#123;</span><br><span class="line">        prev_text: &#39;&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;&#39;,</span><br><span class="line">        next_text: &#39;&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;&#39;,</span><br><span class="line">        mid_size: 1</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &lt;&#x2F;nav&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.prev or page.next %&#125;</span><br><span class="line">  &lt;nav class&#x3D;&quot;pagination&quot;&gt;</span><br><span class="line">    &#123;&#123;</span><br><span class="line">      paginator(&#123;</span><br><span class="line">        prev_text: &#39;&lt;&#39;,</span><br><span class="line">        next_text: &#39;&gt;&#39;,</span><br><span class="line">        mid_size: 1</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &lt;&#x2F;nav&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>重新发布以后可以看到翻页按钮可以正常显示了<br><img src="https://img-blog.csdnimg.cn/20200310154621131.png" alt="正常显示箭头"></p><hr><p>作者博客:<a href="http://xiejava.gitee.io" target="_blank" rel="noopener">http://xiejava.gitee.io</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用Hexo搭了个Gitpage的博客，兴冲冲的发了11篇博文后发现翻页按钮不正常显示，显示为&lt;code&gt;&amp;lt;i class=&amp;quot;fa fa-angle-right&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;&lt;/code&gt;的HTML编码。如下图：&lt;br&gt;&lt;img sr
      
    
    </summary>
    
    
      <category term="技术" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="开发" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Hexo" scheme="http://xiejava.ishareread.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>通过filebeat、logstash、rsyslog采集nginx日志的几种方式</title>
    <link href="http://xiejava.ishareread.com/posts/f3e97829/"/>
    <id>http://xiejava.ishareread.com/posts/f3e97829/</id>
    <published>2020-03-09T15:13:51.000Z</published>
    <updated>2020-03-10T06:56:34.838Z</updated>
    
    <content type="html"><![CDATA[<p>由于nginx功能强大，性能突出，越来越多的web应用采用nginx作为http和反向代理的web服务器。而nginx的访问日志不管是做用户行为分析还是安全分析都是非常重要的数据源之一。如何有效便捷的采集nginx的日志进行有效的分析成为大家关注的问题。本文通过几个实例来介绍如何通过filebeat、logstash、rsyslog采集nginx的访问日志和错误日志。</p><p>大家都知道ELK技术栈是采集、分析日志的利器。所以这里介绍的是从nginx采集日志到ES。当然至于日志采集以后存到看大家的需要。通过logstash可以方便的配置日志输出存储的方式。</p><p>一般来说nginx默认安装后，日志文件在 /usr/local/nginx/logs 目录下。分别有 access.log和error.log 访问日志和错误日志。<br>这次示例Elasitcsearch是三个节点组成的集群172.28.65.22、172.28.65.23、172.28.65.24，172.28.65.30 是kibana的地址，172.28.65.32是数据采集服务器，上面装有logstash、nginx、 filebeat。一般来说采集服务器上有logstash，而nginx、 filebeat应该是装在采集目标上。</p><h2 id="一、直接通过filebeat采集日志到ES"><a href="#一、直接通过filebeat采集日志到ES" class="headerlink" title="一、直接通过filebeat采集日志到ES"></a>一、直接通过filebeat采集日志到ES</h2><p><img src="https://img-blog.csdnimg.cn/20200309222757224.png" alt="filebeat到ES"><br>在filebeat的安装目录找到filebeat.yml 配置获取日志文件的路径及输出到ES的配置。<br> 具体：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- type: log</span><br><span class="line">  <span class="comment"># Change to true to enable this input configuration.</span></span><br><span class="line">  enabled: true</span><br><span class="line">  <span class="comment"># Paths that should be crawled and fetched. Glob based paths.</span></span><br><span class="line">  paths:</span><br><span class="line">    <span class="comment">#- /var/log/*.log</span></span><br><span class="line">    - /usr/local/nginx/logs/*.log</span><br><span class="line">    <span class="comment">#- c:\programdata\elasticsearch\logs\*</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309222853340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="filebeat.yml配置"><br>如果需要在kibana中友好显示的化，可进行kibana配置<br><img src="https://img-blog.csdnimg.cn/20200309222955878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="kibana配置"><br>输出到es中，在hosts中配置好你的ES服务地址。如果单机只有一个节点，就可以只配一个ip和端口。<br><img src="https://img-blog.csdnimg.cn/20200309223104639.png" alt="filebeat.yml配置中配置es"><br>启动filebeat 进行日志数据采集</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filebeat <span class="literal">-e</span> <span class="literal">-c</span> filebeat.yml <span class="literal">-d</span> <span class="string">"publish"</span></span><br></pre></td></tr></table></figure><p>通过elasticsearch-head插件查看es索引中的日志信息<br><img src="https://img-blog.csdnimg.cn/20200309223159337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="elasticsearch-head插件查看es索引"><br>可以看到nginx中的access.log和error.log的日志都已经上来了。<br>在kibana中通过filebeat-*过滤看filebeat的索引，可以看到通过filebeat采过来的数据。</p><p><img src="https://img-blog.csdnimg.cn/20200309223308928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="kibana中通过filebeat-*过滤看filebeat的索引"><br>这种直接通过filebeat直接对接ES采日志的方式简单直接，但是无法对采集的日志进行预处理和其他一些操作，也不够灵活。<br>可以在filebeat 和 ES之间加一层Logstash，可以将filebeat于ES解耦，通过Logstash可以做一些预处理，也可以通过Logstash采集到除ES以外的其他数据存储上。</p><h2 id="二、通过filebeat采集日志到logstash再送到ES"><a href="#二、通过filebeat采集日志到logstash再送到ES" class="headerlink" title="二、通过filebeat采集日志到logstash再送到ES"></a>二、通过filebeat采集日志到logstash再送到ES</h2><p><img src="https://img-blog.csdnimg.cn/20200309223343261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="通过filebeat采集日志到logstash再送到ES"><br>首先得安装 logstash ，安装完后在logstash的安装目录下新建vi filebeat-pipeline.conf<br>filebeat-pipeline.conf的具体配置如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    beats &#123;</span><br><span class="line">        port =&gt; <span class="string">"5044"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123; hosts =&gt; [<span class="string">"172.28.65.24:9200"</span>] &#125;</span><br><span class="line">    stdout &#123; codec =&gt; rubydebug&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input配置表示通过5044端口接收beats的数据<br>output配置表示输出到elasticsearch，并且同时输出到标准输出也就是控制台。<br>然后通过命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash <span class="operator">-f</span> filebeat<span class="literal">-pipeline</span>.conf -<span class="literal">-config</span>.reload.automatic</span><br></pre></td></tr></table></figure><p>应用filebeat-pipeline.conf启动logstash。<br><img src="https://img-blog.csdnimg.cn/20200309223435991.png" alt="应用filebeat-pipeline.conf启动logstash"><br>启动以后可以看到logstash的启动日志5044端口的服务已经起了，可以接受通过filebeat通过5044端口传过来的数据了。<br>接下来配置filebeat<br>在filebeat的安装目录找到filebeat.yml 配置获取日志文件的路径及输出到logstash的配置。不直接输出到ES了。<br>具体配置如下：<br>将output.elasticsearch的配置屏蔽<br>配置output.logstash，配置正确的logstash的服务主机和端口<br><img src="https://img-blog.csdnimg.cn/20200309223511426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="配置output.logstash"><br>启动filebeat 进行日志数据采集</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filebeat <span class="literal">-e</span> <span class="literal">-c</span> filebeat.yml <span class="literal">-d</span> <span class="string">"publish"</span></span><br></pre></td></tr></table></figure><p>我们访问nginx服务提供的web服务<a href="http://172.28.65.32/" target="_blank" rel="noopener">http://172.28.65.32/</a><br>在logstash的控制台 可以看到相应的访问access.log 日志<br><img src="https://img-blog.csdnimg.cn/20200309223557623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="logstash的控制台 可以看到相应的访问access.log 日志"><br>同时在ES 中也可以看到有相应的日志数据<br><img src="https://img-blog.csdnimg.cn/20200309223625788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="在ES 中也可以看到有相应的日志数据"></p><h2 id="三、直接通过rsyslog采集日志到logstash在送到ES"><a href="#三、直接通过rsyslog采集日志到logstash在送到ES" class="headerlink" title="三、直接通过rsyslog采集日志到logstash在送到ES"></a>三、直接通过rsyslog采集日志到logstash在送到ES</h2><p>在很多情况下你需要采集的web服务器并不是自己能够控制的，不是说你想装filebeat就可以让你装的，这时候就可以要求目标数据源通过 syslog  的方式将日志发出来。我们可以再通过 logstash送到ES或其他的日志存储处理平台。<br><img src="https://img-blog.csdnimg.cn/2020030922365724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="直接通过rsyslog采集日志到logstash在送到ES"><br>通过syslog往日志服务器上发nginx的日志有两种方式，一种就是利用nginx的配置往外发日志，一种就是通过配置linux的rsyslog的配置往外发日志。</p><h3 id="通过nginx配置发送syslog到logstash"><a href="#通过nginx配置发送syslog到logstash" class="headerlink" title="通过nginx配置发送syslog到logstash"></a>通过nginx配置发送syslog到logstash</h3><p>参考见nginx官方文档：<a href="http://nginx.org/en/docs/syslog.html" target="_blank" rel="noopener">http://nginx.org/en/docs/syslog.html</a><br>具体配置如下：<br>在nginx的配置文件nginx.conf中<br>在server下配置access_log和error_log的输出方式</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">access_log syslog:server=<span class="number">172.28</span>.<span class="number">65.32</span>:<span class="number">514</span>,facility=local7,tag=nginx_access_log,severity=info;</span><br><span class="line">error_log syslog:server=<span class="number">172.28</span>.<span class="number">65.32</span>:<span class="number">514</span>,facility=local7,tag=nginx_error_log,severity=info;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020030922391711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="nginx.conf配置"><br>配置完成后执行 <code>./nginx -s reload</code> 使配置生效。这样就通过linux的rsyslog服务将nginx的日志往外发了。<br>接着来配置logstash的syslog的服务接收配置 。在logstash的安装目录下新建<code>vi syslog-pipeline.conf</code><br>syslog-pipeline.conf的具体配置如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    syslog&#123;</span><br><span class="line">        type =&gt; <span class="string">"system-syslog"</span></span><br><span class="line">        port =&gt; <span class="number">514</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [<span class="string">"172.28.65.24:9200"</span>]</span><br><span class="line">        index =&gt; <span class="string">"system-syslog-%&#123;+YYYY.MM&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">    stdout &#123; codec =&gt; rubydebug&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input配置表示通过514端口接收syslog的数据<br>output配置表示输出到elasticsearch，并且同时输出到标准输出也就是控制台。<br>通过执行 <code>bin/logstash -f syslog-pipeline.conf --config.reload.automatic</code> 启动logstash<br><img src="https://img-blog.csdnimg.cn/20200309224021167.png" alt="可以看到logstash启动以后开启了514端口的tcp和upd协议的侦听"><br>可以看到logstash启动以后开启了514端口的tcp和upd协议的侦听。<br>我们访问nginx服务提供的web服务<a href="http://172.28.65.32/" target="_blank" rel="noopener">http://172.28.65.32/</a><br>在logstash的控制台 可以看到相应的nginx访问access和error的日志<br><img src="https://img-blog.csdnimg.cn/20200309224058280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="logstash的控制台可以看到相应的nginx访问access和error的日志"><br>同样通过Elasticsearch-head在ES 中也可以看到有相应的日志数据<br><img src="https://img-blog.csdnimg.cn/20200309224153318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="通过Elasticsearch-head在ES 中也可以看到有相应的日志"></p><h3 id="通过配置rsyslog发送syslog日志到logstash"><a href="#通过配置rsyslog发送syslog日志到logstash" class="headerlink" title="通过配置rsyslog发送syslog日志到logstash"></a>通过配置rsyslog发送syslog日志到logstash</h3><p>有些老版本的nginx不支持配置syslog输出日志，或者说我想输出其他不是nginx的日志该怎么办呢？可以通过直接配置rsyslog的方式来往外发送日志。<br>在/etc/rsyslog.conf 中配置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$IncludeConfig</span> /etc/rsyslog.d/*.conf</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309224226484.png" alt="/etc/rsyslog.conf"><br>意思是可以引用外部的配置文件，引用外部的配置文件一方面可以不影响主配置文件，另一方面也比较好管理<br>在/etc/rsyslog.d目录下新建nginx-log.conf<br>配置如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ModLoad</span> imfile</span><br><span class="line"><span class="variable">$InputFilePollInterval</span> <span class="number">1</span></span><br><span class="line"><span class="variable">$WorkDirectory</span> /var/spool/rsyslog</span><br><span class="line"><span class="variable">$PrivDropToGroup</span> adm</span><br><span class="line"></span><br><span class="line"><span class="comment">##Nginx访问日志文件路径，根据实际情况修改:</span></span><br><span class="line"><span class="variable">$InputFileName</span> /usr/local/nginx/logs/access.log</span><br><span class="line"><span class="variable">$InputFileTag</span> nginx<span class="literal">-access</span>:</span><br><span class="line"><span class="variable">$InputFileStateFile</span> stat<span class="literal">-nginx</span><span class="literal">-access</span></span><br><span class="line"><span class="variable">$InputFileSeverity</span> info</span><br><span class="line"><span class="variable">$InputFilePersistStateInterval</span> <span class="number">25000</span></span><br><span class="line"><span class="variable">$InputRunFileMonitor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##Nginx错误日志文件路径，根据实际情况修改:</span></span><br><span class="line"><span class="variable">$InputFileName</span> /usr/local/nginx/logs/error.log</span><br><span class="line"><span class="variable">$InputFileTag</span> nginx<span class="literal">-error</span>:</span><br><span class="line"><span class="variable">$InputFileStateFile</span> stat<span class="literal">-nginx</span><span class="literal">-error</span></span><br><span class="line"><span class="variable">$InputFileSeverity</span> error</span><br><span class="line"><span class="variable">$InputFilePersistStateInterval</span> <span class="number">25000</span></span><br><span class="line"><span class="variable">$InputRunFileMonitor</span></span><br><span class="line"></span><br><span class="line">*.* @<span class="number">172.28</span>.<span class="number">65</span>:<span class="number">514</span></span><br></pre></td></tr></table></figure><p>配置好了以后，重启rsyslog服务</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rsyslog</span><br></pre></td></tr></table></figure><p>我们访问nginx服务提供的web服务<a href="http://172.28.65.32/" target="_blank" rel="noopener">http://172.28.65.32/</a><br>在logstash的控制台 可以看到同样的效果。<br><img src="https://img-blog.csdnimg.cn/20200309224257449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="logstash的控制台"></p><p>本文介绍了如何通过filebeat、logstash、rsyslog采集nginx的访问日志和错误日志的几种方式，具体需要根据实际情况灵活的运用。</p><hr><p>作者博客:<a href="http://xiejava.gitee.io" target="_blank" rel="noopener">http://xiejava.gitee.io</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于nginx功能强大，性能突出，越来越多的web应用采用nginx作为http和反向代理的web服务器。而nginx的访问日志不管是做用户行为分析还是安全分析都是非常重要的数据源之一。如何有效便捷的采集nginx的日志进行有效的分析成为大家关注的问题。本文通过几个实例来介
      
    
    </summary>
    
    
      <category term="技术" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="开发" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="大数据" scheme="http://xiejava.ishareread.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="ELK" scheme="http://xiejava.ishareread.com/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>浅析SIEM、态势感知平台、安全运营中心</title>
    <link href="http://xiejava.ishareread.com/posts/e29f28e5/"/>
    <id>http://xiejava.ishareread.com/posts/e29f28e5/</id>
    <published>2020-03-02T13:50:03.000Z</published>
    <updated>2020-03-02T13:53:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>近年来SIEM、态势感知平台、安全运营中心等概念炒的火热，有的人认为这都是安全管理产品，这些产品就是一回事，有人认为还是有所区分。那么到底什么是SIEM、什么是态势感知平台、什么是安全运营中心，他们之间有什么联系和区别呢？</p><h1 id="一、SIEM"><a href="#一、SIEM" class="headerlink" title="一、SIEM"></a>一、SIEM</h1><p>SIEM英文是security information and event managemen安全信息和事件管理<br>SIEM是一个由多个监视和分析组件组成的安全系统，旨在帮助组织检测和减轻威胁<br>一款典型的SIEM产品是将许多其他安全规则和工具结合在一个综合的框架下形成的一个合集。<br>典型的包括以下模块<br>日志管理(LMS)——用于传统日志收集和存储的工具。<br>安全信息管理(SIM)——集中于从多个数据源收集和管理与安全相关的数据的工具或系统。例如，这些数据源可以是防火墙、DNS服务器、路由器和防病毒应用程序。<br>安全事件管理(SEM)——基于主动监视和分析的系统，包括数据可视化、事件相关性和警报<br>大多数的SIEM包括以下元素<br><strong>1、安全数据采集</strong><br>主要是基于安全日志数据，日志表示在数字环境中运行的进程的原始输出，是提供实时发生的事情的准确图像的最佳来源，因此是SIEM系统的主要数据源。无论是防火墙日志、服务器日志、数据库日志，还是在实际网络环境中生成的任何其他类型的日志，SIEM系统都能够收集这些数据并将其存储在一个中心位置以进行扩展的保留。此采集过程通常由代理或应用程序执行，部署在监视的系统上，并配置为将数据转发到SIEM系统的中央数据存储。<br><strong>2、安全数据解析处理和标准化</strong><br>为了能够跨不同源和事件相关性高效地解释数据，SIEM系统能够规范化日志。这个规范化过程包括将日志处理为可读的结构化格式，从日志中提取重要数据，并映射日志中包含的不同字段。<br><strong>3、安全数据集中存储</strong><br>安全信息数据存储的目地当然是为了利用数据进行管理分析发现安全事件。<br><strong>4、安全数据分析</strong><br>一旦收集、解析和存储，SIEM系统中的下一步将负责连接这些点并关联来自不同数据源的事件。这种关联工作基于各种SIEM工具提供的规则、为不同的攻击场景预定义的规则，或者由分析人员创建和调整的规则。大多数SIEM系统还提供生成报告的内置机制。这些报告可以用于管理、审计或合规性原因。例如，可以将详细描述触发警报或规则的每日报告嵌入到仪表板中。<br><strong>5、安全数据呈现</strong><br>可视化数据和事件的能力是SIEM系统中的另一个关键组件，因为它允许分析人员方便地查看数据。包含多个可视化或视图的仪表板有助于识别趋势、异常情况，并监控环境的总体健康或安全状态。一些SIEM工具将附带预先制作的仪表板，而另一些工具将允许用户创建和调整自己的仪表板。<br>基于目前海量的安全信息数据，<strong>大数据架构已经成为主流</strong>。并不是说SIEM必须使用大数据架构，因为这是一个应用场景问题而非技术问题。但面对大量数据需要处理的场景时，基于大数据架构的SIEM则必不可少。所以有些厂商提出了SDC（security data center）安全大数据中心的概念就是把所有的安全数据集中管理起来，在SDC的基础上构建安全数据分析和展现能力，形成SIEM平台。</p><p>目前成熟的SIEM产品有很多，开源的有OSSIM、Elastic SIEM、Opensoc<br>OSSIM是SIEM的代表性产品，在产品形式上和Kali类似是一个基于Debain进行二次开发的Linux发行版，当前5.6.5版本基于Dibian 8（jessie）。<br>OSSIM使用Nmap等实现资产发现、使用Nessus等实现漏洞扫描、使用Snort等实现入侵检测、使用MySQL等进行数据存储，自己实现的部分主要是工具、数据整合和可视化展示。ossim存储架构是mysql，支持多种日志格式，包括鼎鼎大名的Snort、Nmap、 Nessus以及Ntop等，对于数据规模不大的情况是个不错的选择，新版界面很酷炫<br>从架构上来看，OSSIM系统是一个开放的框架，它的核心价值在于创新的集成各开源软件之所长，它里面的模块既有C/S架构，又有B/S架构，但作为最终用户主要掌握OSSIM WebUI主要采用B/S架构，Web服务器使用Apache。OSSIM系统结构示意图如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200302211541393.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第1层，属于数据采集层，使用各种采集技术采集流量信息、日志、各种资产信息，经过归一化处理后传入核心层。改层体现安全事件来源，入侵检测、防火墙、重要主机发出的日志都是安全事件来源，它们按发出机制分为两类：模式侦查器和异常监控（两者都采集警告信息，功能互补）由它们采集的安全事件，再被Agent转换为统一的格式发到OSSIM服务器，这一层就是Sensor要完成的内容。<br>第2层，属于核心处理层，主要实现对各种数据的深入加工处理，包括运行监控、安全分析、策略管理、风险评估、关联分析、安全对象管理、脆弱性管理、事件管理、报表管理等。该层中OSSIM Server是主角，OSSIM服务器，主要功能是安全事件的集中并对集中后的事件进行关联分析、风险评估及严重性标注等。所谓的集中就是以一种统一格式组织所有系统产生的安全事件告警信息（Alarms）并将所有的网络安全事件告警存储到数据库，这样就完成了对网络中所产生事件的一个庞大视图。系统通过事件序列关联和启发式算法关联来更好的识别误报和侦查攻击的能力。<br>OSSIM本质上通过对各种探测器和监控产生的告警进行格式化处理，再进行关联分析，通过后期这些处理能提高检测性能，即减少告警数量，减小关联引擎的压力，从整体上提高告警质量。<br>第3层，属于数据展现层，主要负责完成与用户之间的交互，达到安全预警和事件监控、安全运行监控、综合分析的统一展示，形式上以图形化方式展示给用户。Web框架(Framework)控制台界面即OSSIM的Web UI（Web User Interface，Web用户界面），其实就是OSSIM系统对外的门户站点，它主要由仪表盘、SIEM控制台、Alarm控制台、资产漏洞扫描管理、可靠性监控、报表及系统策略等部分组成。<br>OSSIM主要模块的关系<br>OSSIM系统主要使用了PHP、Python、Perl和C等四种编程语言，从软件层面上看OSSIM框架系统包括五大模块：Agent模块、Server模块、Database数据库模块、Frameworkd模块以及Framework模块，逻辑结构如图所示。<br><img src="https://img-blog.csdnimg.cn/20200302213041778.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Elastic SIEM 的核心是全新的 SIEM 应用，此应用是安全团队的交互式工作空间，可允许他们对事件进行分类并开展初期调查。其中包括的时间线事件查看器 (Timeline Event Viewer) 能够允许分析师收集和存储攻击证据，固定相关活动并添加注释，以及添加评论并分享他们的发现，而且这一切在 Kibana 中即可完成；这样一来，您便能够轻松处理符合 ECS 格式的任何数据了。<br><img src="https://img-blog.csdnimg.cn/20200302213101396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">Opensoc是思科2014年在BroCon大会上公布的开源项目，但是没有真正开源其源代码，只是发布了其技术框架。可以参考Opensoc发布的架构，结合实际落地SIEM的方案。Opensoc完全基于开源的大数据框架kafka、storm、spark和es等，天生具有强大的横向扩展能力<br><img src="https://img-blog.csdnimg.cn/20200302213127295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>所以从SIEM的定义和功能来看有两个核心能力，一个是安全信息数据的采集汇聚能力，一个就是安全事件的分析能力。</strong></p><h1 id="二、安全态势感知平台"><a href="#二、安全态势感知平台" class="headerlink" title="二、安全态势感知平台"></a>二、安全态势感知平台</h1><p>“态势感知”早在 20 世纪 80 年代由美国空军提出，其包含感知、理解和预测三个层次。截止目前，业界对网络安全态势感知还没有一个统一全面的定义，基于美国Endsley 博士的理论对网络安全态势感知做出的定义：“网络安全态势感知是综合分析网络安全要素，评估网络安全状况，预测其发展趋势，并以可视化的方式展现给用户，并给出相应的报表和应对措施。”<br>什么是态势感知平台，大家都认为应该是利用大数据、机器学习等技术对态势感知态势海量数据进行提取，进行多维度的关联分析。能够提供对安全风险保持报警、趋势预测等，海量数据、关联分析、大屏展示和趋势预测是四个重点。而趋势预测最核心，目前做起来也比较难。<br>个人理解，<strong>SIEM重点在于对安全事件的感知和理解，态势感知重点在于通过大数据、机器学习等技术加深了对安全趋势的预测</strong>。国外一般不提态势感知系统，而国内，很多厂商都推出了态势感知系统。<br>目前国内安全厂商提供的“态势感知产品”包含的功能模块有：资产管理、漏洞管理、大数据平台、日志分析平台、威胁情报、沙箱、用户行为分析、网络流量分析、取证溯源、威胁捕捉等能力。<br>几个关键点：<br>1、 大数据平台。随着监测范围的扩大，数据量也在扩大，需要一个具备大数据处理和计算能力的平台，这是整个态势感知平台建设很重要的基础。<br>2、 基于威胁情报的监测。威胁情报对于降低大量数据和报警中的垃圾数据或者报警噪声，帮助更快速、更高效的发现攻击行为和攻击者非常关键，威胁情报的质量是检验态势感知平台能力的很重要的方面。<br>3、 全要素数据的采集。利用态势感知这样的平台能力的核心目的，是要监测到复杂的、高级的攻击，就需要态势感知平台首先要捕获到微观的状态，低成本、高效率的全要素数据采集能力是基础。<br>4、 基于攻击场景的分析研判。攻击不再是基于特征的监测，需要运用威胁情报、运用一些专家的经验，来构建基于场景的分析系统，它不是一个静态的东西，是一个与时俱进的攻防对抗过程中不断学习、学习参考的过程，需要持续运营这样的分析管理，需要更多的专家的经验和安全运营人员的参与。</p><h1 id="三、安全运营中心"><a href="#三、安全运营中心" class="headerlink" title="三、安全运营中心"></a>三、安全运营中心</h1><p>SOC（安全运营中心）来源于NOC（网络运营中心）。<br>随着信息安全问题的日益突出，安全管理理论与技术的不断发展，需要从安全的角度去管理整个网络和系统，而传统的NOC在这方面缺少技术支撑，于是，出现了SOC的概念。<br>以前大家所说的SOC是SOC 1.0阶段，只是在SOC的核心部件SIEM的买卖，国外所说的SOC是一个复杂的系统，它使用SIEM产品进行运维又以此向客户提供服务，也就是我们所说的SOC 2.0<br>SOC(安全运营中心)是以资产为核心，以安全事件管理为关键流程，采用安全域划分的思想，建立一套实时的资产风险模型，协助管理员进行事件及风险分析，预警管理，应急响应的集中安全管理系统。<br>SOC是一个复杂的系统，它既有产品，又有服务，还有运维，SOC是技术、流程和人的有机结合。<br>随着<strong>安全态势感知平台的兴起，安全运营中心将以态势感知平台作为智能安全运营的载体</strong>，在风险监测、分析研判、通知协作、响应处置、溯源取证等各方面进行了增强，同时融入了当前流行的技术和平台作为支撑，如大数据技术、东西向流量采集技术，EDR 终端检测响应技术、机器学习、欺骗攻击技术等。同时态势感知平台与 ITIL（Information Technology Infrastructure Library，ITIL）理念与信息安全管理标准相融合，将安全运营划分为不同角色，如安全管理人员、安全专家、安全运维、安全分析师、安全应急响应人员、安全研究人员等，在集成了安全事件管理全生命周期的流程中，通过工作流程将其串联起来，使安全运营流程更加规范和有序。</p><p><strong>所以个人认为SDC&lt;SIEM&lt;态势感知&lt;安全运营中心</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近年来SIEM、态势感知平台、安全运营中心等概念炒的火热，有的人认为这都是安全管理产品，这些产品就是一回事，有人认为还是有所区分。那么到底什么是SIEM、什么是态势感知平台、什么是安全运营中心，他们之间有什么联系和区别呢？&lt;/p&gt;
&lt;h1 id=&quot;一、SIEM&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="网络安全" scheme="http://xiejava.ishareread.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="网络安全" scheme="http://xiejava.ishareread.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>通过Git Pages+Hexo搭建自己的博客</title>
    <link href="http://xiejava.ishareread.com/posts/79ebd763/"/>
    <id>http://xiejava.ishareread.com/posts/79ebd763/</id>
    <published>2020-02-12T07:41:23.000Z</published>
    <updated>2020-02-12T07:57:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、申请并配置Github-Pages"><a href="#一、申请并配置Github-Pages" class="headerlink" title="一、申请并配置Github Pages"></a>一、申请并配置Github Pages</h1><h2 id="step1-在github上创建一个git库"><a href="#step1-在github上创建一个git库" class="headerlink" title="step1 在github上创建一个git库"></a>step1 在github上创建一个git库</h2><p>用github账号登录<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> ，如没有github账号则申请一个github账号。登录后点击“New repository”新建一个名为username.github.io（username是你的github用户名）如我的是：xiejava1018.github.io ，如果库名以及存在则会报库名已经存在的错误。<br><img src="https://img-blog.csdnimg.cn/20200212151727627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="新建库"></p><h2 id="step2-绑定自己的域名（如果没有自己的域名也可以不绑）"><a href="#step2-绑定自己的域名（如果没有自己的域名也可以不绑）" class="headerlink" title="step2 绑定自己的域名（如果没有自己的域名也可以不绑）"></a>step2 绑定自己的域名（如果没有自己的域名也可以不绑）</h2><p>访问刚申请的git库，点击Settings<br><img src="https://img-blog.csdnimg.cn/20200212151814995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="Settings"><br>如果库名不是username.github.io（username是你的github用户名）在这里可以修改成username.github.io<br><img src="https://img-blog.csdnimg.cn/202002121518548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="修改库名"><br>拖到下面可以看到GitHub Pages的信息，如果不绑定自己的域名实际可以通过<a href="https://username.github.io/来访问你的站点了。" target="_blank" rel="noopener">https://username.github.io/来访问你的站点了。</a><br><img src="https://img-blog.csdnimg.cn/20200212151939704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="站点地址"><br>如果有申请自己的域名，可以将域名解析到你的GithubPages username.github.io 如我的是xiejava1018.github.io<br><img src="https://img-blog.csdnimg.cn/20200212152026730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="解析自定义域名"><br>在GitHub Pages的自定义域名Custom domain中输入刚解析的域名保存后就可以看到你的站点被发布到你的域名上了，如<a href="https://xiejavablog.ishareread.com/" target="_blank" rel="noopener">https://xiejavablog.ishareread.com/</a><br><img src="https://img-blog.csdnimg.cn/20200212152056432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="绑定自定义域名"><br>这时候你就可以用自己的域名来访问GitHub Pages的网站了，不过现在什么都没有，只有个空白页面。这就需要我们借助Hexo这个静态站点生成工具来生我们站点的内容了。</p><h1 id="二、安装Hexo并生成站点"><a href="#二、安装Hexo并生成站点" class="headerlink" title="二、安装Hexo并生成站点"></a>二、安装Hexo并生成站点</h1><p>安装Hexo并生成站点可以参考官方的文档 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a>  </p><h2 id="1、安装前的准备"><a href="#1、安装前的准备" class="headerlink" title="1、安装前的准备"></a>1、安装前的准备</h2><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：<br>Node.js (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)<br>Git</p><h2 id="2、安装Hexo"><a href="#2、安装Hexo" class="headerlink" title="2、安装Hexo"></a>2、安装Hexo</h2><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完了以后可以通过hexo version 查看相应的版本<br><img src="https://img-blog.csdnimg.cn/2020021215253021.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="版本信息"></p><h2 id="3、生成站点"><a href="#3、生成站点" class="headerlink" title="3、生成站点"></a>3、生成站点</h2><p>安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：<br><img src="https://img-blog.csdnimg.cn/20200212152343204.png" alt="目录"><br>其中_config.yml 文件是网站的配置文件<br>package.json 是应用程序的信息<br>scaffolds<br>模版文件夹。当新建文章时，Hexo 会根据 scaffold 来建立文件。<br>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。<br>source<br>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。<br>themes<br>主题 文件夹。Hexo 会根据主题来生成静态页面。</p><h2 id="4、安装主题"><a href="#4、安装主题" class="headerlink" title="4、安装主题"></a>4、安装主题</h2><p>Hexo提供了很多主题，我用的是hexo-theme-next主题，大家可以直接克隆我的主题<a href="https://github.com/xiejava1018/hexo-theme-next.git" target="_blank" rel="noopener">https://github.com/xiejava1018/hexo-theme-next.git</a> 这里修复了一些bug如乱码问题等。<br>cd 切换到站点目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/xiejava1018/hexo-theme-next.git themes/hexo-theme-next</span><br></pre></td></tr></table></figure><p>也可以用其他git客户端工具将主题拉取到themes目录下<br>修改_config.yml文件的theme改为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme :</span> <span class="string">hexo-theme-next</span></span><br></pre></td></tr></table></figure><h2 id="5、写作"><a href="#5、写作" class="headerlink" title="5、写作"></a>5、写作</h2><p>可以执行下列命令来创建一篇新文章或者新的页面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。<br>如执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 2020-02-11-2020-02-11-看完全套149本《书虫》是种什么样的体验</span><br></pre></td></tr></table></figure><p>执行该命令后就会在响应的站点目录的source_posts下生成2020-02-11-看完全套149本《书虫》是种什么样的体验.md文件。<br><img src="https://img-blog.csdnimg.cn/2020021215265521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1bGxidWc=,size_16,color_FFFFFF,t_70" alt="文件"><br>用任何喜欢的编辑器编辑这个.md文件即可，排版是支持MarkDown的。</p><h2 id="6、生成和发布"><a href="#6、生成和发布" class="headerlink" title="6、生成和发布"></a>6、生成和发布</h2><p>编辑好需要发表的内容后。执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>就会生成相应的静态文件。改命令也可以简写成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就可以通过该地址访问本地的站点。<br>在本地检查没有问题以后就可以发布到Github Pages上通过互联网上访问了。<br>首先在配置_config.yml文件配置需要发布的地址。这个地址就是你在github上申请的Github Pages库的git地址<br><img src="https://img-blog.csdnimg.cn/20200212152738164.png" alt="发布地址配置"><br>然后就可以通过命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>进行发布了。发布以后就可以通过<a href="https://xiejava1018.github.io" target="_blank" rel="noopener">https://xiejava1018.github.io</a> 或者自定义的域名 <a href="https://xiejavablog.ishareread.com" target="_blank" rel="noopener">https://xiejavablog.ishareread.com</a> 来访问了。需要注意的是，每次重新发布以后，需要重新设置域名绑定才能正确访问，否则会报404的错误。</p><p>欢迎大家访问我的BLOG  <a href="https://xiejavablog.ishareread.com/" target="_blank" rel="noopener">https://xiejavablog.ishareread.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、申请并配置Github-Pages&quot;&gt;&lt;a href=&quot;#一、申请并配置Github-Pages&quot; class=&quot;headerlink&quot; title=&quot;一、申请并配置Github Pages&quot;&gt;&lt;/a&gt;一、申请并配置Github Pages&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="技术" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="开发" scheme="http://xiejava.ishareread.com/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Hexo" scheme="http://xiejava.ishareread.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>看完全套149本《书虫》是种什么样的体验</title>
    <link href="http://xiejava.ishareread.com/posts/40bbedc5/"/>
    <id>http://xiejava.ishareread.com/posts/40bbedc5/</id>
    <published>2020-02-11T02:23:10.000Z</published>
    <updated>2020-02-14T08:00:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200211/blogimage/english.png" alt="English" title="English"></p><p>一直想学好英语，可惜一直在陷入”从入门到放弃”的怪圈，这么多年来一直尝试各种方式方法来学英语始终未成正果。当然这一切都归因于自己没有恒心没有毅力。有过坚持了330天终于放弃了背单词的经历，也找了很多如何学好英语的书籍和方法。受了李笑来老师的《人人都能用英语》及伍君仪的《把你的词汇用起来》的影响。经过自己仔细思考认为确实如果要把英语学好必须要用起来。考虑到自己的实际情况，没有相应的语言环境，从听说开始用起来可能也不太现实，最现实的方式就是从大量的阅读开始将英语用起来。即学了知识又学了英语，还没有那么枯燥。</p><p>如何开始阅读，读什么东西呢？自己的水平还没有达到能够读懂英文原版书的程度，望着满片英文的原版书还是心生畏惧。也是在网上看大家学习英语的经验，有人就介绍了阅读的方式方法。初学者一开始就不要挑战太高难度了，容易打击自己的自信心。最好的方式是采取分级阅读的方式，阅读i+1的英语材料。也就是阅读比自己能力稍微高一点的英语材料。在找英语阅读的材料过程中发现了很多人推荐了《书虫》，也就是”书虫·牛津英汉双语读物”，这套读物是外语教学与研究出版社和牛津大学出版社联袂奉献给英语学习者的一大分级阅读精品书系，提供了从小学高年级至大学的全套阅读方案。图书按照词汇量和语言难度进行科学分级。共分了七个级别，15套，共149本书。</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200211/blogimage/%E4%B9%A6%E8%99%AB2.png" alt="《书虫》系列" title="《书虫》系列"></p><p>我觉得这套读物比较适合像我这样的初学者。离开学校多年了，也不知道自己的英语水平究竟是属于什么级别，抱着空杯的心态，干脆就从最低级的开始看起（想想还可以给小孩看）。我是2019年6月18日购买的全套，从快递点搬回来的时候一大箱子很重。看着这满满一箱足足149本，比较兴奋又比较忐忑。兴奋的是我终于可以开始我的英语阅读之旅了，忐忑的是这也149本也忒多了吧？从来没有尝试过一次性读过这么多的书，即使是中文书也没有挑战过。</p><p>很欣赏伍君仪在《把你的词汇用起来》中的一句话，就是“学英语既然开始了，就一定要把它学好！”。反反复复从”从入门到放弃”浪费时间精力又没有什么效果。于是从2019年7月正式从书虫第一套入门级的第一本《 Survive！》生存游戏开始。入门级相当于小学高年级的水平，当然读起来很流畅很爽。有时候可以一口气看三、四本。入门级每一本都比较薄只有几十页，而且有一半还是中文解释。基本上没有什么挑战。毕竟有近150本怎么才能全部读完呢？我做了个计划给自己规定每天看40页或以上，准备用大半年的时间将这套书全部看完。书虫这套书可读性还是比较强，内容非常丰富，主题多样，包括悬疑、侦探、间谍等多种题材，大部分都是世界名著。小时候读名著读得比较少，这下可以过一下名著的瘾了，虽然是简写版的。尽管是简写版的但是改编得故事性挺强的，非常吸引人，很能提高阅读兴趣。为了让自己能够坚持下去，我每读一本都会在豆瓣上进行标记，并加入到自己的已读英文读本的豆列里。每读完一本就感觉到离胜利越近了一点。前面1至5级读得还很顺利，几乎都可以不用看中文翻译，后面到了第6级以后就有点磕磕绊绊了，有时候需要借助中文翻译才能看懂。不管怎么样，终于在2020年2月9日将全套书虫的最后一本《印度之行》全部读完，历时半年。除了其中11月底有段时间公司加班很厉害确实没有读以外，基本上每天都有阅读。看着满满的一箱书，这一本本标记已读的书，心里还是满满的成就感。</p><p>通过阅读全套书虫的经历，让我建立了学好英语的信心，培养了我阅读英语的兴趣。我想我再也不会“从入门到放弃”了。我花了半年的时间和精力把全套《书虫》都看完了，你要我放弃，那不这半年的努力都白费了吗？</p><p>但是有人可能会问我，看完全套书虫以后你的英语水平达到了什么程度。我想我会很遗憾的告诉你，“革命尚未成功，同志仍需努力”。我也曾经报有幻想，以为看完全套《书虫》自己的英语水平就很牛B了。但是越看到后面越清晰的认识到《书虫》这套书有它的局限性。整套书下来，最高级别的单词量才3000。也是高中毕业大学低年级的水平。也使我清晰的认识到自己目前的英语水平也就是高中毕业大学低年级的水平。一个意外的收获就是通过阅读《书虫》全套，大致的了解了英语的小说文学史，相当于给了我一个目录和一个指引。有哪些好的小说有兴趣可以更加深入的读下去。比如通过阅读书虫对英国文学史上著名的勃朗特三姐妹有了深刻的了解，因为里面有本书是写《勃朗特一家的故事》。这套书里还有《呼啸山庄》和《简·爱》,分别是勃朗特三姐妹中的艾米莉·勃朗特和夏洛蒂·勃朗特的名著，看了他们的简介再读了她们的作品理解更加全面和深刻了。让我有进一步看这两部名著的英文原版的欲望了。还有英国侦探小说女王阿加莎·克里斯蒂有本书《神秘女人——阿加莎•克里斯蒂》就是介绍她的经历和作品，看完以后我立马找了她的中文版的《东方快车谋杀案》看了觉得很有意思。还有狄更斯、哈代等的名作都让人看了还想看。通过这样大量的阅读体验以后，我对名著产生了浓厚的兴趣，我觉得我应该具备了阅读英文原版书的能力。下一个阶段我有信心准备开始我的英文原版书阅读了。今年我的计划是挑战看完十本英文原版书。</p><p>我读过的英文读本豆列： <a href="https://www.douban.com/doulist/118432400/" target="_blank" rel="noopener">https://www.douban.com/doulist/118432400/</a></p><p>爱分享读书豆瓣小组： <a href="https://www.douban.com/group/655112/" target="_blank" rel="noopener">https://www.douban.com/group/655112/</a></p><hr><center>关注：“爱分享读书”微信公众号 </center><p><img src="http://image.ishareread.com/qrcode_for_gh_70fb5d85a824_258.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><center>读书我们是认真的</center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://xiejava1018.github.io/xiejavaimagesrc/images/20200211/blogimage/english.png&quot; alt=&quot;English&quot; title=&quot;English&quot;&gt;&lt;/p&gt;
&lt;p&gt;一直想学
      
    
    </summary>
    
    
      <category term="读书" scheme="http://xiejava.ishareread.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读后感" scheme="http://xiejava.ishareread.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
      <category term="英语" scheme="http://xiejava.ishareread.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>坚持了330天，我终于放弃了背单词</title>
    <link href="http://xiejava.ishareread.com/posts/48451ead/"/>
    <id>http://xiejava.ishareread.com/posts/48451ead/</id>
    <published>2020-02-11T02:01:38.000Z</published>
    <updated>2020-02-14T08:23:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200211/blogimage/bdc.png" alt="不背单词，能学好英语吗？" title="不背单词，能学好英语吗？"><br>不背单词，能学好英语吗？<br>学习英语是我永远的痛，读书的时候没有把英语学好，工作后觉得英语很重要，经历了N多次从坚持到放弃。这一次，我是来真的，发誓不把英语学好不罢休，为此我下载了百词斩。为了有人监督我加入了打卡群，每天坚持英语背单词打卡，这是我坚持做得最好的一件事情，每天早上起床第一件事情就是背单词，每天20-30个，几乎从来没有中断过。但是我坚持到330天后，我还是决定放弃背单词了。为什么呢？因为没效果！！！我已经背完了从小学到大学以及新概念1-2册的单词，APP上显示我的词汇量已经达到7000，超过了80%的网友。可是我看英语文章还是一脸懵逼，即使是最浅的英语读物也有单词不认识。听不懂，更别奢望能说了。英语单词背了忘、忘了背，严重怀疑这个APP上显示7000多的单词量是哄我开心的，要不背了这么久的单词，英语水平还这么菜，依旧啥也看不懂……</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200211/blogimage/englishisharet.png" alt="学英语是会呼吸的痛" title="学英语是会呼吸的痛"></p><p>放弃背单词，并不代表我放弃了英语，因为我找了一本书–《人人都能用英语》。经过傻傻的认为打卡背单词就可以学好英语沉痛而失败的教训后，越发认为这本书相见恨晚。学英语就是要用，要不学英语干啥？坚持非常重要，但是坚持的方向错了一切都是白搭！</p><p>这不是一本英语的单词书、语法书。是一本教你如何学英语，不，应该是如何“用”英语的书。作者是我们都很熟悉的曾经是新东方专业英语老师，现在是比特币首富的–李笑来老师，《把时间当做朋友》的作者。虽然是专业的英语老师，在书中他没有卖弄自己的专业，而是非常真诚的讲述了自己学习英语的过程。整本书解决了我所有学英语的疑惑。</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200211/blogimage/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E7%94%A8%E8%8B%B1%E8%AF%AD1.png" alt="《人人都能用英语》" title="《人人都能用英语》"></p><p>经历了N多次从坚持到放弃，我曾经就差点相信学习英语要有天赋才能学好，自己不是学英语的那块料。在书中作者花了很大量的篇幅来告诉我们，人人都可以学好英语！书中举了个例子，大约在1988年前后，他父亲的同事一位教英语的副教授去考了一次托福，成绩是570（满分677分），一个专职的英语教授考托福才考570分，想想这是个多么难的考试。当年，甚至若干年作者都不敢想象自己能够去考托福。直到2000年底，他急需要一份稳定的工作，想去新东方应聘，他花了4个月的时间专注学习，考了托福，考了GRE，拿了变态的成绩去应聘了新东方成为了那里的英语教师。他以亲身经历说明了一个问题，你学不好，是因为你不信，只有你相信你能做好，你才能真正做好。哪里有那么多天才呢？所谓的天才，只不过是反复练习，持之以恒的结果。</p><p>不要再“学”英语，你就应该“用”英语！这是最触动我的一句话，也是整本书的核心。大部分的人，包括我都是从初中、高中、大学，“学”了近十来年的英语，真正学会的人又有几个呢？只“学”不“用”的下场就是在十几年之后依然在学依然无用。依旧陷入从坚持到放弃的怪圈。学英语的核心其实是在用。只有不断地“用”，才能真正地学到，要不就会一直停留在“学”的阶段。既然不“用”就“学”不好，那不如从一开始就直接“用”。无论如何，一定要想明白对自己来说，英语真正的用处在哪儿？对于很多人来说，其实只要能够流利阅读英语或许已经足够了，至少对我来说已经够了。既然想要流利的阅读英语，那就直接从“用”英语阅读开始，抛开所谓的单词量、语法、语音、语调。不会的单词查字典，看不懂的句子查语法书。不管你是想流利的阅读，还是用英语交流，反正，用就是了。回想一下，也是哦，想想自己小学语文的经历，小学一年级还学下生字，二年级就开始学用字典查生字，以后慢慢的抛开字典可以自由的读写了。</p><p>其实如何通过“用”来学习外语，国学大师、学界泰斗季羡林，季老先生在自己的言传身教中已经说的非常清楚，并且可操作性非常强。他说到：“我想斗胆提出一个，‘无师自通’的办法，供胡同志和其他读者参考。你只需要找一位通德语的人，用上二三个小时，把字母读音学好。从此你就可以丢掉老师这个拐棍，自己行走了。你找一本有可靠的汉文译文的德文科技图书，伴之以一本浅易的德文语法。先把语法了解个大概的情况，不必太深入，就立即读德文原文，字典反正不能离手，语法也放在手边。一开始必然如堕入五里雾中。读不懂，再读，也许不止一遍两遍。等到你认为对原文已经有了一个大概的了解，为了验证自己了解的正确程度，只是到了此时，才把那一本可靠的译本拿过来，看看自己了解得究竟如何。就这样一页页读下去，一本原文读完了，再加以努力，你慢慢就能够读没有汉译本的德文原文了。”</p><p>嗯，我想我可以放心的放弃背单词，拿起我的那本英文版的《Spring in Action》开始慢慢啃了……</p><hr><center>关注：“爱分享读书”微信公众号 </center><p><img src="http://image.ishareread.com/qrcode_for_gh_70fb5d85a824_258.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><center>读书我们是认真的</center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://xiejava1018.github.io/xiejavaimagesrc/images/20200211/blogimage/bdc.png&quot; alt=&quot;不背单词，能学好英语吗？&quot; title=&quot;不背单词，能学好英语吗？&quot;&gt;&lt;br&gt;不背
      
    
    </summary>
    
    
      <category term="读书" scheme="http://xiejava.ishareread.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读后感" scheme="http://xiejava.ishareread.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
      <category term="英语" scheme="http://xiejava.ishareread.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>把时间当作朋友，相信我，你并不孤独</title>
    <link href="http://xiejava.ishareread.com/posts/a0bb2f7e/"/>
    <id>http://xiejava.ishareread.com/posts/a0bb2f7e/</id>
    <published>2020-01-05T10:21:18.000Z</published>
    <updated>2020-02-14T12:48:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200106/blogimage/3.jpg" alt="把时间当做朋友" title="把时间当做朋友"><br>相信我，你并不孤独！自卑、对任何事情都没有兴趣、在工作多年后，对未来还是很迷茫，对自己的效率不满，对自己的能力怀疑。相信在此世间，此时此刻，困恼的不是我一个。  </p><p>《把时间当作朋友》这本书2009年出版，现在这本书已经是第三版了，并且还推出了逻辑思维独家定制版。该书长期在豆瓣上评分都是在8.3分以上，无数人看了以后都感觉到相见恨晚，受益匪浅。作者李笑来原来是新东方的老师，现在号称是投资人，比特币首富。新东方的老师像创始人俞敏洪、锤子手机的老罗、古典等都有个特点，都很都善于灌鸡汤，兜售所谓的成功学，很有煽动性。可以理解像英语那么枯燥有难度的学习过程，如果没有成功学的激励被放弃的几率还是蛮大的。成功离不开鸡血，也少不了鸡汤。   </p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200106/blogimage/4.jpg" alt="《把时间当做朋友》" title="《把时间当做朋友》"><br>《把时间当作朋友》这本书从心智成长的角度来谈时间管理、学习方法、兴趣、人脉等成功的关键所在。虽然书中有个章节是”小心所谓的成功学”。但不可否认，这本书就是告诉大家如何了解时间，和时间做朋友，用心智成长开启自己的人生成功之旅的“成功学”。其中的某些观点和做法我觉得很有道理并值得付之于行动。  </p><p>首先是对时间管理的认识，有很多书都在谈时间管理，而时间每天每个人都只有24小时，都在静静的不以人的意识为转移地流逝。时间它是不会听从任何人的管理，我们无法管理时间，我们真正能够管理的是我们自己。而管理好自己就是需要通过自己的大脑控制自己的大脑，需要有很强的意志力和成熟的心智。  </p><p>管理好自己利用好时间，需要对自己的时间有个清楚的了解，知道自己的时间都花到哪里去了。最有效的办法就是《奇特的一生》的作者，苏联生物学家柳比歇夫的事件-事件日志记录方法。将自己每天做的每件事情都花的多少时间详细的记录下来。想尽一切办法真正了解自己，真正了解时间，精确地感知时间，而后再想办法使自己的行为与时间”合拍”，与时间做朋友。  </p><p>学会了如何利用好自己的时间，接下来的就是行动。什么时候开始行动呢？如果要打算做某件事情，并且想做成的话，应该是立刻、马上、立即、now就开始行动！  </p><p>开始行动后就要学会坚持。所有学习上的成功，都只靠两件事：策略和坚持，而坚持本身就是最重要的策略，坚持其实就是重复，而重复说到底就是时间的投入，任何领域想要取得卓越的成就都必须用一生的努力才能取得，想要出类拔萃，就要努力至少一万小时。</p><h2 id="关于学习方法："><a href="#关于学习方法：" class="headerlink" title="关于学习方法："></a><strong>关于学习方法：</strong></h2><p>除了“试错”、“观察”、“阅读”之外，“思考”准确的说是“正确地思考”才是获得真正意义上的知识的主要手段。<br>提高自学能力</p><ol><li>自学能力的基础技能是阅读理解能力。</li><li>检索能力是建立在相当熟练的阅读能力之上的能力。</li><li>写作能力在自学能力中占据着重要的地位。</li><li>实践能力是自学能力最终能够转换为真正价值的根本。<br>教是最好的学习方法。</li></ol><h2 id="关于兴趣："><a href="#关于兴趣：" class="headerlink" title="关于兴趣："></a><strong>关于兴趣：</strong></h2><p>很多人，包括我自己，不知道自己的兴趣在哪里？或试图要培养自己的兴趣。书中的一段话给我很大的启示，只要一件事你能做好，并且做得比谁都好，或者至少比大多数人好，你就不会对那件事情没兴趣。往往并不是有兴趣才能做好，而是做好了才有兴趣。  </p><p>大多数事情都需要孰能生巧，做得多了，自然就擅长了，擅长了，就自然比别人做得好，做得比别人好，兴趣就大起来了，而后就更加喜欢做，更擅长，更……良性循环。但同样做得多久需要大量的时间投入，没兴趣，往往只不过是结果而已，如果被当做不去做好的理由，最终的惩罚就是大量的时间白白的流逝。</p><h2 id="关于人脉："><a href="#关于人脉：" class="headerlink" title="关于人脉："></a><strong>关于人脉：</strong></h2><p>打造人脉不如打造自己，只有优秀的人才拥有有效的人脉。  </p><p>关于书中讲到了通过自己的大脑控制自己的大脑。其实就是个人意志力的问题，只是书中换了个说法。个人的成功很大程度都是取决于个人意志力。通过意志力控制心智成长，让人成熟，成功。  </p><p>如果你现在还在迷茫，相信我，你并不孤独。把这本书看完吧。再牛逼的人都有段苦逼的经历，如果你还在苦逼的过程中，请把时间当做朋友，沉下心来慢慢学习积累，收获成长，笃性自己能够成功！大家一起共勉。</p><hr><center>关注：“爱分享读书”微信公众号 </center><p><img src="http://image.ishareread.com/qrcode_for_gh_70fb5d85a824_258.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><center>读书我们是认真的</center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://xiejava1018.github.io/xiejavaimagesrc/images/20200106/blogimage/3.jpg&quot; alt=&quot;把时间当做朋友&quot; title=&quot;把时间当做朋友&quot;&gt;&lt;br&gt;相信我，你并不孤独！自卑、对
      
    
    </summary>
    
    
      <category term="读书" scheme="http://xiejava.ishareread.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读后感" scheme="http://xiejava.ishareread.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>终身学习时代，阅读是你大脑的磨刀石</title>
    <link href="http://xiejava.ishareread.com/posts/da35ea85/"/>
    <id>http://xiejava.ishareread.com/posts/da35ea85/</id>
    <published>2020-01-05T08:25:38.000Z</published>
    <updated>2020-03-02T13:52:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200106/blogimage/1.jpg" alt="图书馆" title="图书馆"><br>  在这个互联网信息知识大爆炸的时代，学习能力是每个人的核心能力，如何通过学习把知识转化为自己的能力，拓宽人生的可能性，是每个人孜孜不倦渴求的。而阅读，尤其是高效的阅读是掌握知识最简单、成本最低、也是最高效的学习方式。阅读能力是学习能力的根本，会阅读的人才会具备快速学习的能力和良好思维以及应变能力。认识到这一点，所以想读书的人越来越多，爱读书的人越来越多。但是很多人在阅读或培养阅读的过程中碰到了各种各样的困难和问题。如：知道阅读很重要，但是拿起书就想睡觉根本看不进书；没有时间阅读；读不懂，记不住，用不上等等。市面上也涌现了不少教大家阅读的书籍，如被誉为阅读圣经的《如何阅读一本书》、《越读者》、《书都不会读，你还想成功》、《如何高效读懂一本书》等等。</p><p>  好脑筋需要书本，就如同宝剑需要磨刀石。</p><p><img src="https://xiejava1018.github.io/xiejavaimagesrc/images/20200106/blogimage/2.jpg" alt="好脑筋需要书本，就如同宝剑需要磨刀石" title="好脑筋需要书本，就如同宝剑需要磨刀石"></p><p>  通过阅读我们可以系统性地获取知识，但很多人在阅读习惯养成的前期也会面临很多问题，很多人对阅读有障碍、有困难，实际上是我们对阅读这件事的理解并不清晰透彻，我们应该了解阅读的本质。阅读的本质就是在可以利用的时间里，以你自己能理解的程度去学习。有些初学者了解到阅读的重要性以后，心情非常迫切，一上来就捧起大部头的书，或者比较深奥烧脑的书看，结果要不就是看几页昏昏入睡，要不就是看了几天都看不完，渐渐的失去了耐心，阅读兴趣和想培养的阅读习惯也就在屡次的打击中放弃了。其实要想开始阅读或培养阅读习惯，最有效的办法就是根据自己的能力先从一些入门级的自己感兴趣的书籍着手。在《书都不会读，你还想成功》的书中，就是建议先给自己定个计划读100本书开始，这100本书先抛开任何功利性的想法，不管什么书，只要是自己感兴趣的或者能够看得下去的书就可以，看不下去的书先放一边，通过100本书慢慢培养自己的阅读兴趣和习惯。先有了阅读兴趣和习惯，想看了愿意看了。再来谈阅读方法的问题，通过阅读方法解决看得快，记得牢的问题。再来逐渐选择高于自己目前能力的书籍进行有目的性的阅读。</p><p>  其实阅读方法正如《洋葱阅读法》里所述，无非就是碎片化阅读、快速阅读、主题阅读。不管是那种阅读方法，都是需要带有强烈目的性的阅读，只有有目的的阅读，然后学以致用才能看得快，记得牢，用得上。</p><p>  碎片阅读实际就是利用碎片化的时间，学习碎片化的内容。如何取得碎片化阅读的效果呢？有人每天都碎片化的阅读一些微信文章啥的，但是长期以来除了感觉有些文章写得不错每天点赞外，对自己并没有什么提高呢。其中最关键的就是要建立自己的知识体系。在基于自己的知识体系的基础上将阅读到的碎片化的内容补充到自己的知识体系中建立相应的联系。要不然阅读到的碎片还是碎片，不和已有的知识进行关联，永远都是碎片，久而久之久会忘记掉。没有自己的知识体系就相当于没有建立自己的银行账户，碎片化阅读看到的内容相当于打零工赚回来的钱没有地方放。东放一点，西放一点时间久了自然就忘记了。有了自己的知识体系就相当于建立自己的知识银行账户，打零工赚的钱可以零存整取，不断的往自己的知识体系中填砖加瓦，让自己的知识银行账户余额越存越多。</p><p>  如何构建自己的知识体系呢，就要通过快速阅读和主题阅读。一本书本身的就是某个知识系统化的描述。所以要想系统的构建自己的知识体系，系统的看书是必经之路。</p><p>  快速阅读的本质就是提升阅读的速度，快速掌握书中的知识。核心就是带着问题来阅读。在阅读之前，先了解一下自己读这本书的目的，梳理一下问题，为什么要读这本书，这本书能够解决我什么问题，自己以前有没有读过类似的书等等。通过快速的阅读，在书中找这些问题。有些无关紧要的描述就可以快速略看，与问题相关的仔细阅读。通过变速阅读达到快速了解一本书掌握关键知识点的目的。</p><p>  主题阅读则更是为了构建自己的知识体系，在某个知识主题领域，通过广泛的阅读，同时阅读多本相同主题书的方式来深入对某个知识主题领域学习的过程。其主要目的是搞懂某个主题领域的知识。</p><p>  当然不管是碎片化阅读、快速阅读、主题阅读，要想通过阅读来提高自己的能力，首先要有构建自己知识体系的意识；其次是通过某种方式彻底的搞懂自己没有懂的知识如通过反复阅读，一本书重复多读几遍或通过读同一知识点不同作者写的书来搞懂，或者通过费曼读书法将阅读的知识通过自己的理解用自己的方式讲述给懂的人；最后就是要学以制用，将通过阅读学到的知识在平时的工作、生活、学习等各个方面用起来。只有这样才能真正的通过阅读不断的提高自己的能力，真正找到阅读的乐趣，越读越有味，越读越想读！</p><hr><center>关注：“爱分享读书”微信公众号 </center><p><img src="http://image.ishareread.com/qrcode_for_gh_70fb5d85a824_258.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><center>读书我们是认真的</center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://xiejava1018.github.io/xiejavaimagesrc/images/20200106/blogimage/1.jpg&quot; alt=&quot;图书馆&quot; title=&quot;图书馆&quot;&gt;&lt;br&gt;  在这个互联网信息知识大爆炸的时代，学习能
      
    
    </summary>
    
    
      <category term="读书" scheme="http://xiejava.ishareread.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读后感" scheme="http://xiejava.ishareread.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>用系统方式思考，高效的工作</title>
    <link href="http://xiejava.ishareread.com/posts/f7e86db6/"/>
    <id>http://xiejava.ishareread.com/posts/f7e86db6/</id>
    <published>2020-01-05T08:14:59.000Z</published>
    <updated>2020-02-14T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　用系统方式工作的思想是萨姆·卡彭特在《用系统来工作》的书中提到的。大家可以想想华为、富士康等公司为什么效率高？因为有一套系统化的流程让各个环节高效的运作。所以咱们也可以参考，运用到我们的工作、学习、生活中来，让我们更高效。 </p><p>　　所有工作都可以用系统的视角的思考。如管理公司、上班的日常工作、学一门技能、健身等等。<br>　　首先我们要明确目标，比如管理公司我要达到什么经营目标，学习我要学到什么东西达到什么程度，减肥健身要达到什么效果，一定要有非常清晰的目标，最好是能够写下来，放在显眼的地方，时时关注。<br>　　其次我们要制定准则，即达到实现目标的大的方针，比如减肥健身，准则可以定义为控制饮食、加强锻炼等。<br>　　最后我们要明确做事的流程，如何明确流程？可以按照以下几点整理。<br>　　1、分解每个工作的任务项。<br>　　 将一个工作分解成一个个可以操作的具体任务项。如开会可以分解为确定会议室、准备会议材料、通知会议参与人、做会议纪要、跟踪会议结论执行情况等等。<br>　　 如减肥健身可以分解为：合理饮食、准备活动、有氧运动、肌肉强化运动、睡眠休息等等。<br>　　2、将每个工作任务项按依赖顺序整理形成固化的流程<br>　　 有些工作项是有依赖关系的，所以我们要按照依赖关系顺序整理成流程。先干什么，后干什么，这样做事才会更有条理，减少等待的时间更高效。<br>　　3、给每个工作任务项提供说明指导<br>　　 就是将每个细化的工作项做到最好。在华为，所有的岗位，每项工作都有具体的作业指导书。在作业指导书中详细定义了这个环节需要做什么，具体怎么做，完成后如何检查反馈。这个作业指导书是不断总结完善的。所以不管是老手，还是新来的菜鸟，都可以很好并高效的完成。<br>　　4、在实践的工作中不断完善流程<br>　　 一开始可能流程并不完善，我们可以在实际实施的过程中不断的优化调整，去掉一些不必要的环节，优化一些效率低下的环节，一切优化都是遵循我们开始定义的目标。 </p><p>　　通过系统方式思考做事情可以用到工作、学习、生活的各个方面，总的来说，就是明确目标、制定准则、定义流程，不断完善流程。将事情高效的做好。作为领导者，有了流程后，你还可以将这个流程交给任何一个人都可以做好。将自己释放出来。有更多的时间平衡工作、学习、生活。这就是系统的力量。</p><hr><center>关注：“爱分享读书”微信公众号 </center><p><img src="http://image.ishareread.com/qrcode_for_gh_70fb5d85a824_258.jpg" alt="“爱分享读书”微信公众号" title="“爱分享读书”微信公众号"></p><center>读书我们是认真的</center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　用系统方式工作的思想是萨姆·卡彭特在《用系统来工作》的书中提到的。大家可以想想华为、富士康等公司为什么效率高？因为有一套系统化的流程让各个环节高效的运作。所以咱们也可以参考，运用到我们的工作、学习、生活中来，让我们更高效。 &lt;/p&gt;
&lt;p&gt;　　所有工作都可以用系统的视角
      
    
    </summary>
    
    
      <category term="读书" scheme="http://xiejava.ishareread.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读后感" scheme="http://xiejava.ishareread.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
</feed>
